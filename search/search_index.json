{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DSP-API Docs","text":"<p>DSP-API is part of the DaSCH Service Platform (DSP). The following documentation is intended for developers and users who want to interact with the DSP-API directly through the REST API. For a guide on how to use DSP through the web interface, see the DSP-APP User Guide.</p>"},{"location":"Readme/","title":"DSP-API Documentation","text":"<p>This folder contains the sources to the DSP-API part of documentation published under https://docs.dasch.swiss/ and managed by DSP-DOCS repository.</p>"},{"location":"Readme/#build-and-serve-the-docs-locally","title":"Build and serve the docs locally","text":"<p>Documentation can be build by invoking the following make commands from the project root directory:</p> <pre><code>make docs-install-requirements: ## install requirements\nmake docs-build # build the documentation\nmake docs-serve # serve it locally\n</code></pre>"},{"location":"Readme/#prerequisites","title":"Prerequisites","text":"<p>You will need Graphviz. On macOS:</p> <pre><code>brew install graphviz\n</code></pre> <p>On Linux, use your distribution's package manager.</p>"},{"location":"01-introduction/example-project/","title":"An Example Project","text":"<p>This section introduces some of the basic concepts involved in creating ontologies for DSP projects, by means of a relatively simple example project. Before reading this document, it will be helpful to have some familiarity with the basic concepts explained in knora-base.</p> <p>DSP-API comes with two example projects, called <code>incunabula</code> and <code>images-demo</code>. Here we will consider the <code>incunabula</code> example, which is a reduced version of a real research project on early printed books. It is designed to store an image of each page of each book, as well as RDF data about books, pages, their contents, and relationships between them.</p>"},{"location":"01-introduction/example-project/#the-incunabula-ontology","title":"The Incunabula Ontology","text":"<p>Here we will just focus on some of the main aspects of the ontology. An ontology file typically begins by defining prefixes for the IRIs of other ontologies that will be referred to. First there are some prefixes for ontologies that are very commonly used in RDF:</p> <pre><code>@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .\n@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .\n@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .\n@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .\n@prefix dcterms: &lt;http://purl.org/dc/terms/&gt; .\n</code></pre> <p>The <code>rdf</code>, <code>rdfs</code>, and <code>owl</code> ontologies contain basic properties that are used to define ontology entities. The <code>xsd</code> ontology contains definitions of literal data types such as <code>string</code> and <code>integer</code>. (For more information about these ontologies, see the references in knora-base.) The <code>foaf</code> ontology contains classes and properties for representing people. The <code>dcterms</code> ontology represents Dublin Core metadata.</p> <p>Then we define prefixes for DSP ontologies:</p> <pre><code>@prefix knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt; .\n@prefix salsah-gui: &lt;http://www.knora.org/ontology/salsah-gui#&gt; .\n</code></pre> <p>The <code>knora-base</code> ontology contains DSP-API's core abstractions, and is described in knora-base. The <code>salsah-gui</code> ontology includes properties that DSP projects must use to enable SALSAH, DSP-API's generic virtual research environment.</p> <p>For convenience, we can use the empty prefix to refer to the <code>incunabula</code> ontology itself:</p> <pre><code>@prefix : &lt;http://www.knora.org/ontology/0803/incunabula#&gt; .\n</code></pre> <p>However, outside the ontology file, it would make more sense to define an <code>incunabula</code> prefix to refer to the <code>incunabula</code> ontology.</p>"},{"location":"01-introduction/example-project/#properties","title":"Properties","text":"<p>All the content produced by a DSP project must be stored in Knora resources (see incunabula-resource-classes). Resources have properties that point to different parts of their contents; for example, the <code>incunabula</code> project contains books, which have properties like <code>title</code>. Every property that poitns to a DSP value must be a subproperty of <code>knora-base:hasValue</code>, and every property that points to another Knora resource must be a subproperty of <code>knora-base:hasLinkTo</code>.</p> <p>Here is the definition of the <code>incunabula:title</code> property:</p> <pre><code>:title rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf knora-base:hasValue, dcterms:title ;\n\n  rdfs:label \"Titel\"@de ,\n    \"Titre\"@fr ,\n    \"Titolo\"@it ,\n    \"Title\"@en ;\n\n  knora-base:subjectClassConstraint :book ;\n\n  knora-base:objectClassConstraint knora-base:TextValue ;\n\n  salsah-gui:guiElement salsah-gui:SimpleText ;\n\n  salsah-gui:guiAttribute \"size=80\" ,\n    \"maxlength=255\" .\n</code></pre> <p>The definition of <code>incunabula:title</code> consists of a list of triples, all of which have <code>:title</code> as their subject. To avoid repeating <code>:title</code> for each triple, Turtle syntax allows us to use a semicolon (<code>;</code>) to separate triples that have the same subject. Moreover, some triples also have the same predicate; a comma (<code>,</code>) is used to avoid repeating the predicate. The definition of <code>:title</code> says:</p> <ul> <li><code>rdf:type owl:ObjectProperty</code>: It is an <code>owl:ObjectProperty</code>. There are   two kinds of OWL properties: object properties and datatype properties.   Object properties point to objects, which have IRIs and   can have their own properties. Datatype properties point to literal   values, such as strings and integers.</li> <li><code>rdfs:subPropertyOf knora-base:hasValue, dcterms:title</code>: It is a   subproperty of <code>knora-base:hasValue</code> and <code>dcterms:title</code>. Since the   objects of this property will be Knora values, it must be a   subproperty of <code>knora-base:hasValue</code>. To facilitate searches, we   have also chosen to make it a subproperty of <code>dcterms:title</code>. In the   DSP-API v2, if you do a search for resources that have a certain   <code>dcterms:title</code>, and there is a resource with a matching   <code>incunabula:title</code>, the search results could include that resource.</li> <li><code>rdfs:label \"Titel\"@de</code>, etc.: It has the specified labels in   various languages. These are needed, for example, by user   interfaces, to prompt the user to enter a value.</li> <li><code>knora-base:subjectClassConstraint :book</code>: The subject of the   property must be an <code>incunabula:book</code>.</li> <li><code>knora-base:objectClassConstraint knora-base:TextValue</code>: The object   of this property must be a <code>knora-base:TextValue</code> (which is a   subclass of <code>knora-base:Value</code>).</li> <li><code>salsah-gui:guiElement salsah-gui:SimpleText</code>: When SALSAH asks a   user to enter a value for this property, it should use a simple text   field.</li> <li><code>salsah-gui:guiAttribute \"size=80\" , \"maxlength=255\"</code>: The SALSAH   text field for entering a value for this property should be 80   characters wide, and should accept at most 255 characters.</li> </ul> <p>The <code>incunabula</code> ontology contains several other property definitions that are basically similar. Note that different subclasses of <code>Value</code> are used. For example, <code>incunabula:pubdate</code>, which represents the publication date of a book, points to a <code>knora-base:DateValue</code>. The <code>DateValue</code> class stores a date range, with a specified degree of precision and a preferred calendar system for display.</p> <p>A property can point to a Knora resource instead of to a Knora value. For example, in the <code>incunabula</code> ontology, there are resources representing pages and books, and each page is part of some book. This relationship is expressed using the property <code>incunabula:partOf</code>:</p> <pre><code>:partOf rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf knora-base:isPartOf ;\n\n  rdfs:label \"ist ein Teil von\"@de ,\n    \"est un part de\"@fr ,\n    \"e una parte di\"@it ,\n    \"is a part of\"@en ;\n\n  rdfs:comment \"\"\"Diese Property bezeichnet eine Verbindung zu einer anderen Resource, in dem ausgesagt wird, dass die vorliegende Resource ein integraler Teil der anderen Resource ist. Zum Beispiel ist eine Buchseite ein integraler Bestandteil genau eines Buches.\"\"\"@de ;\n\n  knora-base:subjectClassConstraint :page ;\n\n  knora-base:objectClassConstraint :book ;\n\n  salsah-gui:guiElement salsah-gui:Searchbox .\n</code></pre> <p>The key things to notice here are:</p> <ul> <li><code>rdfs:subPropertyOf knora-base:isPartOf</code>: The <code>knora-base</code> ontology provides a generic <code>isPartOf</code> property to express   part-whole relationships. A project may use <code>knora-base:isPartOf</code> directly, however creating a subproperty such as   <code>incunabula:partOf</code> will allow to customize the property further, e.g. by giving it a more descriptive label.   It is important to note that <code>knora-base:isPartOf</code> is a subproperty of <code>knora-base:hasLinkTo</code>. Any property that   points to a <code>knora-base:Resource</code> must be a subproperty of <code>knora-base:hasLinkTo</code>. Such a   property is called a link property.</li> <li><code>knora-base:objectClassConstraint :book</code>: The object of this property must be a member of the class <code>incunabula:book</code>,   which, as we will see below, is a subclass of <code>knora-base:Resource</code>.</li> <li><code>salsah-gui:guiElement salsah-gui:Searchbox</code>: When SALSAH prompts a user to select the book that a page is part of, it   should provide a search box enabling the user to find the desired book.</li> </ul> <p>Because <code>incunabula:partOf</code> is a link property, it must always accompanied by a link value property, which enables Knora to store metadata about each link that is created with the link property. This metadata includes the date and time when the link was created, its owner, the permissions it grants, and whether it has been deleted. Storing this metadata allows Knora to authorise users to see or modify the link, as well as to query a previous state of a repository in which a deleted link had not yet been deleted. (The ability to query previous states of a repository is planned for DSP-API version 2.)</p> <p>The name of a link property and its link value property must be related by the following naming convention: to determine the name of the link value property, add the word <code>Value</code> to the name of the link property. Hence, the <code>incunabula</code> ontology defines the property <code>partOfValue</code>:</p> <pre><code>:partOfValue rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf knora-base:isPartOfValue ;\n\n  knora-base:subjectClassConstraint :page ;\n\n  knora-base:objectClassConstraint knora-base:LinkValue .\n</code></pre> <p>As a link value property, <code>incunabula:partOfValue</code> must point to a <code>knora-base:LinkValue</code>. The <code>LinkValue</code> class is an RDF reification of a triple (in this case, the triple that links a page to a book). For more details about this, see knora-base-linkvalue.</p> <p>Note that the property <code>incunabula:hasAuthor</code> points to a <code>knora-base:TextValue</code>, because the <code>incunabula</code> project represents authors simply by their names. A more complex project could represent each author as a resource, in which case <code>incunabula:hasAuthor</code> would need to be a subproperty of <code>knora-base:hasLinkTo</code>.</p>"},{"location":"01-introduction/example-project/#resource-classes","title":"Resource Classes","text":"<p>The two main resource classes in the <code>incunabula</code> ontology are <code>book</code> and <code>page</code>. Here is <code>incunabula:book</code>:</p> <pre><code>:book rdf:type owl:Class ;\n\n  rdfs:subClassOf knora-base:Resource , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :title ;\n    owl:minCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasAuthor ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :publisher ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :publoc ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"4\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :pubdate ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :location ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :url ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :description ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :physical_desc ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"9\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :note ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :citation ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :book_comment ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger\n  ] ;\n\n  knora-base:resourceIcon \"book.gif\" ;\n\n  rdfs:label \"Buch\"@de ,\n    \"Livre\"@fr ,\n    \"Libro\"@it ,\n    \"Book\"@en ;\n\n  rdfs:comment \"\"\"Diese Resource-Klasse beschreibt ein Buch\"\"\"@de .\n</code></pre> <p>Like every Knora resource class, <code>incunabula:book</code> is a subclass of <code>knora-base:Resource</code>. It is also a subclass of a number of other classes of type <code>owl:Restriction</code>, which are defined in square brackets, using Turtle's syntax for anonymous blank nodes. Each <code>owl:Restriction</code> specifies a cardinality for a property that is allowed in resources of type <code>incunabula:book</code>. A cardinality is indeed a kind of restriction: it means that a resource of this type may have, or must have, a certain number of instances of the specified property. For example, <code>incunabula:book</code> has cardinalities saying that a book must have at least one title and at most one publication date. In the DSP-API version 1, the word 'occurrence' is used instead of 'cardinality'.</p> <p>The OWL cardinalities supported by Knora are described in OWL Cardinalities.</p> <p>Note that <code>incunabula:book</code> specifies a cardinality of <code>owl:minCardinality 0</code> on the property <code>incunabula:hasAuthor</code>. At first glance, this might seem as if it serves no purpose, since it says that the property is optional and can have any number of instances. You may be wondering whether this cardinality could simply be omitted from the definition of <code>incunabula:book</code>. However, Knora requires every property of a resource to have some cardinality in the resource's class. This is because Knora uses the cardinalities to determine which properties are possible for instances of the class, and the DSP-API relies on this information. If there was no cardinality for <code>incunabula:hasAuthor</code>, Knora would not allow a book to have an author.</p> <p>Each <code>owl:Restriction</code> specifying a cardinality can include the predicate <code>salsah-gui:guiOrder</code>, which tells the SALSAH GUI the order the properties should be displayed in.</p> <p>Here is the definition of <code>incunabula:page</code>:</p> <pre><code>:page rdf:type owl:Class ;\n\n  rdfs:subClassOf knora-base:StillImageRepresentation , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :pagenum ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :partOfValue ;\n    owl:cardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :partOf ;\n    owl:cardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :seqnum ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :description ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :citation ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :page_comment ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :origname ;\n    owl:cardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasLeftSidebandValue ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasLeftSideband ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasRightSidebandValue ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasRightSideband ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :transcription ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger\n  ] ;\n\n  knora-base:resourceIcon \"page.gif\" ;\n\n  rdfs:label \"Seite\"@de ,\n    \"Page\"@fr ,\n    \"Page\"@en ;\n\n  rdfs:comment \"\"\"Eine Seite ist ein Teil eines Buchs\"\"\"@de ,\n    \"\"\"Une page est une partie d'un livre\"\"\"@fr ,\n    \"\"\"A page is a part of a book\"\"\"@en .\n</code></pre> <p>The <code>incunabula:page</code> class is a subclass of <code>knora-base:StillImageRepresentation</code>, which is a subclass of <code>knora-base:Representation</code>, which is a subclass of <code>knora-base:Resource</code>. The class <code>knora-base:Representation</code> is used for resources that contain metadata about files stored by Knora. Each It has different subclasses that can hold different types of files, including still images, audio, and video files. A given <code>Representation</code> can store metadata about several different files, as long as they are of the same type and are semantically equivalent, e.g. are different versions of the same image with different colorspaces, so that coordinates in one file will work in the other files.</p> <p>In Knora, a subclass inherits the cardinalities defined in its superclasses. Let's look at the class hierarchy of <code>incunabula:page</code>, starting with <code>knora-base:Representation</code>:</p> <pre><code>:Representation rdf:type owl:Class ;\n\n  rdfs:subClassOf :Resource , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasFileValue ;\n    owl:minCardinality \"1\"^^xsd:nonNegativeInteger\n  ] ;\n\n  rdfs:comment \"A resource that can store one or more FileValues\"@en .\n</code></pre> <p>This says that a <code>Representation</code> must have at least one instance of the property <code>hasFileValue</code>, which is defined like this:</p> <pre><code>:hasFileValue rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf :hasValue ;\n\n  :subjectClassConstraint :Representation ;\n\n  :objectClassConstraint :FileValue .              \n</code></pre> <p>The subject of <code>hasFileValue</code> must be a <code>Representation</code>, and its object must be a <code>FileValue</code>. There are different subclasses of <code>FileValue</code> for different kinds of files, but we'll skip the details here.</p> <p>This is the definition of <code>knora-base:StillImageRepresentation</code>:</p> <pre><code>:StillImageRepresentation rdf:type owl:Class ;\n\n  rdfs:subClassOf :Representation , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasStillImageFileValue ;\n    owl:minCardinality \"1\"^^xsd:nonNegativeInteger\n  ] ;\n\n  rdfs:comment \"A resource that can contain two-dimensional still image files\"@en .\n</code></pre> <p>It must have at least one instance of the property <code>hasStillImageFileValue</code>, which is defined as follows:</p> <pre><code>:hasStillImageFileValue rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf :hasFileValue ;\n\n  :subjectClassConstraint :StillImageRepresentation ;\n\n  :objectClassConstraint :AbstractStillImageFileValue .              \n</code></pre> <p>Because <code>hasStillImageFileValue</code> is a subproperty of <code>hasFileValue</code>, the cardinality on <code>hasStillImageFileValue</code>, defined in the subclass <code>StillImageRepresentation</code>, overrides the cardinality on <code>hasFileValue</code>, defined in the superclass <code>Representation</code>. In other words, the more general cardinality in the superclass is replaced by a more specific cardinality in the base class. Since <code>incunabula:page</code> is a subclass of <code>StillImageRepresentation</code>, it inherits the cardinality on <code>hasStillImageFileValue</code>. As a result, a page must have at least one image file value attached to it.</p> <p>Here's another example of cardinality inheritance. The class <code>knora-base:Resource</code> has a cardinality for <code>knora-base:seqnum</code>. The idea is that resources of any type could be arranged in some sort of sequence. As we saw above, <code>incunabula:page</code> is a subclass of <code>knora-base:Resource</code>. But <code>incunabula:page</code> has its own cardinality for <code>incunabula:seqnum</code>, which is a subproperty of <code>knora-base:seqnum</code>. Once again, the subclass's cardinality on the subproperty replaces the superclass's cardinality on the superproperty: a page is allowed to have an <code>incunabula:seqnum</code>, but it is not allowed to have a <code>knora-base:seqnum</code>.</p>"},{"location":"01-introduction/file-formats/","title":"File Formats in DSP-API","text":"<p>Currently, only a limited number of file formats is accepted to be uploaded onto DSP. Some metadata is extracted from the files during the ingest but the file formats are not validated. Only image file formats are currently migrated into another format. Both, the migrated version of the file and the original are kept.</p> <p>The following table shows the accepted file formats:</p> Category Accepted format Converted during ingest? Text, XML *) HTML, JSON, ODD, RNG, TXT, XML, XSD, XSL No Tables CSV, XLS, XLSX No 2D Images JPG, JPEG, JP2, PNG, TIF, TIFF Yes, converted to JPEG 2000 by Sipi Audio MPEG (MP3), WAV No Video MP4 No Office EPUB, PDF, DOC, DOCX, PPT, PPTX No Archives ZIP, TAR, GZ, Z, TAR.GZ, TGZ, GZIP, 7Z No <p>*) If your XML files represent text with markup (e.g. TEI/XML), it is possible to store it as Standoff/RDF, as described in the api overview.</p>"},{"location":"01-introduction/legal-info/","title":"Storing Legal Information","text":"<p>Each file representation in the project data may have legal metadata associated with it. This metadata is stored in the FileValue that represents the file.</p> <p>For each file value, the legal information consists of:</p> <ul> <li>Exactly one copyright holder (mandatory when legal information is required)</li> <li>Exactly one license (mandatory when legal information is required)  </li> <li>One or more authorship attributions (mandatory when legal information is required)</li> </ul> <p>Legal Information Will Become Mandatory</p> <p>Currently, the legal information on the FileValue is optional. This will change in the future when License, Authorship, and Copyright Holder will become mandatory.</p>"},{"location":"01-introduction/legal-info/#copyright-holder","title":"Copyright Holder","text":"<p>The copyright holder of the file. A copyright holder is a person or organization that holds the copyright to a file. Each file value has exactly one copyright holder (currently zero or one).</p> <p>Each project references an allowed list of copyright holders that can be used. System project administrators can add new copyright holders to the list.</p>"},{"location":"01-introduction/legal-info/#authorship","title":"Authorship","text":"<p>The authorship of the file. This can be a person or an organization who was involved in creating the asset, also known as moral rights to the asset. Each file value can have one or more authorship attributions (currently zero or more).</p>"},{"location":"01-introduction/legal-info/#license","title":"License","text":"<p>The license under which the file is published. Each file value has exactly one license (currently zero or one). A license has the following properties:</p> <ul> <li><code>uri</code> - this is a URI that identifies the license.</li> <li><code>label-en</code> - this is a human-readable label for the license in English.</li> <li><code>id</code> - this is a unique identifier as an IRI for the license.</li> </ul> <p>Each project knows which licenses are available. From the set of available licenses a project must enable the licenses it needs. New projects will be created with the DaSCH recommended licenses enabled. Only enabled licenses are allowed to be used for project data.</p> <p>Currently, the set of available licenses is fixed and cannot be changed by the project.</p>"},{"location":"01-introduction/legal-info/#available-licenses","title":"Available Licenses","text":"<p>We encourage the use of Creative Commons licenses for the publication of data. Notable CC BY 4.0 (Attribution 4.0 International) and CC BY-SA 4.0 (Attribution-ShareAlike 4.0 International) licenses are well suited for FAIR content.</p>"},{"location":"01-introduction/legal-info/#licenses-recommended-by-dasch","title":"Licenses Recommended by DaSCH","text":"<ul> <li>Creative Commons Licenses<ul> <li>CC BY 4.0 (Attribution 4.0 International)<ul> <li>Id: <code>http://rdfh.ch/licenses/cc-by-4.0</code></li> <li>URI: https://creativecommons.org/licenses/by/4.0/</li> </ul> </li> <li>CC BY-SA 4.0 (Attribution-ShareAlike 4.0 International)<ul> <li>Id: <code>http://rdfh.ch/licenses/cc-by-sa-4.0</code></li> <li>URI: https://creativecommons.org/licenses/by-sa/4.0/</li> </ul> </li> <li>CC BY-NC 4.0 (Attribution-NonCommercial 4.0 International)<ul> <li>Id: <code>http://rdfh.ch/licenses/cc-by-nc-4.0</code></li> <li>URI: https://creativecommons.org/licenses/by-nc/4.0/</li> </ul> </li> <li>CC BY-NC-SA 4.0 (Attribution-NonCommercial-ShareAlike 4.0 International)<ul> <li>Id: <code>http://rdfh.ch/licenses/cc-by-nc-sa-4.0</code></li> <li>URI: https://creativecommons.org/licenses/by-nc-sa/4.0/</li> </ul> </li> <li>CC BY-ND 4.0 (Attribution-NoDerivatives 4.0 International)<ul> <li>Id: <code>http://rdfh.ch/licenses/cc-by-nd-4.0</code></li> <li>URI: https://creativecommons.org/licenses/by-nd/4.0/</li> </ul> </li> <li>CC BY-NC-ND 4.0 (Attribution-NonCommercial-NoDerivatives 4.0 International)<ul> <li>Id: <code>http://rdfh.ch/licenses/cc-by-nc-nd-4.0</code></li> <li>URI: https://creativecommons.org/licenses/by-nc-nd/4.0/</li> </ul> </li> </ul> </li> <li>Special licenses<ul> <li>AI-Generated Content - Not Protected by Copyright<ul> <li>Id: <code>http://rdfh.ch/licenses/ai-generated</code></li> <li>URI: http://rdfh.ch/licenses/ai-generated</li> </ul> </li> <li>Unknown License - Ask Copyright Holder for Permission<ul> <li>Id: <code>http://rdfh.ch/licenses/unknown</code></li> <li>URI: http://rdfh.ch/licenses/unknown</li> </ul> </li> <li>Public Domain - Not Protected by Copyright<ul> <li>Id: <code>http://rdfh.ch/licenses/public-domain</code></li> <li>URI: http://rdfh.ch/licenses/public-domain</li> </ul> </li> </ul> </li> </ul>"},{"location":"01-introduction/legal-info/#other-licenses","title":"Other Licenses","text":"<ul> <li>CC_0_1_0 (CC0 1.0 Universal)<ul> <li>Id: http://rdfh.ch/licenses/cc-0-1.0</li> <li>URI: https://creativecommons.org/publicdomain/zero/1.0/</li> </ul> </li> <li>CC_PDM_1_0 (Public Domain Mark 1.0 Universal)<ul> <li>Id: http://rdfh.ch/licenses/cc-pdm-1.0</li> <li>URI: https://creativecommons.org/publicdomain/mark/1.0/</li> </ul> </li> <li>BORIS Standard License<ul> <li>Id: http://rdfh.ch/licenses/boris</li> <li>URI: https://www.ub.unibe.ch/services/open_science/boris_publications/index_eng.html#collapse_pane631832</li> </ul> </li> <li>LICENCE OUVERTE 2.0<ul> <li>Id: \"http://rdfh.ch/licenses/open-licence-2.0</li> <li>URI: https://www.etalab.gouv.fr/wp-content/uploads/2018/11/open-licence.pdf</li> </ul> </li> <li>No Copyright - Non-Commercial Use Only 1.0<ul> <li>Id: http://rdfh.ch/licenses/noc-nc-1.0</li> <li>URI: http://rightsstatements.org/vocab/NoC-NC/1.0/</li> </ul> </li> </ul>"},{"location":"01-introduction/standoff-rdf/","title":"Standoff/RDF Text Markup","text":"<p>Standoff markup is text markup that is stored separately from the content it describes. DSP-API's Standoff/RDF markup stores content as a simple Unicode string, and represents markup separately as RDF data. This approach has some advantages over commonly used markup systems such as XML:</p> <p>First, XML and other hierarchical markup systems assume that a document is a hierarchy, and have difficulty representing non-hierarchical structures or multiple overlapping hierarchies. Standoff markup can easily represent these structures.</p> <p>Second, markup languages are typically designed to be used in text files. But there is no standard system for searching and linking together many different text files containing markup. It is possible to do this in a non-standard way by using an XML database such as eXist, but this still does not allow for queries that include text as well as non-textual data not stored in XML.</p> <p>By storing markup as RDF, DSP-API can search for markup structures in the same way as it searches for any RDF data structure. This makes it possible to do searches that combine text-related criteria with other sorts of criteria. For example, if persons and events are represented as resources, and texts are represented in Standoff/RDF, a text can contain tags representing links to persons or events. You could then search for a text that mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain time period.</p> <p>In DSP-API's Standoff/RDF, a tag is an RDF entity that is linked to a text value. Each tag points to a substring of the text, and has semantic properties of its own. You can define your own tag classes in your ontology by making subclasses of <code>knora-base:StandoffTag</code>, and attach your own properties to them. You can then search for those properties using DSP-API's search language, Gravsearch.</p> <p>The built-in knora-base and <code>standoff</code> ontologies provide some basic tags that can be reused or extended. These include tags that represent DSP-API data types. For example, <code>knora-base:StandoffDateTag</code> represents a date in exactly the same way as a date value, i.e. as a calendar-independent astronomical date. You can use this tag as-is, or extend it by making a subclass, to represent dates in texts. Gravsearch includes built-in functionality for searching for these data type tags. For example, you can search for text containing a date that falls within a certain date range.</p> <p>DSP-API supports automatic conversion between XML and Standoff/RDF. To make this work, Standoff/RDF stores the order of tags and their hierarchical relationships. You must define an XML-to-Standoff Mapping for your standoff tag classes and properties. Then you can import an XML document into DSP-API, which will store it as Standoff/RDF. The text and markup can then be searched using Gravsearch. When you retrieve the document, DSP-API converts it back to the original XML.</p> <p>To represent overlapping or non-hierarchical markup in exported and imported XML, DSP-API supports CLIX tags.</p> <p>As XML-to-Standoff has proved to be complicated and not very well performing,  the use of standoff with custom mappings is discouraged.  Improved integration of text with XML mark up, particularly TEI-XML, is in planning.</p>"},{"location":"01-introduction/what-is-dsp/","title":"What is DSP and DSP-API?","text":"<p>The DaSCH Service Platform (DSP) is  a content management system for the long-term preservation and reuse of humanities data. It is designed to accommodate data with a complex internal structure, including data that could be stored in relational databases.</p> <p>DSP aims to solve key problems in the long-term preservation and reuse of humanities data:</p> <p>First, traditional archives preserve data, but do not facilitate reuse. Typically, only metadata can be searched, not the data itself. You have to first identify an information package that might be of interest, then download it, and only then can you find out what's really in it. This is time-consuming, and makes it impractical to reuse data from many different sources.</p> <p>DSP solves this problem by keeping the data alive. You can query all the data in a DSP repository, not just the metadata. You can import thousands of databases into DSP, and run queries that search through all of them at once.</p> <p>Another problem is that researchers use a multitude of different file formats, many of which are proprietary and quickly become obsolete. It is not practical to maintain all the programs that were used to create and read old files, or even all the operating systems that these programs ran on. Therefore, DSP only accepts a certain number of file formats.</p> <ul> <li>Non-binary data is stored as   RDF, in a dedicated   database called a triplestore. RDF is an open, vendor-independent standard   that can express any data structure.</li> <li>Binary media files (images, audio, and video) are converted to a few specialised   archival file formats and stored by Sipi,   with metadata stored in the triplestore.</li> </ul> <p>DSP makes this data available for reuse via its generic, standards-based application programming interface DSP-API. A virtual research environment (VRE) can use DSP-API to query, link, and add to data from different research projects in a unified way.</p>"},{"location":"01-introduction/what-is-dsp/#humanities-focused-data-storage","title":"Humanities-Focused Data Storage","text":"<p>Each project creates its own data model (or ontology), describing the types of items it wishes to store, using basic data types defined in Knora's base ontology. This gives projects the freedom to describe their data in a way that makes sense to them, while allowing DSP to support searching and linking across projects.</p> <p>DSP has built-in support for data structures that are commonly needed in humanities data, and that present unique challenges for any type of database storage.</p>"},{"location":"01-introduction/what-is-dsp/#calendar-independent-dates","title":"Calendar-Independent Dates","text":"<p>In the humanities, a date could be based on any sort of calendar (e.g. Gregorian, Julian, Islamic, or Hebrew). The DSP stores dates using a calendar-independent, astronomical representation, and converts between calendars as needed. This makes it possible to search for a date in one calendar, and get search results in other calendars.</p>"},{"location":"01-introduction/what-is-dsp/#flexible-searchable-text-markup","title":"Flexible, Searchable Text Markup","text":"<p>Commonly used text markup systems, such as TEI/XML, have to represent a text as a hierarchy, and therefore have trouble supporting overlapping markup. DSP supports Standoff/RDF markup: the markup is stored as RDF data, separately from the text, allowing for overlapping markup. The DSP can import any XML document (including TEI/XML) for storage as standoff/RDF, and can regenerate the original XML document at any time.</p>"},{"location":"01-introduction/what-is-dsp/#powerful-searches","title":"Powerful Searches","text":"<p>DSP-API provides a search language, Gravsearch, that is designed to meet the needs of humanities researchers. Gravsearch supports DSP-API's humanities-focused data structures, including calendar-independent dates and standoff markup, as well as fast full-text searches. This allows searches to combine text-related criteria with any other criteria. For example, you could search for a text that contains a certain word and also mentions a person who lived in the same city as another person who is the author of a text that mentions an event that occurred during a certain time period.</p>"},{"location":"01-introduction/what-is-dsp/#access-control","title":"Access Control","text":"<p>The RDF standards do not include any concept of permissions. DSP-API's permission system allows project administrators and users to determine who can see or modify each item of data. DSP-API filters search results according to each user's permissions.</p>"},{"location":"01-introduction/what-is-dsp/#data-history","title":"Data History","text":"<p>RDF does not have a concept of data history. DSP-API maintains all previous versions of each item of data. Ordinary searches return only the latest version, but you can obtain and cite an item as it was at any point in the past.</p>"},{"location":"01-introduction/what-is-dsp/#data-consistency","title":"Data Consistency","text":"<p>RDF triplestores do not implement a standardised way of ensuring the consistency of data in a repository. DSP-API ensures that all data is consistent, conforms the project-specific data models, and meets DSP-API's minimum requirements for interoperability and reusability of data.</p>"},{"location":"01-introduction/what-is-dsp/#linked-open-data","title":"Linked Open Data","text":"<p>DSP-API supports publishing data online as Linked Open Data, using open standards to allow interoperability between different repositories on the web.</p>"},{"location":"02-dsp-ontologies/introduction/","title":"Introduction","text":"<p>The DSP ontologies provide a generic framework for describing humanities research data, allowing data from different projects to be combined, augmented, and reused.</p>"},{"location":"02-dsp-ontologies/introduction/#resource-description-framework-rdf","title":"Resource Description Framework (RDF)","text":"<p>DSP-API uses a hierarchy of ontologies based on the Resource Description Framework (RDF), RDF Schema (RDFS), and the Web Ontology Language (OWL). Both RDFS and OWL are expressed in RDF. RDF expresses information as a set of statements (called triples). A triple consists of a subject, a predicate, and an object:</p> <p></p> <p>The object may be either a literal value (such as a name or number) or another subject. Thus it is possible to create complex graphs that connect many subjects, like this:</p> <p></p> <p>In RDF, each subject and predicate has a unique, URL-like identifier called an Internationalized Resource Identifier (IRI). Within a given project, IRIs typically differ only in their last component (the \"local part\"), which is often the fragment following a <code>#</code> character. Such IRIs share a long \"prefix\". In Turtle and similar formats for writing RDF, a short prefix label can be defined to represent the long prefix. Then an IRI can be written as a prefix label and a local part, separated by a colon (<code>:</code>). For example, if the \"example\" project's long prefix is <code>http://www.example.org/rdf#</code>, and it contains subjects with IRIs like <code>http://www.example.org/rdf#book</code>, we can define the prefix label <code>ex</code> to represent the prefix label, and write prefixed names for IRIs:</p> <p></p>"},{"location":"02-dsp-ontologies/introduction/#built-in-ontologies-and-user-created-ontologies","title":"Built-in Ontologies and User-Created Ontologies","text":"<p>To ensure the interoperability of data produced by different projects, each project must describe its data model by creating one or more ontologies that extend Knora's built-in ontologies. The main built-in ontology in Knora is knora-base.</p>"},{"location":"02-dsp-ontologies/introduction/#shared-ontologies","title":"Shared Ontologies","text":"<p>Knora does not normally allow a project to use classes or properties defined in an ontology that belongs to another project. Each project must be free to change its own ontologies, but this is not possible if they have been used in ontologies or data created by other projects.</p> <p>However, an ontology can be defined as shared, meaning that it can be used by multiple projects, and that its creators will not change it in ways that could affect other ontologies or data that are based on it. Specifically, in a shared ontology, existing classes and properties cannot safely be changed, but new ones can be added. (It is not even safe to add an optional cardinality to an existing class, because this could cause subclasses to violate the rule that a class cannot have a cardinality on property P as well as a cardinality on a subproperty of P; see Restrictions on Classes.)</p>"},{"location":"02-dsp-ontologies/knora-base/","title":"The Knora Base Ontology","text":""},{"location":"02-dsp-ontologies/knora-base/#overview","title":"Overview","text":"<p>The Knora base ontology is the main built-in Knora ontology. Each project that uses DSP-API must describe its data model by creating ontologies that extend this ontology.</p> <p>The Knora base ontology is identified by the IRI <code>http://www.knora.org/ontology/knora-base</code>. In the DSP-API documentation in general, it is identified by the prefix <code>knora-base</code>, but for brevity, in this document, we use <code>kb</code> or omit the prefix entirely.</p>"},{"location":"02-dsp-ontologies/knora-base/#the-knora-data-model","title":"The Knora Data Model","text":"<p>The Knora data model is based on the observation that, in the humanities, a value or literal is often itself structured and can be highly complex. Moreover, a value may have its own metadata, such as its creation date, information about permissions, and so on. Therefore, the Knora base ontology describes structured value types that can store this type of metadata. In the diagram below, a book (<code>ex:book2</code>) has a title (identified by the predicate <code>ex:title</code>) and a publication date (<code>ex:pubdate</code>), each of which has some metadata.</p> <p></p>"},{"location":"02-dsp-ontologies/knora-base/#projects","title":"Projects","text":"<p>In DSP-API, each item of data belongs to some particular project. Each project using DSP-API must define a <code>kb:knoraProject</code>, which has these properties (cardinalities are indicated in parentheses after each property name):</p> <ul> <li> <p><code>projectShortname</code> (1): A short name that can be used to identify the project in configuration files and the like.</p> </li> <li> <p><code>projectLongname</code> (0-1): The full name of the project.</p> </li> <li> <p><code>projectShortcode</code> (1): A hexadecimal code that uniquely identifies the project. These codes are assigned to projects   by the DaSCH.</p> </li> <li> <p><code>projectDescription</code> (1-n): A description of the project.</p> </li> </ul> <p>Ontologies and resources are associated with a project by means of the <code>kb:attachedToProject</code> property, as described in Ontologies and Properties of Resource). Users are associated with a project by means of the <code>kb:isInProject</code> property, as described in Users and Groups.</p>"},{"location":"02-dsp-ontologies/knora-base/#ontologies","title":"Ontologies","text":"<p>Each user-created ontology must be defined as an <code>owl:Ontology</code> with the properties <code>rdfs:label</code> and <code>kb:attachedToProject</code>. Since DSP-API v20 <code>kb:lastModificationDate</code> property is also required.</p>"},{"location":"02-dsp-ontologies/knora-base/#resources","title":"Resources","text":"<p>All the content produced by a project (e.g. digitised primary source materials or research data) must be stored in objects that belong to subclasses of <code>kb:Resource</code>, so that DSP-API can query and update that content. Each project using the Knora base ontology must define its own OWL classes, derived from <code>kb:Resource</code>, to represent the types of data it deals with. A subclass of <code>kb:Resource</code> may additionally be a subclass of any other class, e.g. an industry-standard class such as <code>foaf:Person</code>; this can facilitate searches across projects.</p> <p>Resources have properties that point to different parts of the content they contain. For example, a resource representing a book could have a property called <code>hasAuthor</code>, pointing to the author of the book. There are two possible kinds of content in a Knora resource: Knora values (see Values) or links to other resources (see Links Between Resources). Properties that point to Knora values must be subproperties of <code>kb:hasValue</code>, and properties that point to other resources must be subproperties of <code>kb:hasLinkTo</code>. Either of these two types of properties may also be a subproperty of any other property, e.g. an industry-standard property such as <code>foaf:name</code>; this can facilitate searches across projects. Each property definition must specify the types that its subjects and objects must belong to (see Constraints on the Types of Property Subjects and Objects for details).</p> <p>Each user-created resource class definition must use OWL cardinality restrictions to specify the properties that resources of that class can have (see OWL Cardinalities for details).</p> <p>Resources are not versioned; only their values are versioned (see Values).</p> <p>Every resource is required to have an <code>rdfs:label</code>. The object of this property is an <code>xsd:string</code>, rather than a Knora value; hence it is not versioned. A user who has modify permission on a resource (see Authorisation) can change its label.</p> <p>A resource can be marked as deleted; DSP-API does this by adding the predicate <code>kb:isDeleted true</code> to the resource. An optional <code>kb:deleteComment</code> may be added to explain why the resource has been marked as deleted. Deleted resources are normally hidden. They cannot be undeleted, because even though resources are not versioned, it is necessary to be able to find out when a resource was deleted. If desired, a new resource can be created by copying data from a deleted resource.</p>"},{"location":"02-dsp-ontologies/knora-base/#properties-of-resource","title":"Properties of Resource","text":"<ul> <li> <p><code>creationDate</code> (1): The time when the resource was created.</p> </li> <li> <p><code>attachedToUser</code> (1): The user who owns the resource.</p> </li> <li> <p><code>attachedToProject</code> (1): The project that the resource is part of.</p> </li> <li> <p><code>lastModificationDate</code> (0-1): A timestamp indicating when the resource (or one of its values) was last modified.</p> </li> <li> <p><code>seqnum</code> (0-1): The sequence number of the resource, if it is part of an ordered group of resources, such as the pages   in a book.</p> </li> <li> <p><code>isDeleted</code> (1): Indicates whether the resource has been deleted.</p> </li> <li> <p><code>deleteDate</code> (0-1): If the resource has been deleted, indicates when it was deleted.</p> </li> <li> <p><code>deleteComment</code> (0-1): If the resource has been deleted, indicates why it was deleted.</p> </li> </ul> <p>Resources can have properties that point to other resources; see Links Between Resources. A resource grants permissions to groups of users; see Authorisation.</p>"},{"location":"02-dsp-ontologies/knora-base/#representations","title":"Representations","text":"<p>It is not practical to store all data in RDF. In particular, RDF is not a good storage medium for binary data such as images. Therefore, DSP-API stores such data outside the triplestore, in ordinary files. A resource can have metadata about a file attached to it. The technical term for such a resource in the Knora ontology is a Representation. For each file, there is a <code>kb:FileValue</code> in the triplestore containing metadata about the file (see FileValue). DSP-API uses Sipi to store files. The DSP-API provides ways to create file values.</p> <p>A resource that has a file value must belong to one of the subclasses of <code>kb:Representation</code>. Its subclasses include:</p> <ul> <li> <p><code>StillImageRepresentation</code>: A representation referring to a still image file which can be stored in Sipi or an external IIIF server.</p> </li> <li> <p><code>MovingImageRepresentation</code>: A representation containing a video file.</p> </li> <li> <p><code>AudioRepresentation</code>: A representation containing an audio file.</p> </li> <li> <p><code>DDDrepresentation</code>: A representation containing a 3D image file.</p> </li> <li> <p><code>TextRepresentation</code>: A representation containing a formatted text file, such as an XML file.</p> </li> <li> <p><code>DocumentRepresentation</code>: A representation containing a document (such as a PDF file) that is not a text file.</p> </li> <li> <p><code>ArchiveRepresentation</code>: A representation containing an archive file (such as a zip archive).</p> </li> </ul> <p>These classes can be used directly in data, but it is often better to make subclasses of them, to include metadata about the files being stored.</p> <p>The base class of all these classes is <code>Representation</code>, which is not intended to be used directly. It has this property, which its subclasses override:</p> <ul> <li><code>hasFileValue</code> (1): Points to a file value.</li> </ul> <p>There are two ways for a project to design classes for representations. The simpler way is to create a resource class that represents a thing in the world (such as <code>ex:Painting</code>) and also belongs to a subclass of <code>Representation</code>. This is adequate if the class can have only one type of file attached to it. For example, if paintings are represented only by still images, <code>ex:Painting</code> could be a subclass of <code>StillImageRepresentation</code>.</p> <p>The more flexible approach, which is supported by DSP-API v2, is for each <code>ex:Painting</code> to link (using <code>kb:hasRepresentation</code> or a subproperty) to other resources containing files that represent the painting. Each of these other resources can extend a different subclass of <code>Representation</code>. For example, a painting could have a <code>StillImageRepresentation</code> as well as a <code>DDDrepresentation</code>.</p>"},{"location":"02-dsp-ontologies/knora-base/#standard-resource-classes","title":"Standard Resource Classes","text":"<p>In general, each project must define its own subclasses of <code>kb:Resource</code>. However, the Knora base ontology provides some standard subclasses of <code>kb:Resource</code>, which are intended to be used by any project:</p> <ul> <li> <p><code>Region</code>: Represents a region of a <code>Representation</code> (see Representations).</p> </li> <li> <p><code>Annotation</code>: Represents an annotation of a resource.   The <code>hasComment</code> property points to the text of the annotation, represented as a <code>kb:TextValue</code>.</p> </li> <li> <p><code>LinkObj</code>: Represents a link that connects two or more resources.   A <code>LinkObj</code> has a <code>hasLinkTo</code> property pointing to each resource that it connects, as well as a <code>hasLinkToValue</code>   property pointing to a reification of each of these direct links (   see Links Between Resources).   A <code>LinkObj</code> is more complex (and hence less convenient and readable) than a simple direct link, but it has the   advantage that it can be annotated using an <code>Annotation</code>. For improved readability, a project can make its own   subclasses of <code>LinkObj</code> with specific meanings.</p> </li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#values","title":"Values","text":"<p>The Knora base ontology defines a set of OWL classes that are derived from <code>kb:Value</code> and represent different types of structured values found in humanities data. This set of classes may not be extended by user-created ontologies.</p> <p>A value is always part of one particular resource, which points to it using some property derived from <code>hasValue</code>. For example, a user-created ontology could specify a <code>Book</code> class with a property <code>hasSummary</code> (derived from <code>hasValue</code>), and that property could have a <code>knora-base:objectClassConstraint</code> of <code>TextValue</code>. This would mean that the summary of each book is represented as a <code>TextValue</code>.</p> <p>Knora values are versioned. Existing values are not modified. Instead, a new version of an existing value is created. The new version is linked to the old version via the <code>previousValue</code> property.</p> <p>Since each value version has a different IRI, there is no IRI that can be used to cite the value, such that it will always refer to the latest version of the value. Therefore, the latest version of each value has a separate UUID, as the object of the property <code>valueHasUUID</code>. When a new version of the value is created, this UUID is moved to the new version. This makes it possible to cite the latest version of a value by searching for the UUID.</p> <p>\"Deleting\" a value means marking it with <code>kb:isDeleted</code>. An optional <code>kb:deleteComment</code> may be added to explain why the value has been marked as deleted. Deleted values are normally hidden.</p> <p>Most types of values are marked as deleted without creating a new version of the value. However, link values must be treated as a special case. Before a <code>LinkValue</code> can be marked as deleted, its reference count must be decremented to 0. Therefore, a new version of the <code>LinkValue</code> is made, with a reference count of 0, and it is this new version that is marked as deleted.</p> <p>To simplify the enforcement of ontology constraints, and for consistency with resource updates, no new versions of a deleted value can be made; it is not possible to undelete. Instead, if desired, a new value can be created by copying data from a deleted value.</p>"},{"location":"02-dsp-ontologies/knora-base/#properties-of-value","title":"Properties of Value","text":"<ul> <li> <p><code>valueCreationDate</code> (1): The date and time when the value was created.</p> </li> <li> <p><code>attachedToUser</code> (1): The user who owns the value.</p> </li> <li> <p><code>valueHasString</code> (1): A human-readable string representation of the value's contents, which is available to DSP-API's   full-text search index.</p> </li> <li> <p><code>valueHasOrder</code> (0-1): A resource may have several properties of the same type with different values (which will be of   the same class), and it may be necessary to indicate an order in which these values occur. For example, a book may   have several authors which should appear in a defined order. Hence, <code>valueHasOrder</code>, when present, points to an   integer literal indicating the order of a given value relative to the other values of the same property. These   integers will not necessarily start at any particular number, and will not necessarily be consecutive.</p> </li> <li> <p><code>previousValue</code> (0-1): The previous version of the value.</p> </li> <li> <p><code>valueHasUUID</code> (0-1): The UUID that refers to all versions of the value. Only the latest version of the value has this   property.</p> </li> <li> <p><code>isDeleted</code> (1): Indicates whether the value has been deleted.</p> </li> <li> <p><code>deleteDate</code> (0-1): If the value has been deleted, indicates when it was deleted.</p> </li> <li> <p><code>deleteComment</code> (0-1): If the value has been deleted, indicates why it was deleted.</p> </li> </ul> <p>Each Knora value can grant permissions (see Authorisation).</p>"},{"location":"02-dsp-ontologies/knora-base/#subclasses-of-value","title":"Subclasses of Value","text":""},{"location":"02-dsp-ontologies/knora-base/#textvalue","title":"TextValue","text":"<p>Represents text, possibly including markup. The text is the object of the <code>valueHasString</code> property. A line break is represented as a Unicode line feed character (<code>U+000A</code>). The non-printing Unicode character <code>INFORMATION SEPARATOR TWO (U+001E)</code> can be used to separate words that are separated only by standoff markup (see below), so they are recognised as separate in a full-text search index.</p> <p>Markup is stored using this property:</p> <ul> <li> <p><code>valueHasStandoff</code> (0-n): Points to a standoff markup tag. See   Text with Standoff Markup.</p> </li> <li> <p><code>valueHasMapping</code> (0-1): Points to the mapping used to create the standoff markup and to convert it back to the   original XML. See Mapping to Create Standoff From XML.</p> </li> </ul> <p>A text value can have a specified language:</p> <ul> <li><code>valueHasLanguage</code> (0-1): An ISO 639-1 code as string specifying the language of the text.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#datevalue","title":"DateValue","text":"<p>Humanities data includes many different types of dates. A date has a specified calendar, and is always represented as a period with start and end points (which may be equal), each of which has a precision (<code>DAY</code>, <code>MONTH</code>, or <code>YEAR</code>). For <code>GREGORIAN</code> and <code>JULIAN</code> calendars, an optional <code>ERA</code> indicator term (<code>BCE</code>, <code>CE</code>, or <code>BC</code>, <code>AD</code>) can be added to the date, when no era is provided the default era <code>AD</code> will be considered. Internally, the start and end points are stored as two Julian Day Numbers. This calendar-independent representation makes it possible to compare and search for dates regardless of the calendar in which they were entered. Properties:</p> <ul> <li> <p><code>valueHasCalendar</code> (1): The name of the calendar in which the date should be displayed. Currently <code>GREGORIAN</code>,   <code>JULIAN</code>, and <code>ISLAMIC</code> civil calendars are supported.</p> </li> <li> <p><code>valueHasStartJDN</code> (1): The Julian Day Number of the start of the period (an <code>xsd:integer</code>).</p> </li> <li> <p><code>valueHasStartPrecision</code> (1): The precision of the start of the period.</p> </li> <li> <p><code>valueHasEndJDN</code> (1): The Julian Day Number of the end of the period (an <code>xsd:integer</code>).</p> </li> <li> <p><code>valueHasEndPrecision</code> (1): The precision of the end of the period.</p> </li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#timevalue","title":"TimeValue","text":"<p>A Knora time value represents a precise moment in time in the Gregorian calendar. Since nanosecond precision can be included, it is suitable for use as a timestamp. Properties:</p> <ul> <li><code>valueHasTimeStamp</code> (1): An <code>xsd:dateTimeStamp</code>, stored as an <code>xsd:dateTime</code> (because SPARQL does not support   <code>xsd:dateTimeStamp</code>).</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#intvalue","title":"IntValue","text":"<p>Represents an integer. Property:</p> <ul> <li><code>valueHasInteger</code> (1): An <code>xsd:integer</code>.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#colorvalue","title":"ColorValue","text":"<ul> <li><code>valueHasColor</code> (1): A string representing a color. The string encodes a color as hexadecimal RGB values, e.g.   <code>\\#FF0000</code>.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#decimalvalue","title":"DecimalValue","text":"<p>Represents an arbitrary-precision decimal number. Property:</p> <ul> <li><code>valueHasDecimal</code> (1): An <code>xsd:decimal</code>.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#urivalue","title":"UriValue","text":"<p>Represents a non-Knora URI. Property:</p> <ul> <li><code>valueHasUri</code> (1): An <code>xsd:anyURI</code>.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#booleanvalue","title":"BooleanValue","text":"<p>Represents a boolean value. Property:</p> <ul> <li><code>valueHasBoolean</code> (1): An <code>xsd:boolean</code>.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#geomvalue","title":"GeomValue","text":"<p>Represents a geometrical object as a JSON string, using normalized coordinates. Property:</p> <ul> <li><code>valueHasGeometry</code> (1): A JSON string.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#geonamevalue","title":"GeonameValue","text":"<p>Represents a geolocation, using the identifiers found at GeoNames. Property:</p> <ul> <li><code>valueHasGeonameCode</code> (1): The identifier of a geographical feature from GeoNames, represented   as an <code>xsd:string</code>.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#intervalvalue","title":"IntervalValue","text":"<p>Represents a time interval, with precise start and end times on a timeline, e.g. relative to the beginning of an audio or video file. Properties:</p> <ul> <li> <p><code>valueHasIntervalStart</code> (1): An <code>xsd:decimal</code> representing the start of the interval in seconds.</p> </li> <li> <p><code>valueHasIntervalEnd</code> (1): An <code>xsd:decimal</code> representing the end of the interval in seconds.</p> </li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#listvalue","title":"ListValue","text":"<p>Projects often need to define lists or hierarchies of categories that can be assigned to many different resources. Then, for example, a user interface can provide a drop-down menu to allow the user to assign a category to a resource. The <code>ListValue</code> class provides a way to represent these sorts of data structures. It can represent either a flat list or a tree.</p> <p>A <code>ListValue</code> has this property:</p> <ul> <li><code>valueHasListNode</code> (1): Points to a <code>ListNode</code>.</li> </ul> <p>Each <code>ListNode</code> can have the following properties:</p> <ul> <li> <p><code>isRootNode</code> (0-1): Set to <code>true</code> if this is the root node.</p> </li> <li> <p><code>hasSubListNode</code> (0-n): Points to the node's child nodes, if any.</p> </li> <li> <p><code>hasRootNode</code> (0-1): Points to the root node of the list (absent if <code>isRootNode</code> is <code>true</code>).</p> </li> <li> <p><code>listNodePosition</code> (0-1): An integer indicating the node's position in the list of its siblings (absent   if <code>isRootNode</code> is <code>true</code>).</p> </li> <li> <p><code>listNodeName</code> (0-1): The node's human-readable name (absent if <code>isRootNode</code> is <code>true</code>).</p> </li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#filevalue","title":"FileValue","text":"<p>DSP-API can store certain kinds of data outside the triplestore, in files (see Representations). Each digital object that is stored outside the triplestore has associated metadata, which is stored in the triplestore in a <code>kb:FileValue</code>. The base class <code>FileValue</code>, which is not intended to be used directly, has the following properties:</p> <ul> <li> <p>File metadata:</p> <ul> <li><code>internalFilename</code> (1): The name of the file as stored by DSP.</li> <li><code>internalMimeType</code> (1): The MIME type of the file as stored by DSP.</li> <li><code>originalFilename</code> (0-1): The original name of the file when it was uploaded to DSP.</li> <li><code>originalMimeType</code> (0-1): The original MIME type of the file when it was uploaded to DSP.</li> </ul> </li> <li> <p>Legal info metadata</p> <ul> <li><code>hasAuthorship</code> (0-n): Indicates the authorship of the file, each author has their own string literal.</li> <li><code>hasCopyrightHolder</code> (0-1): The copyright holder of the file, a string literal. The project restricts which values are allowed.</li> <li><code>hasLicense</code> (0-1): The license under which the file is published, an IRI to the license. The project restricts which values are allowed.</li> </ul> </li> </ul> <p>The subclasses of <code>FileValue</code>, which are intended to be used directly in data, include:</p> <ul> <li> <p><code>StillImageAbstractFileValue</code>: Contains metadata about a still image file, which can be either <code>StillImageFileValue</code> (an image stored in Sipi) or <code>StillImageExternalFileValue</code> (a reference to an image stored in an external IIIF service).</p> </li> <li> <p><code>MovingImageFileValue</code>: Contains metadata about a video file.</p> </li> <li> <p><code>AudioFileValue</code>: Contains metadata about an audio file.</p> </li> <li> <p><code>DDDFileValue</code>: Contains metadata about a 3D image file.</p> </li> <li> <p><code>TextFileValue</code>: Contains metadata about a text file.</p> </li> <li> <p><code>DocumentFileValue</code>: Contains metadata about a document (such as PDF) that is not a text file.</p> </li> <li> <p><code>ArchiveFileValue</code>: Contains metadata about an archive (such as zio archive).</p> </li> </ul> <p>Each of these classes contains properties that are specific to the type of file it describes. For example, still image files have dimensions, video files have frame rates, and so on.</p> <p><code>FileValue</code> objects are versioned like other values, and the actual files stored by DSP-API are also versioned. Version 1 of the DSP-API does not provide a way to retrieve a previous version of a file, but this feature will be added in a subsequent version of the API.</p>"},{"location":"02-dsp-ontologies/knora-base/#linkvalue","title":"LinkValue","text":"<p>A <code>LinkValue</code> is an RDF \"reification\" containing metadata about a link between two resources. It is therefore a subclass of <code>rdf:Statement</code> as well as of <code>Value</code>. It has these properties:</p> <p><code>rdf:subject</code> (1)</p> <p>:   The resource that is the source of the link.</p> <p><code>rdf:predicate</code> (1)</p> <p>:   The link property.</p> <p><code>rdf:object</code> (1)</p> <p>:   The resource that is the target of the link.</p> <p><code>valueHasRefCount</code> (1)</p> <p>:   The reference count of the link. This is meaningful when the <code>LinkValue</code> describes resource references in Standoff text markup (see StandoffLinkTag). Otherwise, the reference count will always be 1 (if the link exists) or 0 (if it has been deleted).</p> <p>For details about how links are created in DSP-API, see Links Between Resources.</p>"},{"location":"02-dsp-ontologies/knora-base/#externalresvalue","title":"ExternalResValue","text":"<p>Represents a resource that is not stored in the RDF triplestore managed by DSP-API, but instead resides in an external repository managed by some other software. The <code>ExternalResValue</code> contains the information that DSP-API needs in order to access the resource, assuming that a suitable gateway plugin is installed.</p> <p><code>extResAccessInfo</code> (1)</p> <p>:   The location of the repository containing the external resource (e.g. its URL).</p> <p><code>extResId</code> (1)</p> <p>:   The repository-specific ID of the external resource.</p> <p><code>extResProvider</code> (1)</p> <p>:   The name of the external provider of the resource.</p>"},{"location":"02-dsp-ontologies/knora-base/#links-between-resources","title":"Links Between Resources","text":"<p>A link between two resources is expressed, first of all, as a triple, in which the subject is the resource that is the source of the link, the predicate is a \"link property\" (a subproperty of <code>kb:hasLinkTo</code>), and the object is the resource that is the target of the link.</p> <p>It is also useful to store metadata about links. For example, DSP-API needs to know who owns the link, who has permission to modify it, when it was created, and so on. Such metadata cannot simply describe the link property, because then it would refer to that property in general, not to any particular instance in which that property is used to connect two particular resources. To attach metadata to a specific link in RDF, it is necessary to create an RDF \"reification\". A reification makes statements about a particular triple (subject, predicate, object), in this case the triple that expresses the link between the resources. DSP-API uses reifications of type <code>kb:LinkValue</code> (described in LinkValue) to store metadata about links.</p> <p>For example, suppose a project describes paintings that belong to collections. The project can define an ontology as follows (expressed here in Turtle format, and simplified for the purposes of illustration):</p> <pre><code>@prefix kb &lt;http://www.knora.org/ontology/knora-base#&gt; .\n@prefix : &lt;http://www.knora.org/ontology/paintings#&gt; .\n\n:Painting rdf:type owl:Class ;\n    rdfs:subClassOf kb:Resource ,\n        [ rdf:type owl:Restriction ;\n            owl:onProperty :hasArtist ;\n            owl:cardinality 1 ] ,\n        [ rdf:type owl:Restriction ;\n              owl:onProperty :hasTitle ;\n              owl:cardinality 1 ] ;\n        [ rdf:type owl:Restriction ;\n              owl:onProperty :isInCollection ;\n              owl:minCardinality 1 ] ;\n        [ rdf:type owl:Restriction ;\n              owl:onProperty :isInCollectionValue ;\n              owl:minCardinality 1 ] .\n\n:Collection rdf:type owl:Class ;\n    rdfs:subClassOf kb:Resource ,\n        [ rdf:type owl:Restriction ;\n            owl:onProperty :hasCollectionName ;\n            owl:cardinality 1 ] .\n\n:hasArtist rdf:type owl:ObjectProperty ;\n    rdfs:label \"Name of artist\" ;\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint kb:TextValue .\n\n:hasTitle rdf:type owl:ObjectProperty ;\n    rdfs:label \"Title of painting\"\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint kb:TextValue .\n\n:hasCollectionName rdf:type owl:ObjectProperty ;\n    rdfs:label \"Name of collection\" ;\n    kb:subjectClassConstraint :Collection ;\n    kb:objectClassConstraint kb:TextValue .\n</code></pre> <p>To link the paintings to the collection, we must add a \"link property\" to the ontology. In this case, the link property will point from a painting to the collection it belongs to. Every link property must be a subproperty of <code>kb:hasLinkTo</code>.</p> <pre><code>:isInCollection rdf:type owl:ObjectProperty ;\n    rdfs:subPropertyOf kb:hasLinkTo ;\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint :Collection .\n</code></pre> <p>We must then add a \"link value property\", which will point from a painting to a <code>kb:LinkValue</code> (described in LinkValue), which will contain metadata about the link between the property and the collection. In particular, the link value specifies the creator of the link, the date when it was created, and the permissions that determine who can view or modify it. The name of the link value property is constructed using a simple naming convention: the word <code>Value</code> is appended to the name of the link property. In this case, since our link property is called <code>:isInCollection</code>, the link value property must be called <code>:isInCollectionValue</code>. Every link value property must be a subproperty of <code>kb:hasLinkToValue</code>.</p> <pre><code>:isInCollectionValue rdf:type owl:ObjectProperty ;\n    rdfs:subPropertyOf kb:hasLinkToValue ;\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint kb:LinkValue .\n</code></pre> <p>Given this ontology, we can create some RDF data describing a painting and a collection:</p> <pre><code>@prefix paintings &lt;http://www.knora.org/ontology/paintings#&gt; .\n@prefix data &lt;http://www.knora.org/ontology/paintings/data#&gt; .\n\ndata:dali_4587 rdf:type paintings:Painting ;\n    paintings:hasTitle data:value_A ;\n    paintings:hasArtist data:value_B .\n\ndata:value_A rdf:type kb:TextValue ;\n    kb:valueHasString \"The Persistence of Memory\" .\n\ndata:value_B rdf:type kb:TextValue ;\n    kb:valueHasString \"Salvador Dali\" .\n\ndata:pompidou rdf:type paintings:Collection ;\n    paintings:hasCollectionName data:value_C .\n\ndata:value_C rdf:type kb:TextValue ;\n    kb:valueHasString \"Centre Pompidou, Paris\" .\n</code></pre> <p>We can then state that the painting is in the collection:</p> <pre><code>data:dali_4587 paintings:isInCollection data:pompidou ;\n    paintings:isinCollectionValue data:value_D .\n\ndata:value_D rdf:type kb:LinkValue ;\n    rdf:subject data:dali_4587 ;\n    rdf:predicate paintings:isInCollection ;\n    rdf:object data:pompidou ;\n    kb:valueHasRefCount 1 .\n</code></pre> <p>This creates a link (<code>paintings:isInCollection</code>) between the painting and the collection, along with a reification containing metadata about the link. We can visualise the result as the following graph:</p> <p></p> <p>DSP-API allows a user to see a link if the requesting user has permission to see the source and target resources as well as the <code>kb:LinkValue</code>.</p>"},{"location":"02-dsp-ontologies/knora-base/#part-whole-relations-between-resources","title":"Part-Whole-Relations between Resources","text":""},{"location":"02-dsp-ontologies/knora-base/#ispartof","title":"isPartOf","text":"<p>A special case of linked resources are part-of related resources, i.e. a resource consisting of several other resources. In order to create a part-of relation between two resources, the resource that is part of another resource needs to have a property that is either <code>kb:isPartOf</code> or a subproperty thereof. <code>kb:isPartOf</code> itself is a subproperty of <code>kb:hasLinkTo</code>. Same as described above for link properties, a corresponding part-of value property is created automatically. This value property has the same name as the part-of property with <code>Value</code> appended. For example, if in an ontology <code>data</code> a property <code>data:partOf</code> was defined, the corresponding value property would be named <code>data:partOfValue</code>. This newly created property <code>data:partOfValue</code> is defined as a subproperty of <code>kb:isPartOfValue</code>.</p> <p>Part-of relations are recommended for resources of type <code>kb:StillImageRepresentation</code>. In that case, the resource that is part of another resource needs to have a property <code>kb:seqnum</code> or a subproperty thereof, with an integer as value. A client can then use this information to leaf through the parts of the compound resource (p.ex. to leaf through the pages of a book like in this example).</p>"},{"location":"02-dsp-ontologies/knora-base/#segment","title":"Segment","text":"<p>DSP-API supports the creation of segment resources. A segment is a part of a resource which has a temporal extent; the segment is defined by a start and end time relative to the resource. Segments are modelled as resources of type <code>kb:Segment</code>, having the properties <code>kb:isSegmentOf</code>, a LinkValue pointing to the resource the segment is part of, and <code>kb:hasSegmentBounds</code>, a IntervalValue representing the temporal extent of the segment. However, <code>kb:Segment</code> is \"abstract\" and cannot be used directly in data.</p> <p>Segments have a number of optional, generic properties to add additional information: <code>kb:hasTitle</code> (0-1), <code>kb:hasDescription</code> (0-n), <code>kb:hasKeyword</code> (0-n), <code>kb:relatesTo</code>/<code>kb:relatesToValue</code> (0-n), and <code>kb:hasComment</code> (0-1).</p> <p>There are two concrete subclasses of <code>kb:Segment</code> for video and audio resources.</p> <p>It is possible to create subclasses of <code>kb:AudioSegment</code> and <code>kb:VideoSegment</code> to add additional properties, but this is discouraged and may not be supported in future versions of DSP-API. Instead, instances of <code>kb:Annotation</code> pointing to the segment should be used to add additional information.</p>"},{"location":"02-dsp-ontologies/knora-base/#audiosegment","title":"AudioSegment","text":"<p>Audio segments are defined by the following properties:</p> <ul> <li><code>kb:isAudioSegmentOf</code> (1): A LinkValue pointing to an AudioRepresentation.</li> <li><code>kb:hasSegmentBounds</code> (1): An IntervalValue representing the temporal extent of the segment.</li> <li><code>kb:hasTitle</code> (0-1): A TextValue for adding a title or name to the segment.</li> <li><code>kb:hasDescription</code> (0-n): A TextValue for providing one or more descriptions of the segment.</li> <li><code>kb:hasKeyword</code> (0-n): A TextValue for adding one or more keywords to the segment.</li> <li><code>kb:relatesTo</code>/<code>kb:relatesToValue</code> (0-n): A LinkValue for relating the segment to another resource.</li> <li><code>kb:hasComment</code> (0-1): A TextValue for a comment on the segment.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#videosegment","title":"VideoSegment","text":"<p>Video segments are defined by the following properties:</p> <ul> <li><code>kb:isVideoSegmentOf</code> (1): A LinkValue pointing to a MovingImageRepresentation.</li> <li><code>kb:hasSegmentBounds</code> (1): An IntervalValue representing the temporal extent of the segment.</li> <li><code>kb:hasTitle</code> (0-1): A TextValue for adding a title or name to the segment.</li> <li><code>kb:hasDescription</code> (0-n): A TextValue for providing one or more descriptions of the segment.</li> <li><code>kb:hasKeyword</code> (0-n): A TextValue for adding one or more keywords to the segment.</li> <li><code>kb:relatesTo</code>/<code>kb:relatesToValue</code> (0-n): A LinkValue for relating the segment to another resource.</li> <li><code>kb:hasComment</code> (0-1): A TextValue for a comment on the segment.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#text-with-standoff-markup","title":"Text with Standoff Markup","text":"<p>DSP-API is designed to be able to store text with markup, which can indicate formatting and structure, as well as the complex observations involved in transcribing handwritten manuscripts. One popular way of representing text in the humanities is to encode it in XML using the Text Encoding Initiative (TEI) guidelines. In DSP-API, a TEI/XML document can be stored as a file with attached metadata, but this is not recommended, because it does not allow to perform searches across multiple documents.</p> <p>The recommended way to store text with markup in DSP-API is to use the built-in support for \"standoff\" markup, which is stored separately from the text. This has some advantages over embedded markup such as XML. While XML requires markup to have a hierarchical structure, and does not allow overlapping tags, standoff nodes do not have these limitations (see  Using Standoff Properties for Marking-up Historical Documents in the Humanities). A standoff tag can be attached to any substring in the text by giving its start and end positions. Unlike in corpus linguistics, we do not use any tokenisation resulting in a form of predefined segmentation, which would limit the user's ability to freely annotate any ranges in the text.</p> <p>For example, suppose we have the following text:</p> <pre><code>&lt;blockquote&gt;This &lt;i&gt;sentence &lt;strong&gt;has overlapping&lt;/strong&gt;&lt;/i&gt; &lt;strong&gt;visual&lt;/strong&gt; attributes.&lt;/blockquote&gt;\n</code></pre> <p>This would require just two standoff tags: <code>(italic, start=5, end=29)</code> and <code>(bold, start=14, end=36)</code>.</p> <p>Moreover, standoff makes it possible to mark up the same text in different, possibly incompatible ways, allowing for different interpretations without making redundant copies of the text. In the Knora base ontology, any text value can have standoff tags.</p> <p>By representing standoff as RDF triples, DSP-API makes markup searchable across multiple text documents in a repository. For example, if a repository contains documents in which references to persons are indicated in standoff, it is straightforward to find all the documents mentioning a particular person. DSP-API's standoff support is intended to make it possible to convert documents with embedded, hierarchical markup, such as TEI/XML, into RDF standoff and back again, with no data loss, thus bringing the benefits of RDF to existing TEI-encoded documents.</p> <p>In the Knora base ontology, a <code>TextValue</code> can have one or more standoff tags. Each standoff tag indicates the start and end positions of a substring in the text that has a particular attribute. The OWL class <code>kb:StandoffTag</code>, which is the base class of all standoff node classes, has these properties:</p> <ul> <li><code>standoffTagHasStart</code> (1): The index of the first character in the text that has the attribute.</li> <li><code>standoffTagHasEnd</code> (1): The index of the last character in the text that has the attribute, plus 1.</li> <li><code>standoffTagHasUUID</code> (1): A UUID identifying this instance and those corresponding to it in later versions of   the <code>TextValue</code> it belongs to.   The UUID is a means to maintain a reference to a particular range of a text also when new versions are made and   standoff   tag IRIs change.</li> <li><code>standoffTagHasOriginalXMLID</code> (0-1): The original ID of the XML element that the standoff tag represents, if any.</li> <li><code>standoffTagHasStartIndex</code> (1): The start index of the standoff tag. Start indexes are numbered from 0 within the   context of a particular text.   When several standoff tags share the same start position, they can be nested correctly with this information when   transforming them to XML.</li> <li><code>standoffTagHasEndIndex</code> (1): The end index of the standoff tag. Start indexes are numbered from 0 within the context   of a particular text.   When several standoff tags share the same end position, they can be nested correctly with this information when   transforming   them to XML.</li> <li><code>standoffTagHasStartParent</code> (0-1): Points to the parent standoff tag. This corresponds to the original nesting of tags   in XML. If a standoff tag has no parent, it represents the XML root element.   If the original XML element is a CLIX tag, it represents the start of a virtual (non syntactical) hierarchy.</li> <li><code>standoffTagHasEndParent</code> (0-1): Points to the parent standoff tag if the original XML element is a CLIX tag and   represents the end of a virtual (non syntactical) hierarchy.</li> </ul> <p>The <code>StandoffTag</code> class is not used directly in RDF data; instead, its subclasses are used. A few subclasses are currently provided in <code>standoff-onto.ttl</code>. Projects are able to define their own custom standoff tag classes (direct subclasses of <code>StandoffTag</code> or one of the standoff data type classes or subclasses of one of the standoff classes defined in <code>standoff-onto.ttl</code>).</p>"},{"location":"02-dsp-ontologies/knora-base/#subclasses-of-standofftag","title":"Subclasses of StandoffTag","text":""},{"location":"02-dsp-ontologies/knora-base/#standoff-data-type-tags","title":"Standoff Data Type Tags","text":"<p>Associates data in some Knora value type with a substring in a text. Standoff data type tags are subclasses of <code>ValueBase</code> classes.</p> <ul> <li><code>StandoffLinkTag</code> Indicates that a substring refers to another <code>kb:Resource</code>. See StandoffLinkTag.</li> <li><code>StandoffInternalReferenceTag</code> Indicates that a substring refers to another standoff tag in the same text value.   See Internal Links in a TextValue.</li> <li><code>StandoffUriTag</code> Indicates that a substring is associated with a URI, which is stored in the same form that is used   for <code>kb:UriValue</code>. See UriValue.</li> <li><code>StandoffDateTag</code> Indicates that a substring represents a date, which is stored in the same form that is used   for <code>kb:DateValue</code>. See DateValue.</li> <li><code>StandoffColorTag</code> Indicates that a substring represents a color, which is stored in the same form that is used   for <code>kb:ColorValue</code>. See ColorValue.</li> <li><code>StandoffIntegerTag</code> Indicates that a substring represents an integer, which is stored in the same form that is used   for <code>kb:IntegerValue</code>. See IntValue.</li> <li><code>StandoffDecimalTag</code> Indicates that a substring represents a number with fractions, which is stored in the same form   that is used for <code>kb:DecimalValue</code>. See DecimalValue.</li> <li><code>StandoffIntervalTag</code> Indicates that a substring represents an interval, which is stored in the same form that is used   for <code>kb:IntervalValue</code>. See IntervalValue.</li> <li><code>StandoffBooleanTag</code> Indicates that a substring represents a Boolean, which is stored in the same form that is used   for <code>kb:BooleanValue</code>. See BooleanValue.</li> <li><code>StandoffTimeTag</code> Indicates that a substring represents a timestamp, which is stored in the same form that is used   for <code>kb:TimeValue</code>. See TimeValue.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#standofflinktag","title":"StandoffLinkTag","text":"<p>A <code>StandoffLinkTag</code> Indicates that a substring is associated with a Knora resource. For example, if a repository contains resources representing persons, a text could be marked up so that each time a person's name is mentioned, a <code>StandoffLinkTag</code> connects the name to the Knora resource describing that person. It has the following property:</p> <p><code>standoffTagHasLink</code> (1): The IRI of the resource that is referred to.</p> <p>One of the design goals of the Knora base ontology is to make it easy and efficient to find out which resources contain references to a given resource. Direct links are easier and more efficient to query than indirect links. Therefore, when a text value contains a resource reference in its standoff nodes, DSP-API automatically creates a direct link between the containing resource and the target resource, along with an RDF reification (a <code>kb:LinkValue</code>) describing the link, as discussed in Links Between Resources. In this case, the link property is always <code>kb:hasStandoffLinkTo</code>, and the link value property (which points to the <code>LinkValue</code>) is always <code>kb:hasStandoffLinkToValue</code>.</p> <p>DSP-API automatically updates direct links and reifications for standoff resource references when text values are updated. To do this, it keeps track of the number of text values in each resource that contain at least one standoff reference to a given target resource. It stores this number as the reference count of the <code>LinkValue</code> (see LinkValue) describing the direct link. Each time this number changes, it makes a new version of the <code>LinkValue</code>, with an updated reference count. When the reference count reaches zero, it removes the direct link and makes a new version of the <code>LinkValue</code>, marked with <code>kb:isDeleted</code>.</p> <p>For example, if <code>data:R1</code> is a resource with a text value in which the resource <code>data:R2</code> is referenced, the repository could contain the following triples:</p> <pre><code>data:R1\n    ex:hasComment data:V1 .\n\ndata:V1\n    rdf:type            kb:TextValue ;\n    kb:valueHasString   \"This link is internal.\" ;\n    kb:valueHasStandoff data:SO1 .\n\ndata:SO1\n    rdf:type                kb:StandoffLinkTag ;\n    kb:standoffTagHasStart: 5 ;\n    kb:standoffTagHasEnd:   9 ;\n    kb:standoffTagHasLink   data:R2 .\n\ndata:R1\n    kb:hasStandoffLinkTo data:R2 .\n\ndata:R1\n    kb:hasStandoffLinkToValue data:LV1 .\n\ndata:LV1\n    rdf:type            kb:LinkValue ;\n    rdf:subject         data:R1 ;\n    rdf:predicate       kb:hasStandoffLinkTo ;\n    rdf:object          data:R2 ;\n    kb:valueHasRefCount 1 .\n</code></pre> <p>The result can be visualized like this:</p> <p></p> <p>Link values created automatically for resource references in standoff are visible to all users, and the creator of these link values is always <code>kb:SystemUser</code> (see Users and Groups). The DSP-API server allows a user to see a standoff link if the user has permission to see the source and target resources.</p>"},{"location":"02-dsp-ontologies/knora-base/#internal-links-in-a-textvalue","title":"Internal Links in a TextValue","text":"<p>Internal links in a <code>TextValue</code> can be represented using the data type standoff class <code>StandoffInternalReferenceTag</code> or a subclass of it. It has the following property:</p> <p><code>standoffTagHasInternalReference</code> (1): Points to a <code>StandoffTag</code> that belongs to the same <code>TextValue</code>. It has an <code>objectClassConstraint</code> of <code>StandoffTag</code>.</p> <p>For links to a <code>kb:Resource</code>, see StandoffLinkTag.</p>"},{"location":"02-dsp-ontologies/knora-base/#mapping-to-create-standoff-from-xml","title":"Mapping to Create Standoff From XML","text":"<p>A mapping allows for the conversion of an XML document to RDF-standoff and back. A mapping defines one-to-one relations between XML elements (with or without a class) and attributes and standoff classes and properties (see XML to Standoff Mapping).</p> <p>A mapping is represented by a <code>kb:XMLToStandoffMapping</code> which contains one or more <code>kb:MappingElement</code>. A <code>kb:MappingElement</code> maps an XML element (including attributes) to a standoff class and standoff properties. It has the following properties:</p> <ul> <li><code>mappingHasXMLTagname</code> (1): The name of the XML element that is mapped to a standoff class.</li> <li><code>mappingHasXMLNamespace</code> (1): The XML namespace of the XML element that is mapped to a standoff class. If no namespace   is given, <code>noNamespace</code> is used.</li> <li><code>mappingHasXMLClass</code> (1): The name of the class of the XML element. If it has no class, <code>noClass</code> is used.</li> <li><code>mappingHasStandoffClass</code> (1): The standoff class the XML element is mapped to.</li> <li><code>mappingHasXMLAttribute</code> (0-n): Maps XML attributes to standoff properties using <code>MappingXMLAttribute</code>. See below.</li> <li><code>mappingHasStandoffDataTypeClass</code> (0-1): Indicates the standoff data type class of the standoff class the XML element   is mapped to.</li> <li><code>mappingElementRequiresSeparator</code> (1): Indicates if there should be an invisible word separator inserted after the XML   element in the RDF-standoff representation.   Once the markup is stripped, text segments that belonged to different elements may be concatenated.</li> </ul> <p>A <code>MappingXMLAttribute</code> has the following properties:</p> <ul> <li><code>mappingHasXMLAttributename</code>: The name of the XML attribute that is mapped to a standoff property.</li> <li><code>mappingHasXMLNamespace</code>: The namespace of the XML attribute that is mapped to a standoff property. If no namespace is   given, <code>noNamespace</code> is used.</li> <li><code>mappingHasStandoffProperty</code>: The standoff property the XML attribute is mapped to.</li> </ul> <p>DSP-API includes a standard mapping used by the DSP APP. It has the IRI <code>http://rdfh.ch/standoff/mappings/StandardMapping</code> and defines mappings for a few elements used to write texts with simple markup.</p>"},{"location":"02-dsp-ontologies/knora-base/#standoff-in-digital-editions","title":"Standoff in Digital Editions","text":"<p>DSP-API's standoff is designed to make it possible to convert XML documents to standoff and back. One application for this feature is an editing workflow in which an editor works in an XML editor, and the resulting XML documents are converted to standoff and stored in the DSP, where they can be searched and annotated.</p> <p>If an editor wants to correct text that has been imported from XML into standoff, the text can be exported as XML, edited, and imported again. To preserve annotations on standoff tags across edits, each tag can automatically be given a UUID. In a future version of the Knora base ontology, it may be possible to create annotations that point to UUIDs rather than to IRIs. When a text is exported to XML, the UUIDs can be included in the XML. When the edited XML is imported again, it can be converted to new standoff tags with the same UUIDs. Annotations that applied to standoff tags in the previous version of the text will therefore also apply to equivalent tags in the new version.</p> <p>When text is converted from XML into standoff, tags are also given indexes, which are numbered from 0 within the context of a particular text. This makes it possible to order tags that share the same position, and to preserve the hierarchy of the original XML document. An ordinary, hierarchical XML tag is converted to a standoff tag that has one index, as well as the index of its parent tag, if any. The Knora base ontology also supports non-hierarchical markup such as CLIX, which enables overlapping markup to be represented in XML. When non-hierarchical markup is converted to standoff, both the start position and the end position of the standoff tag have indexes and parent indexes.</p> <p>To support these features, a standoff tag can have these additional properties:</p> <ul> <li><code>standoffTagHasStartIndex</code> (0-1): The index of the start position.</li> <li><code>standoffTagHasEndIndex</code> (0-1): The index of the end position, if this is a non-hierarchical tag.</li> <li><code>standoffTagHasStartParent</code> (0-1): The IRI of the tag, if any, that contains the start position.</li> <li><code>standoffTagHasEndParent</code> (0-1): The IRI of the tag, if any, that contains the end position, if this is a   non-hierarchical tag.</li> <li><code>standoffTagHasUUID</code> (0-1): A UUID that can be used to annotate a standoff tag that may be present in different   versions of a text,   or in different layers of a text (such as a diplomatic transcription and an edited critical text).</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#querying-standoff-in-sparql","title":"Querying Standoff in SPARQL","text":"<p>A future version of DSP-API may provide an API for querying standoff markup. In the meantime, it is possible to query it directly in SPARQL. For example, here is a SPARQL query (using RDFS inference) that finds all the text values that have a standoff date tag referring to Christmas Eve 2016, contained in a <code>StandoffItalicTag</code>:</p> <pre><code>PREFIX knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt;\nPREFIX standoff: &lt;http://www.knora.org/ontology/standoff#&gt;\n\nselect * where {\n    ?standoffTag a knora-base:StandoffDateTag  .\n\n    ?standoffTag knora-base:valueHasStartJDN ?dateStart .\n    ?standoffTag knora-base:valueHasEndJDN ?dateEnd .\n\n    FILTER (2457747  &lt;= ?dateEnd &amp;&amp; 2457747  &gt;= ?dateStart)\n\n    ?standoffTag knora-base:standoffTagHasStartParent ?parent .\n    ?parent a standoff:StandoffItalicTag .\n\n    ?textValue knora-base:valueHasStandoff ?standoffTag .\n    ?textValue knora-base:valueHasString ?string .\n\n    ?standoffTag knora-base:standoffTagHasStart ?startPos .\n    ?standoffTag knora-base:standoffTagHasEnd ?endPos .  \n}\n</code></pre>"},{"location":"02-dsp-ontologies/knora-base/#authorisation","title":"Authorisation","text":""},{"location":"02-dsp-ontologies/knora-base/#users-and-groups","title":"Users and Groups","text":"<p>Each DSP-API user is represented by an object belonging to the class <code>kb:User</code>, which is a subclass of <code>foaf:Person</code>, and has the following properties:</p> <p><code>userid</code> (1)</p> <p>:   A unique identifier that the user must provide when logging in.</p> <p><code>password</code> (1)</p> <p>:   A cryptographic hash of the user's password.</p> <p><code>email</code> (0-n)</p> <p>:   Email addresses belonging to the user.</p> <p><code>isInProject</code> (0-n)</p> <p>:   Projects that the user is a member of.</p> <p><code>isInGroup</code> (0-n)</p> <p>:   user-created groups that the user is a member of.</p> <p><code>foaf:familyName</code> (1)</p> <p>:   The user's family name.</p> <p><code>foaf:givenName</code> (1)</p> <p>:   The user's given name.</p> <p>DSP-API's concept of access control is that an object (a resource or value) can grant permissions to groups of users (but not to individual users). There are several built-in groups:</p> <p><code>knora-admin:UnknownUser</code></p> <p>:   Any user who has not logged into DSP-API is automatically assigned to this group.</p> <p><code>knora-admin:KnownUser</code></p> <p>:   Any user who has logged into DSP-API is automatically assigned to this group.</p> <p><code>knora-admin:ProjectMember</code></p> <p>:   When checking a user's permissions on an object, the user is automatically assigned to this group if she is a member of the project that the object belongs to.</p> <p><code>knora-admin:Creator</code></p> <p>:   When checking a user's permissions on an object, the user is automatically assigned to this group if he is the creator of the object.</p> <p><code>knora-admin:ProjectAdmin</code></p> <p>:   When checking a user's permissions on an object, the user is automatically assigned to this group if she is an administrator of the project that the object belongs to.</p> <p><code>knora-admin:SystemAdmin</code></p> <p>:   The group of DSP-API system administrators.</p> <p>A user-created ontology can define additional groups, which must belong to the OWL class <code>knora-admin:UserGroup</code>.</p> <p>There is one built-in <code>knora-admin:SystemUser</code>, which is the creator of link values created automatically for resource references in standoff markup (see StandoffLinkTag).</p>"},{"location":"02-dsp-ontologies/knora-base/#permissions","title":"Permissions","text":"<p>Each resource or value can grant certain permissions to specified user groups. These permissions are represented as the object of the predicate <code>kb:hasPermissions</code>, which is required on every <code>kb:Resource</code> and on the current version of every <code>kb:Value</code>. The permissions attached to the current version of a value also apply to previous versions of the value. Value versions other than the current one do not have this predicate.</p> <p>The following permissions can be granted:</p> <ol> <li>Restricted view permission (RV) Allows a restricted view of the object, e.g. a view of an image with a watermark.</li> <li>View permission (V) Allows an unrestricted view of the object. Having view permission on a resource only affects    the user's ability to view information about the resource other than its values. To view a value, she must have view    permission on the value itself.</li> <li>Modify permission (M) For values, this permission allows a new version of a value to be created. For resources,    this allows the user to create a new value (as opposed to a new version of an existing value), or to change    information about the resource other than its values. When he wants to make a new version of a value, his permissions    on the containing resource are not relevant. However, when he wants to change the target of a link, the old link must    be deleted and a new one created, so he needs modify permission on the resource.</li> <li>Delete permission (D) Allows the item to be marked as deleted.</li> <li>Change rights permission (CR) Allows the permissions granted by the object to be changed.</li> </ol> <p>Each permission in the above list implies all lower-numbered permissions. A user's permission level on a particular object is calculated in the following way:</p> <ol> <li>Make a list of the groups that the user belongs to, including    <code>Creator</code> and/or <code>ProjectMember</code> if applicable.</li> <li>Make a list of the permissions that she can obtain on the object, by iterating over the permissions that the object    grants. For each permission, if she is in the specified group, add the specified permission to the list of    permissions she can obtain.</li> <li>From the resulting list, select the highest-level permission.</li> <li>If the result is that she would have no permissions, give her whatever permission <code>UnknownUser</code> would have.</li> </ol> <p>To view a link between resources, a user needs permission to view the source and target resources. He also needs permission to view the <code>LinkValue</code> representing the link, unless the link property is <code>hasStandoffLinkTo</code> (see StandoffLinkTag).</p> <p>The format of the object of <code>kb:hasPermissions</code> is as follows:</p> <ul> <li>Each permission is represented by the one-letter or two-letter abbreviation given above.</li> <li>Each permission abbreviation is followed by a space, then a comma-separated list of groups that the permission is   granted to.</li> <li>The IRIs of built-in groups are shortened using the <code>knora-admin</code>   prefix.</li> <li>Multiple permissions are separated by a vertical bar (<code>|</code>).</li> </ul> <p>For example, if an object grants view permission to unknown and known users, and modify permission to project members, the resulting permission literal would be:</p> <pre><code>V knora-admin:UnknownUser,knora-admin:KnownUser|M knora-admin:ProjectMember\n</code></pre>"},{"location":"02-dsp-ontologies/knora-base/#consistency-checking","title":"Consistency Checking","text":"<p>DSP-API tries to enforce repository consistency by checking constraints that are specified in the Knora base ontology and in user-created ontologies. Three types of consistency rules are enforced:</p> <ul> <li>Cardinalities in OWL class definitions must be satisfied.</li> <li>Constraints on the types of the subjects and objects of OWL object properties must be satisfied.</li> <li>A datatype property may not have an empty string as an object.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#owl-cardinalities","title":"OWL Cardinalities","text":"<p>As noted in Resources, each subclass of <code>Resource</code> must use OWL cardinality restrictions to specify the properties it can have. More specifically, a resource is allowed to have a property that is a subproperty of <code>kb:hasValue</code> or <code>kb:hasLinkTo</code> only if the resource's class has some cardinality for that property. Similarly, a value is allowed to have a subproperty of <code>kb:valueHas</code> only if the value's class has some cardinality for that property.</p> <p>DSP-API supports, and attempts to enforce, the following cardinality constraints:</p> <ul> <li> <p><code>owl:cardinality 1</code>:   Exactly One <code>1</code> - A resource of this class must have exactly one instance of the specified property.</p> </li> <li> <p><code>owl:minCardinality 1</code>:   At Least One <code>1-n</code> - A resource of this class must have at least one instance of the specified property.</p> </li> <li> <p><code>owl:maxCardinality 1</code>:   Zero Or One <code>0-1</code> - A resource of this class must have either zero or one instance of the specified property.</p> </li> <li> <p><code>owl:minCardinality 0</code>:   Unbounded <code>0-n</code> - A resource of this class may have zero or more instances of the specified property.</p> </li> </ul> <p>DSP-API requires cardinalities to be defined using blank nodes, as in the following example from <code>knora-base</code>:</p> <pre><code>:Representation rdf:type owl:Class ;\n    rdfs:subClassOf :Resource ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasFileValue ;\n          owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] .\n\n:StillImageRepresentation rdf:type owl:Class ;\n    rdfs:subClassOf :Representation ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasStillImageFileValue ;\n          owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] .\n</code></pre> <p>The cardinality of a link property must be the same as the cardinality of the corresponding link value property.</p> <p>Each <code>owl:Restriction</code> may have the predicate <code>salsah-gui:guiOrder</code> to indicate the order in which properties should be displayed in a GUI (see The SALSAH GUI Ontology).</p> <p>A resource class inherits cardinalities from its superclasses. This follows from the rules of RDFS inference. Also, in DSP-API, cardinalities in the subclass can override cardinalities that would otherwise be inherited from the superclass. Specifically, if a superclass has a cardinality on a property P, and a subclass has a cardinality on a subproperty of P, the subclass's cardinality overrides the superclass's cardinality. In the example above, <code>hasStillImageFileValue</code> is a subproperty of <code>hasFileValue</code>. Therefore, the cardinality on <code>hasStillImageFileValue</code> overrides (i.e. replaces) the one on <code>hasFileValue</code>.</p> <p>Note that, unlike cardinalities, predicates of properties are not inherited. If <code>:foo rdfs:subPropertyOf :bar</code>, this does not mean that <code>:foo</code> inherits anything from <code>:bar</code>. Any predicates of <code>:foo</code> that are also needed by <code>:bar</code> must be defined explicitly on <code>:bar</code>. This design decision was made because property predicate inheritance is not provided by RDFS inference, and would make it more difficult to check the correctness of ontologies, while providing little practical benefit.</p> <p>For more information about OWL cardinalities, see the OWL 2 Primer.</p>"},{"location":"02-dsp-ontologies/knora-base/#constraints-on-the-types-of-property-subjects-and-objects","title":"Constraints on the Types of Property Subjects and Objects","text":"<p>When a user-created ontology defines a property, it must indicate the types that are allowed as objects (and, if possible, as subjects) of the property. This is done using the following Knora-specific properties:</p> <p><code>subjectClassConstraint</code></p> <p>:   Specifies the class that subjects of the property must belong to. This constraint is recommended but not required. DSP-API will attempt to enforce this constraint.</p> <p><code>objectClassConstraint</code></p> <p>:   If the property is an object property, specifies the class that objects of the property must belong to. Every subproperty of <code>kb:hasValue</code> or a <code>kb:hasLinkTo</code> (i.e. every property of a resource that points to a <code>kb:Value</code> or to another resource) is required to have this constraint, because DSP-API relies on it to know what type of object to expect for the property. DSP-API will attempt to enforce this constraint.</p> <p><code>objectDatatypeConstraint</code></p> <p>:   If the property is a datatype property, specifies the type of literals that can be objects of the property. DSP-API will not attempt to enforce this constraint, but it is useful for documentation purposes.</p> <p>Note that it is possible for a subproperty to have a more restrictive contraint than its base property, by specifing a subject or object class that is a subclass of the one specified in the base property. However, it is not possible for the subproperty to make the base property's constraint less restrictive.</p> <p>See also Why doesn't DSP-API use <code>rdfs:domain</code> and <code>rdfs:range</code> for consistency checking?</p>"},{"location":"02-dsp-ontologies/knora-base/#consistency-constraint-example","title":"Consistency Constraint Example","text":"<p>A user-created ontology could define consistency constraints as in this simplified example:</p> <pre><code>:book rdf:type owl:Class ;\n    rdfs:subClassOf knora-base:Resource ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasTitle ;\n          owl:cardinality \"1\"^^xsd:nonNegativeInteger ] ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasAuthor ;\n          owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] .\n\n:hasTitle rdf:type owl:ObjectProperty ;\n    knora-base:subjectClassConstraint :book ;\n    knora-base:objectClassConstraint knora-base:TextValue .\n\n:hasAuthor rdf:type owl:ObjectProperty ;\n    knora-base:subjectClassConstraint :book ;\n    knora-base:objectClassConstraint knora-base:TextValue .\n</code></pre>"},{"location":"02-dsp-ontologies/knora-base/#summary-of-restrictions-on-user-created-ontologies","title":"Summary of Restrictions on User-Created Ontologies","text":"<p>An ontology can refer to a Knora ontology in another project only if the other ontology is built-in or shared (see Shared Ontologies).</p>"},{"location":"02-dsp-ontologies/knora-base/#restrictions-on-classes","title":"Restrictions on Classes","text":"<ul> <li>Each class must be a subclass of either <code>kb:Resource</code> or   <code>kb:StandoffTag</code>, but not both (note that this forbids user-created subclasses of <code>kb:Value</code>).</li> <li>All the cardinalities that a class defines directly (i.e. does not inherit from <code>kb:Resource</code>) must be on properties   that are defined in the triplestore.</li> <li>Within the cardinalities of a class, there must be a link value property for each link property and vice versa.</li> <li>The cardinality of a link property must be the same as the cardinality of the corresponding link value property.</li> <li>A cardinality on a property with a boolean value must be   <code>owl:cardinality 1</code> or <code>owl:maxCardinality 1</code>.</li> <li>Each class must be a subclass of all the classes that are subject class constraints of the properties in its   cardinalities.</li> <li>If it's a resource class, all its directly defined cardinalities must be on Knora resource properties (subproperties   of <code>kb:hasValue</code>   or <code>kb:hasLinkTo</code>), and all its base classes with Knora IRIs must also be resource classes. A cardinality   on <code>kb:resourceProperty</code> or   <code>kb:hasValue</code> is forbidden. It must also have an <code>rdfs:label</code>.</li> <li>If it's a standoff class, none of its cardinalities may be on Knora resource properties, and all its base classes with   Knora IRIs must also be standoff classes.</li> <li>A class cannot have a cardinality on property P as well as a cardinality on a subproperty of P.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#restrictions-on-properties","title":"Restrictions on properties","text":"<ul> <li>The property's subject class constraint, if provided, must be a subclass of <code>kb:Resource</code> or <code>kb:StandoffTag</code>, and   must be a subclass of the subject class constraints of all its base properties.</li> <li>Its object class constraint, if provided, must be a subclass of the object class constraints of all its base   properties.</li> <li>If the property is a Knora resource property, it must have an object class constraint and an <code>rdfs:label</code>.</li> <li>It can't be a subproperty of both <code>kb:hasValue</code> and <code>kb:hasLinkTo</code>.</li> <li>It can't be a subproperty of <code>kb:hasFileValue</code>.</li> <li>Each of its base properties that has a Knora IRI must also be a Knora resource property.</li> </ul>"},{"location":"02-dsp-ontologies/knora-base/#standardisation","title":"Standardisation","text":"<p>The DaSCH intends to coordinate the standardisation of generally useful entities proposed in user-created ontologies. We envisage a process in which two or more projects would initiate the process by starting a public discussion on proposed entities to be shared. Once a consensus was reached, the DaSCH would publish these entities in a Shared Ontology).</p>"},{"location":"02-dsp-ontologies/knora-base/#knora-ontology-versions","title":"Knora Ontology Versions","text":"<p>The Knora base ontology has the property <code>kb:ontologyVersion</code>, whose object is a string that indicates the deployed version of all the DSP-API built-in ontologies. This allows the repository update program to determine which repository updates are needed when DSP-API is upgraded.</p>"},{"location":"02-dsp-ontologies/salsah-gui/","title":"The SALSAH GUI Ontology","text":""},{"location":"02-dsp-ontologies/salsah-gui/#overview","title":"Overview","text":"<p>The SALSAH GUI ontology provides entities that can be used in user-created ontologies to indicate to SALSAH (or to another GUI) how data should be entered and displayed.</p> <p>The SALSAH GUI ontology is identified by the IRI <code>http://www.knora.org/ontology/salsah-gui</code>. In the Knora documentation in general, it is identified by the prefix <code>salsah-gui</code>, but for brevity, we omit the prefix in this document.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#properties","title":"Properties","text":""},{"location":"02-dsp-ontologies/salsah-gui/#guiorder","title":"guiOrder","text":"<p><code>guiOrder</code> can be attached to a cardinality in a resource class, to indicate the order in which properties should be displayed in the GUI. The object is a non-negative integer. For example, a property with <code>guiOrder</code> 0 would be displayed first, followed by a property with <code>guiOrder</code> 1, and so on.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#guielement","title":"guiElement","text":"<p><code>guiElement</code> can be attached to a property definition to indicate which GUI element should be used to enter data for the property. This should be one of the individuals of class <code>Guielement</code> described below.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#guiattribute","title":"guiAttribute","text":"<p><code>guiAttribute</code> can be attached to a property definition to provide attributes for the GUI element specified in <code>guiElement</code>. The objects of this predicate are written in a DSL with the following syntax:</p> <pre><code>object          = attribute name, \"=\", attribute value ;\nattribute name  = identifier ;\nidentifier      = letter , { letter } ;\nattribute value = integer | decimal | percent | string | iri ;\npercent         = integer, \"%\" ;\niri             = \"&lt;\", string, \"&gt;\" ;\n</code></pre> <p>The attributes used with each GUI element are described below under Individuals.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#guiattributedefinition","title":"guiAttributeDefinition","text":"<p><code>guiAttributeDefinition</code> is used only in the <code>salsah-gui</code> ontology itself, as a predicate attached to instances of <code>Guielement</code> (see Individuals), to specify the attributes that can be given as objects of <code>guiAttribute</code> when a given <code>Guielement</code> is used. The objects of this predicate are written in a DSL with the following syntax:</p> <pre><code>object              = attribute name, [ \"(required)\" ], \":\", attribute type, [ enumerated values ] ;\nenumerated values   = \"(\", enumerated value, { \"|\", enumerated value } \")\" ;\nattribute name      = identifier ;\nattribute type      = \"integer\" | \"decimal\" | \"percent\" | \"string\" | \"iri\" ;\nenumerated value    = identifier ;\nidentifier          = letter , { letter } ;\n</code></pre> <p>Enumerated values are allowed only if <code>attribute type</code> is <code>string</code>. If enumerated values are provided for an attribute, the attribute value given via <code>guiAttribute</code> must be one of the enumerated values.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#classes","title":"Classes","text":""},{"location":"02-dsp-ontologies/salsah-gui/#guielement_1","title":"Guielement","text":"<p>The instances of class <code>Guielement</code> are individuals representing GUI elements for data entry.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#individuals","title":"Individuals","text":""},{"location":"02-dsp-ontologies/salsah-gui/#colorpicker","title":"Colorpicker","text":"<p><code>Colorpicker</code> is a GUI element for selecting a color. A property definition that uses this element may also contain a <code>guiAttribute</code> predicate whose object is a string in the form <code>\"ncolors=N\"</code>, where <code>N</code> is an integer specifying the number of colors to display.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#date","title":"Date","text":"<p><code>Date</code> is a GUI element for selecting a date.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#geometry","title":"Geometry","text":"<p><code>Geometry</code> is a GUI element for selecting the geometry of a two-dimensional region.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#geonames","title":"Geonames","text":"<p><code>Geonames</code> is a GUI element for selecting a Geonames identifier.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#interval","title":"Interval","text":"<p><code>Interval</code> is a GUI element for selecting a time interval in an audio or video recording.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#list","title":"List","text":"<p><code>List</code> is a GUI element for selecting an item in a hierarchical list (see ListValue). A property definition that uses this element must also contain this <code>guiAttribute</code> predicate:</p> <p><code>\"hlist=&lt;LIST_IRI&gt;\"</code>, where <code>LIST_IRI</code> is the IRI of a <code>knora-base:ListNode</code> that is the root node of a hierarchical list.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#pulldown","title":"Pulldown","text":"<p><code>Pulldown</code> is a GUI element for selecting an item in a flat list (see ListValue) using a pull-down menu. A property definition that uses this element must also contain this <code>guiAttribute</code> predicate:</p> <p><code>\"hlist=&lt;LIST_IRI&gt;\"</code>, where <code>LIST_IRI</code> is the IRI of a <code>knora-base:ListNode</code> that is the root node of a hierarchical list.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#radio","title":"Radio","text":"<p><code>Radio</code> is a GUI element for selecting an item in a flat list (see ListValue) using radio buttons. A property definition that uses this element must also contain this <code>guiAttribute</code> predicate:</p> <p><code>\"hlist=&lt;LIST_IRI&gt;\"</code>, where <code>LIST_IRI</code> is the IRI of a <code>knora-base:ListNode</code> that is the root node of a hierarchical list.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#richtext","title":"Richtext","text":"<p><code>Richtext</code> is a GUI element for editing multi-line formatted text.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#searchbox","title":"Searchbox","text":"<p><code>Searchbox</code> is a GUI element for searching for a resource by matching text in its <code>rdfs:label</code>.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#simpletext","title":"SimpleText","text":"<p><code>SimpleText</code> is a GUI element for editing a single line of unformatted text. A property definition that uses this element may also contain a <code>guiAttribute</code> predicate with one or both of the following objects:</p> <ul> <li><code>\"size=N\"</code>, where <code>N</code> is an integer specifying the size of the   text field.</li> <li><code>\"maxlength=N\"</code>, where <code>N</code> is an integer specifying the maximum   length of the string to be input.</li> </ul>"},{"location":"02-dsp-ontologies/salsah-gui/#slider","title":"Slider","text":"<p><code>Slider</code> is a GUI element for choosing numerical values using a slider. A property definition that uses this element must also contain a <code>guiAttribute</code> predicate with both of the following objects:</p> <ul> <li><code>\"min=N\"</code>, where <code>N</code> is an integer specifying the minimum value   of the input.</li> <li><code>\"max=N\"</code>, where <code>N</code> is an integer specifying the maximum value   of the input.</li> </ul>"},{"location":"02-dsp-ontologies/salsah-gui/#spinbox","title":"Spinbox","text":"<p><code>Spinbox</code> is a GUI element for choosing numerical values using a spinbox. A property definition that uses this element may also contain a <code>guiAttribute</code> predicate with one or both of the following objects:</p> <ul> <li><code>\"min=N\"</code>, where <code>N</code> is an integer specifying the minimum value   of the input.</li> <li><code>\"max=N\"</code>, where <code>N</code> is an integer specifying the maximum value   of the input.</li> </ul>"},{"location":"02-dsp-ontologies/salsah-gui/#textarea","title":"Textarea","text":"<p><code>Textarea</code> is a GUI element for editing multi-line unformatted text. A property definition that uses this element may also contain a <code>guiAttribute</code> predicate with one or more of the following objects:</p> <ul> <li><code>\"width=N\"</code>, where <code>N</code> is a percentage of the window width (an   integer followed by <code>%</code>).</li> <li><code>\"cols=N\"</code>, where <code>N</code> is an integer representing the number of   colums in the text entry box.</li> <li><code>\"rows=N\"</code>, where <code>N</code> is an integer specifying the height of the   text entry box in rows.</li> <li><code>\"wrap=W\"</code>, where <code>W</code> is <code>soft</code> or <code>hard</code> (see   wrap).</li> </ul>"},{"location":"02-dsp-ontologies/salsah-gui/#checkbox","title":"Checkbox","text":"<p><code>Checkbox</code> is a GUI element for choosing a boolean value using a checkbox.</p>"},{"location":"02-dsp-ontologies/salsah-gui/#fileupload","title":"Fileupload","text":"<p><code>Fileupload</code> is a GUI element for uploading a file.</p>"},{"location":"03-endpoints/openapi/","title":"OpenAPI Documentation","text":"<p>We provide automatically generated OpenAPI documentation for the DSP API. The OpenAPI specification is available both as YAML specification files and through Swagger UI.</p> <p>The documentation for the version currently deployed in production can be found at:</p> <ul> <li>OpenAPI Specification (YAML)</li> <li>Swagger UI</li> </ul> <p>The documentation for the current main branch can be found at:</p> <ul> <li>OpenAPI Specification (YAML)</li> <li>Swagger UI</li> </ul> <p>Documentation for any other server is available on the according routes:</p> <ul> <li>OpenAPI Specification (YAML): <code>/api/docs/docs.yaml</code></li> <li>Swagger UI: <code>/api/docs/</code></li> </ul> <p>With the API URL prefixed. That is: <code>http://localhost:3333</code> when running the API locally,  or <code>https://api.{server}.dasch.swiss</code> when running on a server.</p>"},{"location":"03-endpoints/api-admin/groups/","title":"Groups Endpoint","text":""},{"location":"03-endpoints/api-admin/groups/#endpoint-overview","title":"Endpoint Overview","text":"<p>Group Operations:</p> <ul> <li><code>GET: /admin/groups</code> : return all groups</li> <li><code>GET: /admin/groups/&lt;groupIri&gt;</code> : return single group identified by [IRI]</li> <li><code>POST: /admin/groups</code> : create a new group</li> <li><code>PUT: /admin/groups/&lt;groupIri&gt;</code> : update groups's basic information</li> <li><code>PUT: /admin/groups/&lt;groupIri&gt;/status</code> : update group's status</li> <li><code>DELETE: /admin/groups/&lt;groupIri&gt;</code> : delete group (set status to false)</li> </ul> <p>Member Operations:</p> <ul> <li><code>GET: /admin/groups/&lt;groupIri&gt;/members</code> : return all group members</li> </ul>"},{"location":"03-endpoints/api-admin/groups/#group-operations","title":"Group Operations","text":""},{"location":"03-endpoints/api-admin/groups/#create-group","title":"Create Group","text":"<ul> <li>Required permission: SystemAdmin / hasProjectAllAdminPermission   / hasProjectAllGroupAdminPermission</li> <li>Required information: name (unique inside project), project IRI</li> <li>Optional information: group descriptions</li> <li>Returns information about the newly created group</li> <li>POST: <code>/admin/groups</code></li> <li>BODY:</li> </ul> <pre><code>    {\n  \"name\": \"NewGroup\",\n  \"descriptions\": [\n    {\n      \"value\": \"NewGroupDescription\",\n      \"language\": \"en\"\n    },\n    {\n      \"value\": \"NeueGruppenBeschreibung\",\n      \"language\": \"de\"\n    }\n  ],\n  \"project\": \"http://rdfh.ch/projects/00FF\",\n  \"status\": true,\n  \"selfjoin\": false\n}\n</code></pre> <p>Additionally, each group can have an optional custom IRI (of @ref:Knora IRI form) specified by the <code>id</code> in the request body as below:</p> <pre><code>    {\n  \"id\": \"http://rdfh.ch/groups/00FF/a95UWs71KUklnFOe1rcw1w\",\n  \"name\": \"GroupWithCustomIRI\",\n  \"descriptions\": [\n    {\n      \"value\": \"A new group with a custom IRI\",\n      \"language\": \"en\"\n    }\n  ],\n  \"project\": \"http://rdfh.ch/projects/00FF\",\n  \"status\": true,\n  \"selfjoin\": false\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/groups/#update-group-information","title":"Update group information","text":"<ul> <li>Required permission: SystemAdmin / hasProjectAllAdminPermission   / hasProjectAllGroupAdminPermission /   hasProjectRestrictedGroupAdminPermission (for this group)</li> <li>Changeable information: <code>name</code>, <code>descriptions</code>, <code>selfjoin</code></li> <li>TypeScript Docs: groupFormats - ChangeGroupApiRequestADM</li> <li>PUT: <code>/admin/groups/&lt;groupIri&gt;</code></li> <li>BODY:</li> </ul> <pre><code>{\n  \"name\": \"UpdatedGroupName\",\n  \"descriptions\": [\n    {\n      \"value\": \"UpdatedGroupDescription\",\n      \"language\": \"en\"\n    }\n  ],\n  \"selfjoin\": false\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/groups/#change-group-status","title":"Change Group Status","text":"<ul> <li>Required permission: SystemAdmin / hasProjectAllAdminPermission</li> <li>Changeable information: <code>status</code></li> <li>Remark: Deleting a group, removes all members from the group.</li> <li>PUT: <code>/admin/groups/&lt;groupIri&gt;/status</code></li> <li>BODY:</li> </ul> <pre><code>{\n  \"status\": false\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/groups/#delete-group","title":"Delete Group","text":"<ul> <li>Required permission: SystemAdmin / hasProjectAllAdminPermission</li> <li>Remark: The same as changing the groups <code>status</code> to   <code>false</code>. To un-delete, set <code>status</code> to <code>true</code>.</li> <li>DELETE: <code>/admin/groups/&lt;groupIri&gt;</code></li> </ul> <p>Example Group Information stored in admin named graph: :</p> <pre><code>&lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;\n     rdf:type knora-admin:UserGroup ;\n     knora-admin:groupName \"Name of the group\" ;\n     knora-admin:groupDescriptions \"A description of the group\"@en ;\n     knora-admin:belongsToProject &lt;http://rdfh.ch/projects/[UUID]&gt; ;\n     knora-admin:status \"true\"^^xsd:boolean ;\n     knora-admin:hasSelfJoinEnabled \"false\"^^xsd:boolean .\n</code></pre>"},{"location":"03-endpoints/api-admin/groups/#member-operations","title":"Member Operations","text":""},{"location":"03-endpoints/api-admin/groups/#get-group-members","title":"Get Group Members","text":"<ul> <li>Returns all group members</li> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>GET: <code>/admin/groups/&lt;groupIri&gt;/members</code></li> </ul>"},{"location":"03-endpoints/api-admin/introduction/","title":"Introduction: Using the Admin API","text":"<p>The DSP Admin API makes it possible to administrate projects, users, user groups, permissions, and hierarchical lists.</p>"},{"location":"03-endpoints/api-admin/introduction/#restful-api","title":"RESTful API","text":"<p>The Knora Admin API is a RESTful API that allows for reading and adding of administrative resources from and to Knora and changing their values using HTTP requests. The actual data is submitted as JSON (request and response format). The various HTTP methods are applied according to the widespread practice of RESTful APIs: GET for reading, POST for adding, PUT for changing resources and values, and DELETE to delete resources or values (see Using HTTP Methods for RESTful Services).</p>"},{"location":"03-endpoints/api-admin/introduction/#knora-iris-in-the-admin-api","title":"Knora IRIs in the Admin API","text":"<p>Every resource that is created or hosted by Knora is identified by a unique ID called an Internationalized Resource Identifier (IRI).  The IRI is required for every API operation to identify the resource in question.  A Knora IRI has itself the format of a URL.  For some API operations, the IRI has to be URL-encoded (HTTP GET requests).</p> <p>Unlike the DSP-API v2, the admin API uses internal IRIs, i.e. the actual IRIs that are stored in the triplestore (see Knora IRIs).</p>"},{"location":"03-endpoints/api-admin/introduction/#admin-path-segment","title":"Admin Path Segment","text":"<p>Every request to Admin API includes <code>admin</code> as a path segment, e.g. <code>http://host/admin/users/iri/http%3A%2F%2Frdfh.ch%2Fusers%2Froot</code>.</p>"},{"location":"03-endpoints/api-admin/introduction/#admin-api-response-format","title":"Admin API Response Format","text":"<p>If an API request is handled successfully, Knora responds with a 200 HTTP status code. The actual answer from Knora (the representation of the requested resource or information about the executed API operation) is sent in the HTTP body, encoded as JSON.</p>"},{"location":"03-endpoints/api-admin/introduction/#placeholder-host-in-sample-urls","title":"Placeholder <code>host</code> in sample URLs","text":"<p>Please note that all the sample URLs used in this documentation contain <code>host</code> as a placeholder. The placeholder <code>host</code> has to be replaced by the actual hostname (and port) of the server the Knora instance is running on.</p>"},{"location":"03-endpoints/api-admin/introduction/#authentication","title":"Authentication","text":"<p>For all API operations that target at changing resources or values, the client has to provide credentials (username and password) so that the API server can authenticate the user making the request. Credentials can be sent as a part of the HTTP header or as parts of the URL (see Authentication in Knora).</p>"},{"location":"03-endpoints/api-admin/introduction/#admin-api-endpoints","title":"Admin API Endpoints","text":"<p>An overview over all admin API endpoints can be found in the overview.</p>"},{"location":"03-endpoints/api-admin/lists/","title":"Lists Endpoint","text":""},{"location":"03-endpoints/api-admin/lists/#endpoint-overview","title":"Endpoint Overview","text":"<p>List Item Operations:</p> <ul> <li><code>GET: /admin/lists[?projectIri=&lt;projectIri&gt;]</code> : return all lists optionally filtered by project</li> <li><code>GET: /admin/lists/&lt;listItemIri&gt;</code> : return complete list with all children if IRI of the list (i.e. root node) is given.   If IRI of the child node is given, return the node with its immediate children</li> <li><code>GET: /admin/lists/infos/&lt;listIri&gt;</code> : deprecated, use <code>/admin/lists/&lt;listIri&gt;/info</code> instead</li> <li><code>GET: /admin/lists/nodes/&lt;nodeIri&gt;</code> : deprecated, use <code>/admin/lists/&lt;listIri&gt;/info</code> instead</li> <li><code>GET: /admin/lists/&lt;listIri&gt;/info</code> : return list basic information (without children)</li> <li> <p><code>GET: /admin/lists/candelete/&lt;listItemIri&gt;</code> : check if list or its node is unused and can be deleted</p> </li> <li> <p><code>POST: /admin/lists</code> : create new list</p> </li> <li> <p><code>POST: /admin/lists/&lt;parentNodeIri&gt;</code> : create new child node under the supplied parent node IRI</p> </li> <li> <p><code>PUT: /admin/lists/&lt;listItemIri&gt;</code> : update node information (root or child)</p> </li> <li><code>PUT: /admin/lists/&lt;listItemIri&gt;/name</code> : update the name of the node (root or child)</li> <li><code>PUT: /admin/lists/&lt;listItemIri&gt;/labels</code> : update labels of the node (root or child)</li> <li><code>PUT: /admin/lists/&lt;listItemIri&gt;/comments</code> : update comments of the node (root or child)</li> <li> <p><code>PUT: /admin/lists/&lt;nodeIri&gt;/position</code> : update position of a child node within its current parent   or by changing its parent node</p> </li> <li> <p><code>DELETE: /admin/lists/&lt;listItemIri&gt;</code> : delete a list (i.e. root node) or a child node and all its children, if not used</p> </li> <li><code>DELETE: /admin/lists/comments/&lt;nodeIri&gt;</code> : delete comments of a node (child only)</li> </ul>"},{"location":"03-endpoints/api-admin/lists/#list-item-operations","title":"List Item Operations","text":""},{"location":"03-endpoints/api-admin/lists/#get-lists","title":"Get lists","text":"<ul> <li>Required permission: none</li> <li>Return all lists optionally filtered by project</li> <li>GET: <code>/admin/lists[?projectIri=&lt;projectIri&gt;]</code></li> </ul>"},{"location":"03-endpoints/api-admin/lists/#get-list","title":"Get list","text":"<ul> <li>Required permission: none</li> <li>Return complete <code>list</code> (or <code>node</code>) including basic information of the list (or child node),    <code>listinfo</code> (or <code>nodeinfo</code>), and all its children</li> <li>GET: <code>/admin/lists/&lt;listIri&gt;</code></li> </ul>"},{"location":"03-endpoints/api-admin/lists/#get-list-info","title":"Get list info","text":"<ul> <li>Required permission: none</li> <li>Return list (or node) basic information, <code>listinfo</code> (or <code>nodeinfo</code>), without its children</li> <li>GET: <code>/admin/lists/&lt;listIri&gt;/info</code></li> </ul>"},{"location":"03-endpoints/api-admin/lists/#check-if-list-node-is-unused-and-can-be-deleted","title":"Check if list node is unused and can be deleted","text":"<ul> <li>Required permission: none</li> <li>GET: <code>/admin/lists/candelete/&lt;listItemIri&gt;</code></li> <li>Return simple JSON that confirms if the list node can be deleted</li> </ul> <pre><code>{\n    \"canDeleteList\": true,\n    \"listIri\": \"http://rdfh.ch/lists/0801/xxx\"\n}\n</code></pre> <p>List (root node or child node with all its children) can be deleted only if it (or one of its children) is not used.</p>"},{"location":"03-endpoints/api-admin/lists/#create-new-list","title":"Create new list","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Required fields: <code>projectIri</code>, <code>labels</code>, <code>comments</code></li> <li>POST: <code>/admin/lists</code></li> <li>BODY:</li> </ul> <pre><code>    {\n        \"projectIri\": \"someprojectiri\",\n        \"labels\": [{ \"value\": \"New list\", \"language\": \"en\"}],\n        \"comments\": []\n    } \n</code></pre> <p>Additionally, each list can have an optional custom IRI (of Knora IRI form) specified by the <code>id</code> in the request body as below:</p> <pre><code>  {\n    \"id\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n    \"projectIri\": \"http://rdfh.ch/projects/0001\",\n    \"name\": \"a new list\",\n    \"labels\": [{ \"value\": \"New list with IRI\", \"language\": \"en\"}],\n    \"comments\": [{ \"value\": \"New comment\", \"language\": \"en\"}]\n  }\n</code></pre> <p>The response will contain the basic information of the list, <code>listinfo</code> and an empty list of its children, as below:</p> <pre><code>{\n    \"list\": {\n        \"children\": [],\n        \"listinfo\": {\n            \"comments\": [{ \"value\": \"New comment\", \"language\": \"en\"}],\n            \"id\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n            \"isRootNode\": true,\n            \"labels\": [\n                {\n                    \"value\": \"New list with IRI\",\n                    \"language\": \"en\"\n                }\n            ],\n            \"name\": \"a new list\",\n            \"projectIri\": \"http://rdfh.ch/projects/0001\"\n        }\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/lists/#create-new-child-node","title":"Create new child node","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Required fields: <code>parentNodeIri</code>, <code>projectIri</code>, <code>labels</code>,</li> <li>Appends a new child node under the supplied nodeIri. If the supplied nodeIri   is the listIri, then a new child node is appended to the top level. If a position is given   for the new child node, the node will be created and inserted in the specified position, otherwise   the node is appended to the end of parent's children.</li> <li>POST: <code>/admin/lists/&lt;parentNodeIri&gt;</code></li> <li>BODY:</li> </ul> <pre><code>     {   \n         \"parentNodeIri\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n         \"projectIri\": \"http://rdfh.ch/projects/0001\",\n         \"name\": \"a child\",\n         \"labels\": [{ \"value\": \"New List Node\", \"language\": \"en\"}]\n    }\n</code></pre> <p>Additionally, each child node can have an optional custom IRI (of Knora IRI form) specified by the <code>id</code> in the request body as below:</p> <pre><code>{    \"id\": \"http://rdfh.ch/lists/0001/8u37MxBVMbX3XQ8-d31x6w\",\n     \"parentNodeIri\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n     \"projectIri\": \"http://rdfh.ch/projects/0001\",\n     \"name\": \"a child\",\n     \"labels\": [{ \"value\": \"New List Node\", \"language\": \"en\"}]\n}\n</code></pre> <p>The response will contain the basic information of the node, <code>nodeinfo</code>, as below:</p> <pre><code>{\n    \"nodeinfo\": {\n        \"comments\": [],\n        \"hasRootNode\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n        \"id\": \"http://rdfh.ch/lists/0001/8u37MxBVMbX3XQ8-d31x6w\",\n        \"labels\": [\n            {\n                \"value\": \"New List Node\",\n                \"language\": \"en\"\n            }\n        ],\n        \"name\": \"a new child\",\n        \"position\": 1\n    }\n}\n</code></pre> <p>The new node can be created and inserted in a specific position which must be given in the payload as shown below. If necessary, according to the given position, the sibling nodes will be shifted.  Note that <code>position</code> cannot have a value higher than the number of existing children.</p> <pre><code>{   \"parentNodeIri\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n    \"projectIri\": \"http://rdfh.ch/projects/0001\",\n    \"name\": \"Inserted new child\",\n    \"position\": 0,\n    \"labels\": [{ \"value\": \"New List Node\", \"language\": \"en\"}]\n}\n</code></pre> <p>In case the new node should be appended to the list of current children, either <code>position: -1</code> must be given in the payload or the <code>position</code> parameter must be left out of the payload.</p>"},{"location":"03-endpoints/api-admin/lists/#update-lists-or-nodes-information","title":"Update list's or node's information","text":"<p>The basic information of a list (or node) such as its labels, comments, name, or all of them can be updated.  The parameters that must be updated together with the new value must be given in the JSON body of the request  together with the IRI of the list and the IRI of the project it belongs to. </p> <ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Required fields: <code>listIri</code>, <code>projectIri</code></li> <li>Update list information</li> <li>PUT: <code>/admin/lists/&lt;listIri&gt;</code></li> <li>BODY:</li> </ul> <pre><code>{\n    \"listIri\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n    \"projectIri\": \"http://rdfh.ch/projects/0001\",\n    \"name\": \"new name for the list\",\n    \"labels\": [{ \"value\": \"a new label for the list\", \"language\": \"en\"}],\n    \"comments\": [{ \"value\": \"a new comment for the list\", \"language\": \"en\"}]\n}\n</code></pre> <p>The response will contain the basic information of the list, <code>listinfo</code> (or <code>nodeinfo</code>), without its children, as below:</p> <pre><code>{\n    \"listinfo\": {\n        \"comments\": [\n            {\n                \"value\": \"a new comment for the list\",\n                \"language\": \"en\"\n            }\n        ],\n        \"id\": \"http://rdfh.ch/lists/0001/yWQEGXl53Z4C4DYJ-S2c5A\",\n        \"isRootNode\": true,\n        \"labels\": [\n            {\n                \"value\": \"a new label for the list\",\n                \"language\": \"en\"\n            }\n        ],\n        \"name\": \"new name for the list\",\n        \"projectIri\": \"http://rdfh.ch/projects/0001\"\n    }\n}\n</code></pre> <p>If only name of the list must be updated, it can be given as below in the body of the request:</p> <pre><code>{\n    \"listIri\": \"listIri\",\n    \"projectIri\": \"someprojectiri\",\n    \"name\": \"another name\"\n}\n</code></pre> <p>Alternatively, basic information <code>name</code>, <code>labels</code>, or <code>comments</code> of the root node (i.e. list)  can be updated individually as explained below.</p>"},{"location":"03-endpoints/api-admin/lists/#update-list-or-nodes-name","title":"Update list or node's name","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Update name of the list (i.e. root node) or a child node whose IRI is specified by <code>&lt;listItemIri&gt;</code>.</li> <li>PUT: <code>/admin/lists/&lt;listItemIri&gt;/name</code></li> <li>BODY: The new name of the node must be given in the body of the request as shown below:</li> </ul> <pre><code>{\n    \"name\": \"a new name\"\n}\n</code></pre> <p>There is no need to specify the project IRI because it is automatically extracted using the given <code>&lt;listItemIRI&gt;</code>.</p>"},{"location":"03-endpoints/api-admin/lists/#update-list-or-nodes-labels","title":"Update list or node's labels","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Update labels of the list (i.e. root node) or a child node whose IRI is specified by <code>&lt;listItemIri&gt;</code>.</li> <li>PUT: <code>/admin/lists/&lt;listItemIri&gt;/labels</code></li> <li>BODY: The new set of labels of the node must be given in the body of the request as shown below:</li> </ul> <pre><code>{\n    \"labels\": [{\"language\": \"se\", \"value\": \"nya m\u00e4rkningen\"}]\n}\n</code></pre> <p>There is no need to specify the project IRI because it is automatically extracted using the given <code>&lt;listItemIRI&gt;</code>.</p>"},{"location":"03-endpoints/api-admin/lists/#update-list-or-nodes-comments","title":"Update list or node's comments","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Update comments of the list (i.e. root node) or a child node whose IRI is specified by <code>&lt;listItemIri&gt;</code>.</li> <li>PUT: <code>/admin/lists/&lt;listItemIri&gt;/labels</code></li> <li>BODY: The new set of comments of the node must be given in the body of the request as shown below:</li> </ul> <pre><code>{\n    \"comments\": [{\"language\": \"se\", \"value\": \"nya kommentarer\"}]\n}\n</code></pre> <p>There is no need to specify the project IRI because it is automatically extracted using the given <code>&lt;listItemIRI&gt;</code>.</p>"},{"location":"03-endpoints/api-admin/lists/#repositioning-a-child-node","title":"Repositioning a child node","text":"<p>The position of an existing child node can be updated. The child node can be either repositioned within its  current parent node, or can be added to another parent node in a specific position. The IRI of the parent node  and the new position of the child node must be given in the request body. </p> <p>If a node is supposed to be repositioned to the end of a parent node's children, give <code>position: -1</code>.</p> <p>Suppose a parent node <code>parentNode1</code> has five children in positions 0-4, to change the position of its child node  <code>childNode4</code> from its original position 3 to position 1 the request body should specify the IRI of its parent node  and the new position as below:</p> <pre><code>   {\n      \"parentNodeIri\": \"&lt;parentNode1-IRI&gt;\",\n      \"position\": 1\n  }\n</code></pre> <p>Then the node <code>childNode4</code> will be put in position 1, and its siblings will be shifted accordingly. The new position given  in the request body cannot be the same as the child node's original position. If <code>position: -1</code> is given, the node will  be moved to the end of children list, and its siblings will be shifted to left. In case of repositioning the node  within its current parent, the maximum permitted position is the length of its children list, i.e. in this example the  highest allowed position is 4.</p> <p>To reposition a child node <code>childNode4</code> to another parent node <code>parentNode2</code> in a specific position, for  example <code>position: 3</code>, the IRI of the new parent node and the position the node must be placed within children of  <code>parentNode2</code> must be given as:</p> <pre><code>   {\n      \"parentNodeIri\": \"&lt;parentNode2-IRI&gt;\",\n      \"position\": 3\n  }\n</code></pre> <p>In this case, the <code>childNode4</code> is removed from the list of children of its old parent <code>parentNode1</code> and its old  siblings are shifted accordingly. Then the node <code>childNode4</code> is added to the specified new parent, i.e. <code>parentNode2</code>, in  the given position. The new siblings are shifted accordingly.</p> <p>Note that, the furthest the node can be placed is at the end of the list of the children of <code>parentNode2</code>. That means  if <code>parentNode2</code> had 3 children with positions 0-2, then <code>childNode4</code> can be placed in position 0-3 within children  of its new parent node. If the <code>position: -1</code> is given, the node will be appended to the end of new parent's children,  and new siblings will not be shifted. </p> <p>Values less than -1 are not permitted for parameter <code>position</code>.</p> <ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Response: returns the updated parent node with all its children.</li> <li>Put <code>/admin/lists/&lt;nodeIri&gt;/position</code></li> </ul>"},{"location":"03-endpoints/api-admin/lists/#delete-a-list-or-a-node","title":"Delete a list or a node","text":"<p>An entire list or a single node of it can be completely deleted, if not in use. Before deleting an entire list  (i.e. root node), the data and ontologies are checked for any usage of the list or its children. If not in use, the list  and all its children are deleted.</p> <p>Similarily, before deleting a single node of a list, it is verified that the node itself and none of its children are used. If not in use, the node and all its children are deleted. Once a node is deleted, its parent node is updated by shifting the  remaining child nodes with respect to the position of the deleted node. </p> <ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li> <p>Response:</p> <ul> <li>If the IRI of the list (i.e. root node) is given, the <code>iri</code> of the deleted list with a flag <code>deleted: true</code> is returned.</li> <li>If the IRI of a child node is given, the updated parent node is returned.</li> </ul> </li> <li> <p>Delete <code>/admin/lists/&lt;listItemIri&gt;</code></p> </li> </ul>"},{"location":"03-endpoints/api-admin/lists/#delete-child-node-comments","title":"Delete child node comments","text":"<p>Performing a DELETE request to route <code>/admin/lists/comments/&lt;nodeIri&gt;</code> deletes the comments of that node. As a response sipmle JSON is returned:</p> <pre><code>{\n    \"commentsDeleted\": true,\n    \"nodeIri\": \"http://rdfh.ch/lists/0801/xxx\"\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/overview/","title":"Admin Endpoint","text":"<p>For the management of users, projects, groups, lists, and permissions, the DSP-API following a resource centric approach, provides the following endpoints corresponding to the respective classes of objects that they have an effect on, namely:</p> <ul> <li>Users endpoint: <code>http://server:port/admin/users</code> - <code>knora-base:User</code></li> <li>Projects endpoint: <code>http://server:port/admin/projects</code> - <code>knora-base:knoraProject</code></li> <li>Groups endpoint: <code>http://server:port/admin/groups</code> - <code>knora-base:UserGroup</code></li> <li>Lists endpoint: <code>http://server:port/admin/lists</code> - <code>knora-base:ListNode</code></li> <li>Permissions endpoint: <code>http://server:port/admin/permissions</code> - <code>knora-admin:Permission</code></li> </ul> <p>All information regarding users, projects, groups, lists and permissions is stored in the <code>http://www.knora.org/admin</code> named graph.</p> <p>Additionally there is the stores endpoint which allows manipulation of the triplestore content.</p>"},{"location":"03-endpoints/api-admin/permissions/","title":"Permissions Endpoint","text":"<p>For an extensive explanation on how DSP permissions are implemented, see the permission documentation.</p> Route Operations Explanation <code>/admin/permissions/{projectIri}</code> <code>GET</code> get all permissions of a project <code>/admin/permissions/ap/{projectIri}</code> <code>GET</code> get all administrative permissions of a project <code>/admin/permissions/ap/{projectIri}/{groupIri}</code> <code>GET</code> get all administrative permissions of a group <code>/admin/permissions/doap/{projectIri}</code> <code>GET</code> get all default object access permissions of a project <code>/admin/permissions/ap</code> <code>POST</code> create a new administrative permission <code>/admin/permissions/doap</code> <code>POST</code> create a new default object access permission <code>/admin/permissions/doap/{permissionIri}</code> <code>PUT</code> update an existing default object access permission <code>/admin/permissions/{permissionIri}/group</code> <code>PUT</code> update for which group an administrative or default object access permission is used <code>/admin/permissions/{permissionIri}/hasPermission</code> <code>PUT</code> update the scope of an administrative or default object access permission, i.e. what permissions are granted to which group when this permission applies <code>/admin/permissions/{permissionIri}</code> <code>DELETE</code> delete an administrative or default object access permission <code>/admin/permissions/{doap_permissionIri}/resourceClass</code> <code>PUT</code> deprecated, use <code>/admin/permissions/doap/{permissionIri}</code> instead <code>/admin/permissions/{doap_permissionIri}/property</code> <code>PUT</code> deprecated,  use <code>/admin/permissions/doap/{permissionIri}</code> instead"},{"location":"03-endpoints/api-admin/permissions/#permission-operations","title":"Permission Operations","text":"<p>Note: For the following operations, the requesting user must be either a <code>systemAdmin</code>or a <code>projectAdmin</code>.</p>"},{"location":"03-endpoints/api-admin/permissions/#getting-permissions","title":"Getting Permissions","text":"<ul> <li> <p><code>GET: /admin/permissions/&lt;projectIri&gt;</code> : return all permissions for a project. As a response, the IRI and the type of all <code>permissions</code> of a project are returned.</p> </li> <li> <p><code>GET: /admin/permissions/ap/&lt;projectIri&gt;</code>: return all administrative permissions  for a project. As a response, all <code>administrative_permissions</code> of a project are returned.</p> </li> <li> <p><code>GET: /admin/permissions/ap/&lt;projectIri&gt;/&lt;groupIri&gt;</code>: return the administrative  permissions for a project group. As a response, the <code>administrative_permission</code> defined  for the group is returned. </p> </li> <li> <p><code>GET: /admin/permissions/doap/&lt;projectIri&gt;</code>: return all default object access  permissions for a project. As a response, all <code>default_object_acces_permissions</code> of a  project are returned. </p> </li> </ul>"},{"location":"03-endpoints/api-admin/permissions/#creating-new-administrative-permissions","title":"Creating New Administrative Permissions","text":"<ul> <li><code>POST: /admin/permissions/ap</code>: create a new administrative permission. The type of  permissions, the project and group to which the permission should be added must be  included in the request body, for example:</li> </ul> <pre><code>{\n    \"forGroup\":\"http://rdfh.ch/groups/0001/thing-searcher\", \n    \"forProject\":\"http://rdfh.ch/projects/0001\", \n    \"hasPermissions\":[\n      {\n        \"additionalInformation\":null,\n        \"name\":\"ProjectAdminGroupAllPermission\",\n        \"permissionCode\":null\n      }\n    ]\n}\n</code></pre> <p>In addition, in the body of the request, it is possible to specify a custom IRI (of  DSP IRI form) for a permission through the <code>@id</code> attribute which will then be assigned to the permission; otherwise the permission will get a unique random IRI. A custom permission IRI must be <code>http://rdfh.ch/permissions/PROJECT_SHORTCODE/</code> (where <code>PROJECT_SHORTCODE</code> is the shortcode of the project that the permission belongs to), plus a custom ID string. For example:</p> <pre><code>\"id\": \"http://rdfh.ch/permissions/0001/jKIYuaEUETBcyxpenUwRzQ\",\n</code></pre> <p>As a response, the created administrative permission and its IRI are returned as below:</p> <pre><code>{\n    \"administrative_permission\": {\n        \"forGroup\": \"http://rdfh.ch/groups/0001/thing-searcher\",\n        \"forProject\": \"http://rdfh.ch/projects/0001\",\n        \"hasPermissions\": [\n            {\n                \"additionalInformation\": null,\n                \"name\": \"ProjectAdminGroupAllPermission\",\n                \"permissionCode\": null\n            }\n        ],\n        \"iri\": \"http://rdfh.ch/permissions/0001/mFlyBEiMQtGzwy_hK0M-Ow\"\n    }\n}\n</code></pre> <p><code>hasPermissions</code> contains permission types that must be granted. See the complete description of administrative permission types. In summary, each permission should contain followings:</p> <ul> <li><code>additionalInformation</code>: should be left empty, otherwise will be ignored.</li> <li><code>name</code> : indicates the type of the permission that can be one of the followings:<ul> <li><code>ProjectAdminAllPermission</code>: gives the user the permission to do anything  on project level, i.e. create new groups, modify all  existing groups</li> <li><code>ProjectAdminGroupAllPermission</code>: gives the user the permission to modify  group info and group membership on all groups  belonging to the project.</li> <li><code>ProjectAdminGroupRestrictedPermission</code>: gives the user the permission to modify  group info and group membership on certain groups  belonging to the project.</li> <li><code>ProjectAdminRightsAllPermission</code>: gives the user the permission to change the  permissions on all objects belonging to the project  (e.g., default permissions attached to groups and  permissions on objects).</li> <li><code>ProjectResourceCreateAllPermission</code>: gives the permission to create resources  inside the project.</li> <li><code>ProjectResourceCreateRestrictedPermission</code>: gives restricted resource creation permission  inside the project.</li> </ul> </li> <li><code>permissionCode</code>: should be left empty, otherwise will be ignored.</li> </ul> <p>Note that during the creation of a new project,  a default set of administrative permissions are added to its ProjectAdmin and ProjectMember groups  (See Default set of permissions for a new project).  Therefore, it is not possible to create new administrative permissions  for the ProjectAdmin and ProjectMember groups of a project.  However, the default permissions set for these groups can be modified  (See update permission).</p>"},{"location":"03-endpoints/api-admin/permissions/#creating-new-default-object-access-permissions","title":"Creating New Default Object Access Permissions","text":"<ul> <li><code>POST: /admin/permissions/doap</code> : create a new default object access permission.  A single instance of <code>knora-admin:DefaultObjectAccessPermission</code> must always reference a project, but can only reference either a group (<code>knora-admin:forGroup</code> property), a resource class (<code>knora-admin:forResourceClass</code>), a property (<code>knora-admin:forProperty</code>), or a combination of resource class and property. For example, to create a new  default object access permission for a group of a project the request body would be</li> </ul> <pre><code>{\n    \"forGroup\":\"http://rdfh.ch/groups/0001/thing-searcher\",\n    \"forProject\":\"http://rdfh.ch/projects/0001\",\n    \"forProperty\":null,\n    \"forResourceClass\":null,\n    \"hasPermissions\":[\n      {\n        \"additionalInformation\":\"http://www.knora.org/ontology/knora-admin#ProjectMember\",\n        \"name\":\"D\",\n        \"permissionCode\":7\n      }\n    ]\n}\n</code></pre> <p><code>hasPermissions</code> contains permission types that must be granted. See a complete description of object access  permission types.  In summary, each permission should contain followings:</p> <ul> <li><code>additionalInformation</code>: To whom the permission should be granted: project members, known users, unknown users, etc.</li> <li><code>name</code> : indicates the type of the permission that can be one of the followings.<ul> <li><code>RV</code>: restricted view permission (least privileged)</li> <li><code>V</code>: view permission</li> <li><code>M</code> modify permission</li> <li><code>D</code>: delete permission</li> <li><code>CR</code>: change rights permission (most privileged)</li> </ul> </li> <li><code>permissionCode</code>: The code assigned to a permission indicating its hierarchical level. These codes are as below:<ul> <li><code>1</code>: for restricted view permission (least privileged)</li> <li><code>2</code>: for view permission</li> <li><code>6</code>: for modify permission</li> <li><code>7</code>: for delete permission</li> <li><code>8</code>: for change rights permission (most privileged)</li> </ul> </li> </ul> <p>Note that, at least either <code>name</code> or <code>permissionCode</code> must be provided. If one is missing, it will be extrapolated from the other. For example, if <code>permissionCode= 1</code> is given but <code>name</code> was left empty, its value will be set to <code>name = RV</code>.    </p> <p>Similar to the previous case a custom IRI can be assigned to a permission specified by the <code>id</code> in the request body.  The example below shows the request body to create a new default object access permission with a custom IRI defined for  a resource class of a specific project:</p> <pre><code>{\n    \"id\": \"http://rdfh.ch/permissions/00FF/fSw7w1sI5IwDjEfFi1jOeQ\",\n    \"forGroup\": null,\n    \"forProject\": \"http://rdfh.ch/projects/00FF\",\n    \"forProperty\": null,\n    \"forResourceClass\": \"http://api.dasch.swiss/ontology/00FF/images/v2#bild\",\n    \"hasPermissions\": [\n      {\n        \"additionalInformation\": \"http://www.knora.org/ontology/knora-admin#ProjectMember\",\n        \"name\": \"D\",\n        \"permissionCode\": 7\n      }\n    ]\n}\n</code></pre> <p>The response contains the newly created permission and its IRI, as:</p> <pre><code>{\n    \"default_object_access_permission\": {\n        \"forGroup\": null,\n        \"forProject\": \"http://rdfh.ch/projects/00FF\",\n        \"forProperty\": null,\n        \"forResourceClass\": \"http://api.dasch.swiss/ontology/00FF/images/v2#bild\",\n        \"hasPermissions\": [\n            {\n                \"additionalInformation\": \"http://www.knora.org/ontology/knora-admin#ProjectMember\",\n                \"name\": \"D\",\n                \"permissionCode\": 7\n            }\n        ],\n        \"iri\": \"http://rdfh.ch/permissions/00FF/fSw7w1sI5IwDjEfFi1jOeQ\"\n    }\n}\n</code></pre> <p>Note that during the creation of a new project,  a set of default object access permissions are created for its ProjectAdmin and ProjectMember groups  (See Default set of permissions for a new project).  Therefore, it is not possible to create new default object access permissions  for the ProjectAdmin and ProjectMember groups of a project.  However, the default permissions set for these groups can be modified; see below for more information.</p>"},{"location":"03-endpoints/api-admin/permissions/#updating-an-existing-default-object-access-permission","title":"Updating an existing Default Object Access Permission","text":"<ul> <li><code>PUT: /admin/permissions/doap/&lt;doap_permissionIri&gt;</code> to change the attributes of an existing default object   access permission, identified by its IRI <code>&lt;doap_permissionIri&gt;</code>.</li> </ul> <p>This is an example of a request body to update an existing default object access permission:</p> <pre><code>{\n  \"forProperty\" : \"http://api.dasch.swiss/ontology/00FF/images/v2#hasTitle\",\n  \"forResourceClass\": \"http://api.dasch.swiss/ontology/0803/incunabula/v2#Book\",\n  \"forGroup\": null, \n  \"hasPermissions\": [\n    {\n      \"additionalInformation\": \"http://www.knora.org/ontology/knora-admin#ProjectMember\",\n      \"name\": \"D\",\n      \"permissionCode\": 7\n    }\n  ]\n}\n</code></pre> <p>All attributes of the default object access permission are optional and may be combined.</p> <p>Warning</p> <p>Only certain combinations of attributes are allowed. Only exactly one of the following combinations is allowed:</p> <ul> <li><code>forGroup</code> </li> <li><code>forResourceClass</code></li> <li><code>forProperty</code></li> <li><code>forResourceClass</code> and <code>forProperty</code></li> </ul> <p>If the combination of attributes is not allowed, the request will fail with a <code>400 Bad Request</code> error. Any valid combination of attributes will replace the existing values.</p> <p>If present, the <code>hasPermissions</code> attribute must contain all permission types that must be granted. See a complete description of object access permission types. This is also described in the Creating New Default Object Access Permissions section.</p> <p>The response is the updated default object access permission with its new attributes and is the same as when creating a new default object access permission.</p>"},{"location":"03-endpoints/api-admin/permissions/#updating-a-permissions-group","title":"Updating a Permission's Group","text":"<p>Note</p> <p>For Default Object Access Permissions this endpoint is deprecated,  use <code>PUT: /admin/permissions/doap/&lt;permissionIri&gt;</code> instead. For more information, see the migration guide.</p> <ul> <li><code>PUT: /admin/permissions/&lt;permissionIri&gt;/group</code> to change the group for which an administrative or a default object  access permission, identified by its IRI <code>&lt;permissionIri&gt;</code>, is defined. The request body must contain the IRI of the new  group as below:</li> </ul> <pre><code>{\n    \"forGroup\": \"http://www.knora.org/ontology/knora-admin#ProjectMember\"\n}\n</code></pre> <p>When updating an administrative permission, its previous <code>forGroup</code> value will be replaced with the new one. When updating a default object access permission, if it originally had a <code>forGroup</code> value defined, it will be replaced  with the new group. Otherwise, if the default object access permission was defined for a resource class or a property or  the combination of both, the permission will be defined for the newly specified group and its previous  <code>forResourceClass</code> and <code>forProperty</code> values will be deleted.</p>"},{"location":"03-endpoints/api-admin/permissions/#updating-a-permissions-scope","title":"Updating a Permission's Scope","text":"<p>Note</p> <p>For Default Object Access Permissions this endpoint is deprecated,  use <code>PUT: /admin/permissions/doap/&lt;permissionIri&gt;</code> instead. For more information, see the migration guide.</p> <ul> <li><code>PUT: /admin/permissions/&lt;permissionIri&gt;/hasPermissions</code> to change the scope of permissions assigned to an administrative   or a default object access permission identified by it IRI, <code>&lt;permissionIri&gt;</code>. The request body must contain the new set    of permission types as below:</li> </ul> <pre><code>{\n   \"hasPermissions\":[\n     {\n       \"additionalInformation\":\"http://www.knora.org/ontology/knora-admin#ProjectMember\",\n       \"name\":\"D\",\n       \"permissionCode\":7\n     }\n   ]\n}\n</code></pre> <p>Each permission item given in <code>hasPermissions</code>, must contain the necessary parameters with respect to the type of the  permission. For example, if you wish to change the scope of an administrative permission, follow the  guidelines for the content of its <code>hasPermissions</code> property. Similarly, if you wish to change the scope of a default object access permission,  follow the guidelines given about the content of its <code>hasPermissions</code> property. Either the <code>name</code> or the <code>permissionCode</code> must be present; it is not necessary to provide both.</p> <p>The previous permission set is replaced by the new permission set. In order to remove a permission for a group entirely, you can provide a new set of permissions, leaving out the permission specification for the group.</p>"},{"location":"03-endpoints/api-admin/permissions/#deleting-a-permission","title":"Deleting a Permission","text":"<ul> <li><code>DELETE: /admin/permissions/&lt;permissionIri&gt;</code> to delete an administrative, or a default object access permission. The  IRI of the permission must be given in encoded form. </li> </ul>"},{"location":"03-endpoints/api-admin/projects/","title":"Projects Endpoint","text":"Scope Route Operations Explanation projects <code>/admin/projects</code> <code>GET</code> get all projects projects <code>/admin/projects</code> <code>POST</code> create a project projects <code>/admin/projects/shortname/{shortname}</code> <code>GET</code> get a single project projects <code>/admin/projects/shortcode/{shortcode}</code> <code>GET</code> get a single project projects <code>/admin/projects/iri/{iri}</code> <code>GET</code> get a single project projects <code>/admin/projects/iri/{iri}</code> <code>PUT</code> update a project projects <code>/admin/projects/iri/{iri}</code> <code>DELETE</code> delete a project projects <code>/admin/projects/iri/{iri}/AllData</code> <code>GET</code> get all data of a project project members <code>/admin/projects/shortname/{shortname}/members</code> <code>GET</code> get all project members project members <code>/admin/projects/shortcode/{shortcode}/members</code> <code>GET</code> get all project members project members <code>/admin/projects/iri/{iri}/members</code> <code>GET</code> get all project members project members <code>/admin/projects/shortname/{shortname}/admin-members</code> <code>GET</code> get all project admins project members <code>/admin/projects/shortcode/{shortcode}/admin-members</code> <code>GET</code> get all project admins project members <code>/admin/projects/iri/{iri}/admin-members</code> <code>GET</code> get all project admins keywords <code>/admin/projects/Keywords</code> <code>GET</code> get all project keywords keywords <code>/admin/projects/iri/{iri}/Keywords</code> <code>GET</code> get project keywords of a single project view settings <code>/admin/projects/shortname/{shortname}/RestrictedViewSettings</code> <code>GET</code> get restricted view settings for a project view settings <code>/admin/projects/shortcode/{shortcode}/RestrictedViewSettings</code> <code>GET</code> get restricted view settings for a project view settings <code>/admin/projects/iri/{iri}/RestrictedViewSettings</code> <code>GET</code> get restricted view settings for a project view settings <code>/admin/projects/iri/{iri}/RestrictedViewSettings</code> <code>POST</code> set restricted view settings for a project view settings <code>/admin/projects/shortcode/{shortcode}/RestrictedViewSettings</code> <code>POST</code> set restricted view settings for a project"},{"location":"03-endpoints/api-admin/projects/#project-operations","title":"Project Operations","text":""},{"location":"03-endpoints/api-admin/projects/#get-all-projects","title":"Get All Projects","text":"<p>Permissions: No permissions required</p> <p>Request definition: <code>GET /admin/projects</code></p> <p>Description: Returns a list of all projects except built-in system ones.</p> <p>Example request:</p> <pre><code>curl --request GET --url http://localhost:3333/admin/projects\n</code></pre> <p>Example response:</p> <pre><code>{\n  \"projects\": [\n    {\n      \"description\": [\n        {\n          \"value\": \"A demo project of a collection of images\",\n          \"language\": \"en\"\n        }\n      ],\n      \"id\": \"http://rdfh.ch/projects/00FF\",\n      \"keywords\": [\n        \"collection\",\n        \"images\"\n      ],\n      \"logo\": null,\n      \"longname\": \"Image Collection Demo\",\n      \"ontologies\": [\n        \"http://0.0.0.0:3333/ontology/00FF/images/v2\"\n      ],\n      \"selfjoin\": false,\n      \"shortcode\": \"00FF\",\n      \"shortname\": \"images\",\n      \"status\": true\n    },\n    {\n      // ...\n    }\n  ]\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/projects/#create-a-new-project","title":"Create a New Project","text":"<p>Permissions: SystemAdmin</p> <p>Request definition: <code>POST /admin/projects</code></p> <p>Description: Create a new project.</p> <p>Required payload:</p> <ul> <li><code>shortcode</code> (unique, 4-digits)</li> <li><code>shortname</code> (unique, 3-20 characters long, can contain small and capital letters, numbers, special characters: <code>-</code> and <code>_</code>, cannot start with number nor allowed special characters, should be in the form of a xsd:NCNAME and URL safe)</li> <li><code>description</code> (collection of descriptions as strings with language tag)</li> <li><code>keywords</code> (collection of keywords)</li> <li><code>status</code> (true, if project is active. false, if project is inactive)</li> <li><code>selfjoin</code></li> </ul> <p>Optional payload:</p> <ul> <li><code>id</code> (unique, custom DSP IRI, e.g. used for migrating a project from one server to another)</li> <li><code>longname</code></li> <li><code>logo</code></li> </ul> <p>Example request:</p> <pre><code>curl --request POST \\\n  --url http://localhost:3333/admin/projects \\\n  --header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"shortname\": \"newproject\",\n    \"shortcode\": \"3333\",\n    \"longname\": \"project longname\",\n    \"description\": [\n        {\n            \"value\": \"project description\",\n            \"language\": \"en\"\n        }\n    ],\n    \"keywords\": [\n        \"test project\"\n    ],\n    \"logo\": \"/fu/bar/baz.jpg\",\n    \"status\": true,\n    \"selfjoin\": false\n}'\n</code></pre> <p>Example response:</p> <pre><code>{\n    \"project\": {\n        \"description\": [\n            {\n                \"value\": \"project description\",\n                \"language\": \"en\"\n            }\n        ],\n        \"id\": \"http://rdfh.ch/projects/3333\",\n        \"keywords\": [\n            \"test project\"\n        ],\n        \"logo\": \"/fu/bar/baz.jpg\",\n        \"longname\": \"project longname\",\n        \"ontologies\": [],\n        \"selfjoin\": false,\n        \"shortcode\": \"3333\",\n        \"shortname\": \"newproject\",\n        \"status\": true\n    }\n}\n</code></pre> <p>Errors:</p> <ul> <li><code>400 Bad Request</code> if the project already exists or any of the provided properties is invalid.</li> <li><code>401 Unauthorized</code> if authorization failed.</li> </ul>"},{"location":"03-endpoints/api-admin/projects/#default-set-of-restrictedviewsize","title":"Default set of RestrictedViewSize","text":"<p>Starting from DSP 2023.10.02 release, the creation of new project will also set the <code>RestrictedViewSize</code> to default value, which is: <code>!512,512</code>. It is possible to change the value using dedicated routes.</p>"},{"location":"03-endpoints/api-admin/projects/#default-set-of-permissions-for-a-new-project","title":"Default set of permissions for a new project","text":"<p>When a new project is created, following default permissions are added to its admins and members:</p> <ul> <li> <p>ProjectAdmin group receives an administrative permission to do all project level operations    and to create resources within the new project.    This administrative permission is retrievable through its IRI:   <code>http://rdfh.ch/permissions/[projectShortcode]/defaultApForAdmin</code></p> </li> <li> <p>ProjectAdmin group also gets a default object access permission to change rights    (which includes delete, modify, view, and restricted view permissions) of any entity that belongs to the project.    This default object access permission is retrievable through its IRI:    <code>http://rdfh.ch/permissions/[projectShortcode]/defaultDoapForAdmin</code></p> </li> <li> <p>ProjectMember group receives an administrative permission to create resources within the new project.    This administrative permission is retrievable through its IRI:   <code>http://rdfh.ch/permissions/[projectShortcode]/defaultApForMember</code></p> </li> <li> <p>ProjectMember group also gets a default object access permission to delete    (which includes modify, view and restricted view permissions) of any entity that belongs to the project.    This default object access permission is retrievable through its IRI:    <code>http://rdfh.ch/permissions/[projectShortcode]/defaultDoapForMember</code></p> </li> </ul>"},{"location":"03-endpoints/api-admin/projects/#get-project-by-id","title":"Get Project by ID","text":"<p>The ID can be shortcode, shortname or IRI.</p> <p>Permissions: No permissions required</p> <p>Request definition:</p> <ul> <li><code>GET /admin/projects/shortcode/{shortcode}</code></li> <li><code>GET /admin/projects/shortname/{shortname}</code></li> <li><code>GET /admin/projects/iri/{iri}</code></li> </ul> <p>Description: Returns a single project identified by shortcode, shortname or IRI.</p> <p>Example request:</p> <pre><code>curl --request GET --url http://localhost:3333/admin/projects/shortcode/0001\n</code></pre> <pre><code>curl --request GET --url http://localhost:3333/admin/projects/shortname/anything\n</code></pre> <pre><code>curl --request GET --url \\\n    http://localhost:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001\n</code></pre> <p>Example response:</p> <pre><code>{\n  \"project\": {\n    \"description\": [\n      {\n        \"value\": \"Anything Project\"\n      }\n    ],\n    \"id\": \"http://rdfh.ch/projects/0001\",\n    \"keywords\": [\n      \"arbitrary test data\",\n      \"things\"\n    ],\n    \"logo\": null,\n    \"longname\": \"Anything Project\",\n    \"ontologies\": [\n      \"http://0.0.0.0:3333/ontology/0001/something/v2\",\n      \"http://0.0.0.0:3333/ontology/0001/freetest/v2\",\n      \"http://0.0.0.0:3333/ontology/0001/minimal/v2\",\n      \"http://0.0.0.0:3333/ontology/0001/anything/v2\"\n    ],\n    \"selfjoin\": false,\n    \"shortcode\": \"0001\",\n    \"shortname\": \"anything\",\n    \"status\": true\n  }\n}\n</code></pre> <p>Errors:</p> <ul> <li><code>400 Bad Request</code> if the provided ID is not valid.</li> <li><code>404 Not Found</code> if no project with the provided ID is found.</li> </ul> <p>NB:</p> <ul> <li>IRI must be URL-encoded.</li> </ul>"},{"location":"03-endpoints/api-admin/projects/#update-project-information","title":"Update Project Information","text":"<p>Permissions: SystemAdmin / ProjectAdmin</p> <p>Request definition: <code>PUT /admin/projects/iri/{iri}</code></p> <p>Description: Update a project identified by its IRI.</p> <p>Payload: The following properties can be changed:</p> <ul> <li><code>longname</code></li> <li><code>description</code></li> <li><code>keywords</code></li> <li><code>logo</code></li> <li><code>status</code></li> <li><code>selfjoin</code></li> </ul> <p>Example request:</p> <pre><code>curl --request PUT \\\n  --url http://localhost:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001 \\\n  --header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n  \"longname\": \"other longname\"\n}'\n</code></pre> <p>Example response:</p> <pre><code>{\n  \"project\": {\n    \"description\": [\n      {\n        \"value\": \"Anything Project\"\n      }\n    ],\n    \"id\": \"http://rdfh.ch/projects/0001\",\n    \"keywords\": [\n      \"arbitrary test data\",\n      \"things\"\n    ],\n    \"logo\": null,\n    \"longname\": \"other longname\",\n    \"ontologies\": [\n      \"http://api.knora.org/ontology/0001/something/v2\",\n      \"http://api.knora.org/ontology/0001/freetest/v2\",\n      \"http://api.knora.org/ontology/0001/minimal/v2\",\n      \"http://api.knora.org/ontology/0001/anything/v2\"\n    ],\n    \"selfjoin\": false,\n    \"shortcode\": \"0001\",\n    \"shortname\": \"anything\",\n    \"status\": true\n  }\n}\n</code></pre> <p>Errors:</p> <ul> <li><code>400 Bad Request</code><ul> <li>if the provided IRI is not valid.</li> <li>if the provided payload is not valid.</li> </ul> </li> <li><code>404 Not Found</code> if no project with the provided IRI is found.</li> </ul>"},{"location":"03-endpoints/api-admin/projects/#delete-a-project","title":"Delete a Project","text":"<p>Permissions: SystemAdmin / ProjectAdmin</p> <p>Request definition: <code>DELETE /admin/projects/iri/{iri}</code></p> <p>Description: Mark a project as deleted (by setting the <code>status</code> flag to <code>false</code>).</p> <pre><code>curl --request DELETE \\\n  --url http://localhost:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001 \\\n  --header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0' \\\n  --header 'Content-Type: application/json'\n</code></pre> <p>Example response:</p> <pre><code>{\n  \"project\": {\n    \"description\": [\n      {\n        \"value\": \"Anything Project\"\n      }\n    ],\n    \"id\": \"http://rdfh.ch/projects/0001\",\n    \"keywords\": [\n      \"arbitrary test data\",\n      \"things\"\n    ],\n    \"logo\": null,\n    \"longname\": \"other longname\",\n    \"ontologies\": [\n      \"http://api.knora.org/ontology/0001/something/v2\",\n      \"http://api.knora.org/ontology/0001/freetest/v2\",\n      \"http://api.knora.org/ontology/0001/minimal/v2\",\n      \"http://api.knora.org/ontology/0001/anything/v2\"\n    ],\n    \"selfjoin\": false,\n    \"shortcode\": \"0001\",\n    \"shortname\": \"anything\",\n    \"status\": false\n  }\n}\n</code></pre> <p>Errors:</p> <ul> <li><code>400 Bad Request</code> if the provided IRI is not valid.</li> <li><code>404 Not Found</code> if no project with the provided IRI is found.</li> </ul>"},{"location":"03-endpoints/api-admin/projects/#get-all-data-of-a-project","title":"Get all Data of a Project","text":"<p>Permissions: ProjectAdmin / SystemAdmin</p> <p>Request definition: <code>POST /admin/projects/iri/{iri}/AllData</code></p> <p>Description: Gets all data of a project as a TriG file (ontologies, resource data, admin data, and permissions).</p> <p>Example request:</p> <pre><code>curl --request GET \\\n  --url http://localhost:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F00FF/AllData \\\n  --header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <p>Example response:</p> <pre><code>@prefix images: &lt;http://www.knora.org/ontology/00FF/images#&gt; .\n@prefix knora-admin: &lt;http://www.knora.org/ontology/knora-admin#&gt; .\n@prefix knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt; .\n@prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .\n@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .\n@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .\n@prefix salsah-gui: &lt;http://www.knora.org/ontology/salsah-gui#&gt; .\n@prefix standoff: &lt;http://www.knora.org/ontology/standoff#&gt; .\n@prefix xml: &lt;http://www.w3.org/XML/1998/namespace&gt; .\n@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .\n\n&lt;http://www.knora.org/ontology/00FF/images&gt; {\n    &lt;http://www.knora.org/ontology/00FF/images&gt;\n            rdf:type                      owl:Ontology ;\n            rdfs:label                    \"The images demo ontology\" ;\n            knora-base:attachedToProject  &lt;http://rdfh.ch/projects/00FF&gt; ;\n            knora-base:lastModificationDate  \"2012-12-12T12:12:12.12Z\"^^xsd:dateTime .\n    images:lastname  rdf:type        owl:ObjectProperty ;\n            rdfs:comment             \"Nachname einer Person\"@de ;\n            rdfs:comment             \"Last name of a person\"@en ;\n            rdfs:label               \"Name\"@de ;\n            rdfs:subPropertyOf       knora-base:hasValue ;\n            knora-base:objectClassConstraint  knora-base:TextValue ;\n            knora-base:subjectClassConstraint  images:person ;\n            salsah-gui:guiAttribute  \"size=32\" ;\n            salsah-gui:guiAttribute  \"maxlength=32\" ;\n            salsah-gui:guiElement    salsah-gui:SimpleText .\n    # ...\n}\n\n&lt;http://www.knora.org/data/00FF/images&gt; {\n    &lt;http://rdfh.ch/00FF/0cb8286054d5&gt;\n            rdf:type                      images:bild ;\n            rdfs:label                    \"1 Alpinismus\" ;\n            images:bearbeiter             &lt;http://rdfh.ch/00FF/0cb8286054d5/values/0b80b43aee0f04&gt; ;\n            images:titel                  &lt;http://rdfh.ch/00FF/0cb8286054d5/values/cea90774ee0f04&gt; ;\n            images:urheber                &lt;http://rdfh.ch/00FF/df1260ad43d5&gt; ;\n            images:urheberValue           &lt;http://rdfh.ch/00FF/0cb8286054d5/values/e346ff38-6b03-4a27-a11b-b0818a2e5ee3&gt; ;\n            knora-base:attachedToProject  &lt;http://rdfh.ch/projects/00FF&gt; ;\n            knora-base:attachedToUser     &lt;http://rdfh.ch/users/c266a56709&gt; ;\n            knora-base:creationDate       \"2016-03-02T15:05:57Z\"^^xsd:dateTime ;\n            knora-base:hasPermissions     \"CR knora-admin:ProjectMember,knora-admin:Creator|V knora-admin:KnownUser|RV knora-admin:UnknownUser\" ;\n            knora-base:hasStillImageFileValue  &lt;http://rdfh.ch/00FF/0cb8286054d5/values/c66133bf942f01&gt; ;\n            knora-base:isDeleted          false .\n    # ...\n}\n\n&lt;http://www.knora.org/data/admin&gt; {\n  # ...\n}\n\n&lt;http://www.knora.org/data/permissions&gt; {\n  # ...\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/projects/#project-member-operations","title":"Project Member Operations","text":""},{"location":"03-endpoints/api-admin/projects/#get-project-members-by-id","title":"Get Project Members by ID","text":"<p>Permissions: SystemAdmin / ProjectAdmin</p> <p>Request definition: </p> <ul> <li><code>GET /admin/projects/shortcode/{shortcode}/members</code></li> <li><code>GET /admin/projects/shortname/{shortname}/members</code></li> <li><code>GET /admin/projects/iri/{iri}/members</code></li> </ul> <p>Description: returns all members part of a project identified through iri, shortname or shortcode</p> <p>Example request:</p> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/shortcode/0001/members' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/shortname/anything/members' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001/members'\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <p>Example response:</p> <pre><code>{\n    \"members\": [\n        {\n            \"email\": \"anything.user01@example.org\",\n            \"familyName\": \"UserFamilyName\",\n            \"givenName\": \"UserGivenName\",\n            \"groups\": [],\n            \"id\": \"http://rdfh.ch/users/BhkfBc3hTeS_IDo-JgXRbQ\",\n            \"lang\": \"de\",\n            \"password\": null,\n            \"permissions\": {\n                \"administrativePermissionsPerProject\": {\n                    \"http://rdfh.ch/projects/0001\": [\n                        {\n                            \"additionalInformation\": null,\n                            \"name\": \"ProjectResourceCreateAllPermission\",\n                            \"permissionCode\": null\n                        }\n                    ]\n                },\n                \"groupsPerProject\": {\n                    \"http://rdfh.ch/projects/0001\": [\n                        \"http://www.knora.org/ontology/knora-admin#ProjectMember\"\n                    ]\n                }\n            },\n            \"projects\": [\n                {\n                    \"description\": [\n                        {\n                            \"value\": \"Anything Project\"\n                        }\n                    ],\n                    \"id\": \"http://rdfh.ch/projects/0001\",\n                    \"keywords\": [\n                        \"arbitrary test data\",\n                        \"things\"\n                    ],\n                    \"logo\": null,\n                    \"longname\": \"Anything Project\",\n                    \"ontologies\": [\n                        \"http://0.0.0.0:3333/ontology/0001/something/v2\",\n                        \"http://0.0.0.0:3333/ontology/0001/anything/v2\"\n                    ],\n                    \"selfjoin\": false,\n                    \"shortcode\": \"0001\",\n                    \"shortname\": \"anything\",\n                    \"status\": true\n                }\n            ],\n            \"sessionId\": null,\n            \"status\": true,\n            \"token\": null,\n            \"username\": \"anything.user01\"\n        }\n    ]\n}\n</code></pre> <p>Errors:</p> <ul> <li><code>400 Bad Request</code> if the provided ID is not valid.</li> <li><code>404 Not Found</code> if no project with the provided ID is found.</li> </ul> <p>NB:</p> <ul> <li>IRI must be URL-encoded.</li> </ul>"},{"location":"03-endpoints/api-admin/projects/#get-project-admins-by-id","title":"Get Project Admins by ID","text":"<p>Permissions: SystemAdmin / ProjectAdmin</p> <p>Request definition: </p> <ul> <li><code>GET /admin/projects/shortcode/{shortcode}/admin-members</code></li> <li><code>GET /admin/projects/shortname/{shortname}/admin-members</code></li> <li><code>GET /admin/projects/iri/{iri}/admin-members</code></li> </ul> <p>Description: returns all admin members part of a project identified through iri, shortname or shortcode</p> <p>Example request:</p> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/shortcode/0001/admin-members' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/shortname/anything/admin-members' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001/admin-members'\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <p>Example response:</p> <pre><code>{\n    \"members\": [\n        {\n            \"email\": \"anything.admin@example.org\",\n            \"familyName\": \"Admin\",\n            \"givenName\": \"Anything\",\n            \"groups\": [],\n            \"id\": \"http://rdfh.ch/users/AnythingAdminUser\",\n            \"lang\": \"de\",\n            \"password\": null,\n            \"permissions\": {\n                \"administrativePermissionsPerProject\": {\n                    \"http://rdfh.ch/projects/0001\": [\n                        {\n                            \"additionalInformation\": null,\n                            \"name\": \"ProjectResourceCreateAllPermission\",\n                            \"permissionCode\": null\n                        },\n                        {\n                            \"additionalInformation\": null,\n                            \"name\": \"ProjectAdminAllPermission\",\n                            \"permissionCode\": null\n                        }\n                    ]\n                },\n                \"groupsPerProject\": {\n                    \"http://rdfh.ch/projects/0001\": [\n                        \"http://www.knora.org/ontology/knora-admin#ProjectMember\",\n                        \"http://www.knora.org/ontology/knora-admin#ProjectAdmin\"\n                    ]\n                }\n            },\n            \"projects\": [\n                {\n                    \"description\": [\n                        {\n                            \"value\": \"Anything Project\"\n                        }\n                    ],\n                    \"id\": \"http://rdfh.ch/projects/0001\",\n                    \"keywords\": [\n                        \"arbitrary test data\",\n                        \"things\"\n                    ],\n                    \"logo\": null,\n                    \"longname\": \"Anything Project\",\n                    \"ontologies\": [\n                        \"http://0.0.0.0:3333/ontology/0001/something/v2\",\n                        \"http://0.0.0.0:3333/ontology/0001/freetest/v2\",\n                        \"http://0.0.0.0:3333/ontology/0001/minimal/v2\",\n                        \"http://0.0.0.0:3333/ontology/0001/anything/v2\"\n                    ],\n                    \"selfjoin\": false,\n                    \"shortcode\": \"0001\",\n                    \"shortname\": \"anything\",\n                    \"status\": true\n                }\n            ],\n            \"sessionId\": null,\n            \"status\": true,\n            \"token\": null,\n            \"username\": \"anything.admin\"\n        }\n    ]\n}\n</code></pre> <p>Errors:</p> <ul> <li><code>400 Bad Request</code> if the provided ID is not valid.</li> <li><code>404 Not Found</code> if no project with the provided ID is found.</li> </ul> <p>NB:</p> <ul> <li>IRI must be URL-encoded.</li> </ul>"},{"location":"03-endpoints/api-admin/projects/#other-project-operations","title":"Other Project Operations","text":""},{"location":"03-endpoints/api-admin/projects/#get-all-keywords","title":"Get all Keywords","text":"<p>Permissions:</p> <p>Request definition: <code>GET /admin/projects/Keywords</code></p> <p>Description: returns keywords of all projects as a list</p> <p>Example request:</p> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/Keywords'\n</code></pre> <p>Example response:</p> <pre><code>{\n    \"keywords\": [\n        \"Annotation\",\n        \"Arabe\",\n        \"Arabic\",\n        \"Arabisch\",\n        \"Audio\",\n        \"Basel\",\n        \"Basler Fr\u00fchdrucke\",\n        \"Bilder\",\n        \"Bilderfolgen\",\n        \"Contectualisation of images\",\n        \"Cyrillic\",\n        \"Cyrillique\",\n        \"Data and Service Center for the Humanities (DaSCH)\",\n        \"Grec\",\n        \"Greek\",\n        \"Griechisch\",\n        \"Hebrew\",\n        \"Hebr\u00e4isch\",\n        \"Hieroglyphen\",\n        \"H\u00e9breu\",\n        \"Inkunabel\",\n        \"Japanese\",\n        \"Japanisch\",\n        \"Japonais\",\n        \"Keilschrift\",\n        \"Kunsthistorisches Seminar Universit\u00e4t Basel\",\n        \"Kyrillisch\",\n        \"Late Middle Ages\",\n        \"Letterpress Printing\",\n        \"Markup\",\n        \"Narrenschiff\",\n        \"Objekte\",\n        \"Sebastian Brant\",\n        \"Sonderzeichen\",\n        \"Texteigenschaften\",\n        \"Textquellen\",\n        \"Wiegendrucke\",\n        \"XML\",\n        \"arbitrary test data\",\n        \"asdf\",\n        \"audio\",\n        \"caract\u00e8res sp\u00e9ciaux\",\n        \"collection\",\n        \"cuneiform\",\n        \"cun\u00e9iforme\",\n        \"early print\",\n        \"hieroglyphs\",\n        \"hi\u00e9roglyphes\",\n        \"images\",\n        \"incunabula\",\n        \"objects\",\n        \"objets\",\n        \"propri\u00e9t\u00e9s de texte\",\n        \"ship of fools\",\n        \"sources\",\n        \"special characters\",\n        \"textual properties\",\n        \"textual sources\",\n        \"things\"\n    ]\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/projects/#get-keywords-of-a-project","title":"Get Keywords of a Project","text":"<p>Permissions:</p> <p>Request definition:</p> <ul> <li><code>GET /admin/projects/iri/{iri}/Keywords</code></li> </ul> <p>Description: returns the keywords of a single project</p> <p>Example request:</p> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001/Keywords'\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <p>Example response:</p> <pre><code>{\n    \"keywords\": [\n        \"arbitrary test data\",\n        \"things\"\n    ]\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/projects/#get-restricted-view-settings","title":"Get Restricted View Settings","text":"<p>Permissions: ProjectAdmin</p> <p>Request definition:</p> <ul> <li><code>GET /admin/projects/shortcode/{shortcode}/RestrictedViewSettings</code></li> <li><code>GET /admin/projects/shortname/{shortname}/RestrictedViewSettings</code></li> <li><code>GET /admin/projects/iri/{iri}/RestrictedViewSettings</code></li> </ul> <p>Description: returns the project's restricted view settings</p> <p>Example request:</p> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/shortcode/0001/RestrictedViewSettings' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/shortname/anything/RestrictedViewSettings' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <pre><code>curl --request GET 'http://0.0.0.0:3333/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001/RestrictedViewSettings' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0'\n</code></pre> <p>Example response:</p> <pre><code>{\n    \"settings\": {\n        \"size\": \"!512,512\",\n        \"watermark\": false\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/projects/#set-restricted-view-settings","title":"Set Restricted View Settings","text":"<p>Set how all still image resources of a projects should be displayed when viewed as restricted.  This can be either a size restriction or a watermark. </p> <p>For that, we support two of the IIIF size forms:</p> <ul> <li><code>!d,d</code> The returned image is scaled so that the width and height of the returned image are not greater than d,    while maintaining the aspect ratio.</li> <li><code>pct:n</code> The width and height of the returned image is scaled to n percent    of the width and height of the original image. 1&lt;= n &lt;= 100.</li> </ul> <p>If the watermark is set to <code>true</code>, the returned image will be watermarked, otherwise the default size <code>!128,128</code> is set. It is only possible to set either the size or the watermark, not both at the same time.</p> <p>Permissions: ProjectAdmin/SystemAdmin</p> <p>Request definition:</p> <ul> <li><code>POST /admin/projects/iri/{iri}/RestrictedViewSettings</code></li> <li><code>POST /admin/projects/shortcode/{shortcode}/RestrictedViewSettings</code></li> </ul> <p>Description: Set the project's restricted view</p> <p>The endpoint accepts either a size or a watermark but not both.</p> <p>Size:</p> <pre><code>{ \"size\": \"!512,512\" }\n</code></pre> <p>Watermark:</p> <pre><code>{ \"watermark\": true }\n</code></pre> <p>Examples :</p> <p>Request:</p> <pre><code>curl --request POST 'http://0.0.0.0:5555/admin/projects/iri/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001/RestrictedViewSettings' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0' \\\n--data '{\"size\": \"!512,512\"}\n</code></pre> <p>Response:</p> <pre><code>{ \"size\": \"!512,512\" }\n</code></pre> <p>Request:</p> <pre><code>curl --request POST 'http://0.0.0.0:5555/admin/projects/shortcode/0001/RestrictedViewSettings' \\\n--header 'Authorization: Basic cm9vdEBleGFtcGxlLmNvbTp0ZXN0' \\\n--data '{\"watermark\": true}'\n</code></pre> <p>Response:</p> <pre><code>{ \"watermark\": true }\n</code></pre> <p>Operates on the following mutually exclusive properties:</p> <ul> <li><code>knora-admin:projectRestrictedViewSize</code>: the IIIF size value</li> <li><code>knora-admin:projectRestrictedViewWatermark</code>: whether images of a project should be protected with a watermark.</li> </ul> <p>Note: Restricted view settings only take effect, if a user has \"Restricted View\" permission on an image.</p>"},{"location":"03-endpoints/api-admin/stores/","title":"Stores Endpoint","text":"<p>This endpoint allows manipulation of the triplestore content.</p> <p><code>POST admin/store/ResetTriplestoreContent</code> resets the triplestore content, given that the <code>allowReloadOverHttp</code> configuration flag is set to <code>true</code>. This route is mostly used in tests.</p>"},{"location":"03-endpoints/api-admin/users/","title":"Users Endpoint","text":""},{"location":"03-endpoints/api-admin/users/#endpoint-overview","title":"Endpoint Overview","text":""},{"location":"03-endpoints/api-admin/users/#general-user-operations","title":"General User Operations","text":"<ul> <li><code>GET: /admin/users</code> : return all users</li> <li><code>GET: /admin/users/[iri | email | username]/&lt;identifier&gt;</code> : return single user identified by [IRI | email | username]</li> <li><code>POST: /admin/users/</code> : create new user</li> <li><code>PUT: /admin/users/iri/&lt;userIri&gt;/BasicUserInformation</code> : update user's basic user information</li> <li><code>PUT: /admin/users/iri/&lt;userIri&gt;/Password</code> : update user's password</li> <li><code>PUT: /admin/users/iri/&lt;userIri&gt;/Status</code> : update user's status</li> <li><code>DELETE: /admin/users/iri/&lt;userIri&gt;</code> : delete user (set status to false)</li> </ul>"},{"location":"03-endpoints/api-admin/users/#project-membership-operations","title":"Project membership operations","text":"<ul> <li><code>GET: /admin/users/iri/&lt;userIri&gt;/project-memberships</code> : get user's project memberships</li> <li><code>POST: /admin/users/iri/&lt;userIri&gt;/project-memberships/&lt;projectIri&gt;</code> : add user to project (to ProjectMember group)</li> <li><code>DELETE: /admin/users/iri/&lt;userIri&gt;/project-memberships/&lt;projectIri&gt;</code> : remove user from project (to ProjectMember   group)</li> </ul>"},{"location":"03-endpoints/api-admin/users/#group-membership-operations","title":"Group membership operations","text":"<ul> <li><code>GET: /admin/users/iri/&lt;userIri&gt;/project-admin-memberships</code> : get user's ProjectAdmin group memberships</li> <li><code>POST: /admin/users/iri/&lt;userIri&gt;/project-admin-memberships/&lt;projectIri&gt;</code> : add user to ProjectAdmin group</li> <li> <p><code>DELETE: /admin/users/iri/&lt;userIri&gt;/project-admin-memberships/&lt;projectIri&gt;</code> : remove user from ProjectAdmin group</p> </li> <li> <p><code>GET: /admin/users/iri/&lt;userIri&gt;/group-memberships</code> : get user's normal group memberships</p> </li> <li><code>POST: /admin/users/iri/&lt;userIri&gt;/group-memberships/&lt;groupIri&gt;</code> : add user to normal group</li> <li> <p><code>DELETE: /admin/users/iri/&lt;userIri&gt;/group-memberships/&lt;groupIri&gt;</code> : remove user from normal group</p> </li> <li> <p><code>PUT: /admin/users/iri/&lt;userIri&gt;/SystemAdmin</code> : Add/remove user to/from SystemAdmin group</p> </li> </ul>"},{"location":"03-endpoints/api-admin/users/#user-operations","title":"User Operations","text":""},{"location":"03-endpoints/api-admin/users/#get-users","title":"Get users","text":"<ul> <li>Required permission: SystemAdmin</li> <li>GET: <code>/admin/users</code></li> </ul>"},{"location":"03-endpoints/api-admin/users/#get-user","title":"Get user","text":"<ul> <li>Required permission:<ul> <li>SystemAdmin / self: for getting all properties</li> <li>All other users: for getting only the public properties (<code>givenName</code> and <code>familyName</code>)</li> </ul> </li> <li>GET:<code>/admin/users/[iri | email | username ]/&lt;identifier&gt;</code></li> </ul>"},{"location":"03-endpoints/api-admin/users/#create-user","title":"Create user","text":"<ul> <li>Required permission: none, self-registration is allowed</li> <li>Required information: email (unique), given name, family name,   password, status, systemAdmin</li> <li>Username restrictions:<ul> <li>3 - 50 characters long</li> <li>Only contains alphanumeric characters (a-z, A-Z, 0-9), underscore (_), hyphen (-), and dot (.)</li> <li>Cannot start or end with underscore, hyphen, or dot</li> <li>Underscore, hyphen, or dot cannot be used multiple times in a row</li> </ul> </li> <li>Returns information about the newly created user</li> <li>POST: <code>/admin/users</code></li> <li>BODY:</li> </ul> <pre><code>    {\n  \"email\": \"donald.duck@example.org\",\n  \"givenName\": \"Donald\",\n  \"familyName\": \"Duck\",\n  \"username\": \"donald.duck\",\n  \"password\": \"test\",\n  \"status\": true,\n  \"lang\": \"en\",\n  \"systemAdmin\": false\n}\n</code></pre> <p>Additionally, each user can have an optional custom IRI (of Knora IRI form) specified by the <code>id</code> in the request body as below:</p> <pre><code>    {\n  \"id\": \"http://rdfh.ch/users/FnjFfIQFVDvI7ex8zSyUyw\",\n  \"email\": \"donald.duck@example.org\",\n  \"givenName\": \"Donald\",\n  \"familyName\": \"Duck\",\n  \"username\": \"donald.duck\",\n  \"password\": \"test\",\n  \"status\": true,\n  \"lang\": \"en\",\n  \"systemAdmin\": false\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/users/#update-basic-user-information","title":"Update basic user information**","text":"<ul> <li>Required permission: SystemAdmin / self</li> <li>Changeable information: username, email, given name, family name,   password, status, SystemAdmin membership</li> <li>TypeScript Docs: userFormats - ChangeUserApiRequestADM</li> <li>PUT: <code>/admin/users/iri/&lt;userIri&gt;/BasicUserInformation</code></li> <li>BODY:</li> </ul> <pre><code>    {\n  \"username\": \"donald.big.duck\",\n  \"email\": \"donald.big.duck@example.org\",\n  \"givenName\": \"Big Donald\",\n  \"familyName\": \"Duckmann\",\n  \"lang\": \"de\"\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/users/#update-users-password","title":"Update user's password","text":"<ul> <li>Required permission: SystemAdmin / self</li> <li>Changeable information: password</li> <li>PUT: <code>/admin/users/iri/&lt;userIri&gt;/Password</code></li> <li>BODY:</li> </ul> <pre><code>    {\n  \"requesterPassword\": \"test\",\n  \"newPassword\": \"test1234\"\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/users/#delete-user","title":"Delete user","text":"<ul> <li>Required permission: SystemAdmin / self</li> <li>Remark: The same as updating a user and changing <code>status</code> to <code>false</code>. To un-delete, set <code>status</code> to <code>true</code>.</li> <li>PUT: <code>/admin/users/iri/&lt;userIri&gt;/Status</code></li> <li>BODY:</li> </ul> <pre><code>{\n  \"status\": false\n  // true or false\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/users/#delete-user-update-user","title":"Delete user (-\\update user)**","text":"<ul> <li>Required permission: SystemAdmin / self</li> <li>Remark: The same as updating a user and changing <code>status</code> to <code>false</code>. To un-delete, set <code>status</code> to <code>true</code>.</li> <li>DELETE: <code>/admin/users/iri/&lt;userIri&gt;</code></li> <li>BODY: empty</li> </ul>"},{"location":"03-endpoints/api-admin/users/#users-project-membership-operations","title":"User's project membership operations","text":""},{"location":"03-endpoints/api-admin/users/#get-users-project-memberships","title":"Get user's project memberships","text":"<ul> <li>GET: <code>/admin/users/iri/&lt;userIri&gt;/project-memberships</code></li> </ul>"},{"location":"03-endpoints/api-admin/users/#addremove-user-tofrom-project","title":"Add/remove user to/from project","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin / self (if project self-assignment is enabled)</li> <li>Required information: project IRI, user IRI</li> <li>Effects: <code>knora-base:isInProject</code> user property</li> <li>POST / DELETE: <code>/admin/users/iri/&lt;userIri&gt;/project-memberships/&lt;projectIri&gt;</code></li> <li>BODY: empty</li> </ul> <p>Note: When a user is project admin in the same project, his project admin membership will be removed as well.</p>"},{"location":"03-endpoints/api-admin/users/#users-group-membership-operations","title":"User's group membership operations","text":""},{"location":"03-endpoints/api-admin/users/#get-users-project-admin-memberships","title":"Get user's project admin memberships","text":"<ul> <li>GET: <code>/admin/users/iri/&lt;userIri&gt;/project-admin-memberships</code></li> </ul>"},{"location":"03-endpoints/api-admin/users/#addremove-user-tofrom-project-admin-group","title":"Add/remove user to/from project admin group","text":"<ul> <li>Required permission: SystemAdmin / ProjectAdmin</li> <li>Required information: project IRI, user IRI</li> <li>Effects: <code>knora-base:isInProjectAdminGroup</code> user property</li> <li>POST / DELETE: <code>/admin/users/iri/&lt;userIri&gt;/project-admin-memberships/&lt;projectIri&gt;</code></li> <li>BODY: empty</li> </ul> <p>Note: In order to add a user to a project admin group, the user needs to be member of that project.</p>"},{"location":"03-endpoints/api-admin/users/#get-users-group-memberships","title":"Get user's group memberships**","text":"<ul> <li>GET: <code>/admin/users/iri/&lt;userIri&gt;/group-memberships</code></li> </ul>"},{"location":"03-endpoints/api-admin/users/#addremove-user-tofrom-normal-group-not-systemadmin-or-projectadmin","title":"Add/remove user to/from 'normal' group (not SystemAdmin or ProjectAdmin)","text":"<ul> <li>Required permission: SystemAdmin / hasProjectAllAdminPermission   / hasProjectAllGroupAdminPermission /   hasProjectRestrictedGroupAdminPermission (for this group) / User   (if group self-assignment is enabled)</li> <li>Required information: group IRI, user IRI</li> <li>Effects: <code>knora-base:isInGroup</code></li> <li>POST / DELETE: <code>/admin/users/iri/&lt;userIri&gt;/group-memberships/&lt;groupIri&gt;</code></li> <li>BODY: empty</li> </ul>"},{"location":"03-endpoints/api-admin/users/#addremove-user-tofrom-system-admin-group","title":"Add/remove user to/from system admin group","text":"<ul> <li>Required permission: SystemAdmin / self</li> <li>Effects property: <code>knora-base:isInSystemAdminGroup</code> with value   <code>true</code> or <code>false</code></li> <li>PUT: <code>/admin/users/iri/&lt;userIri&gt;/SystemAdmin</code></li> <li>BODY:</li> </ul> <pre><code>{\n  \"systemAdmin\": false\n}\n</code></pre>"},{"location":"03-endpoints/api-admin/users/#example-data","title":"Example Data","text":"<p>The following is an example for user information stored in the <code>admin</code> named graph:</p> <pre><code>&lt;http://rdfh.ch/users/c266a56709&gt;\n    rdf:type knora-admin:User ;\n    knora-admin:username \"user01.user1\"^^xsd:string ;\n    knora-admin:email \"user01.user1@example.com\"^^xsd:string ;\n    knora-admin:givenName \"User01\"^^xsd:string ;\n    knora-admin:familyName \"User\"^^xsd:string ;\n    knora-admin:password \"$e0801$FGl9FDIWw+D83OeNPGmD9u2VTqIkJopIQECgmb2DSWQLS0TeKSvYoWAkbEv6KxePPlCI3CP9MmVHuvnWv8/kag==$mlegCYdGXt+ghuo8i0rLjgOiNnGDW604Q5g/v7zwBPU=\"^^xsd:string ;\n    knora-admin:preferredLanguage \"de\"^^xsd:string ;\n    knora-admin:status \"true\"^^xsd:boolean ;\n    knora-admin:isInProject &lt;http://rdfh.ch/projects/00FF&gt; ;\n    knora-admin:isInSystemAdminGroup \"false\"^^xsd:boolean ;\n    knora-admin:isInProjectAdminGroup &lt;http://rdfh.ch/projects/00FF&gt; .\n</code></pre>"},{"location":"03-endpoints/api-util/version/","title":"Version","text":"<p>The version endpoint provides all versions of used components in the DSP stack.</p>"},{"location":"03-endpoints/api-util/version/#example-request","title":"Example request","text":"<p><code>GET /version</code></p>"},{"location":"03-endpoints/api-util/version/#example-response","title":"Example response","text":"<pre><code>HTTP/1.1 200 OK\nContent-Length: 247\nContent-Type: application/json\nDate: Mon, 11 Mar 2024 17:40:32 GMT\nServer: webapi/v30.9.0\n\n{\n    \"buildCommit\": \"bbb0e65c7\",\n    \"buildTime\": \"2024-03-11T17:40:17.322491Z\",\n    \"fuseki\": \"2.1.5\",\n    \"scala\": \"2.13.13\",\n    \"sipi\": \"3.9.0\",\n    \"webapi\": \"v30.9.0\"\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/authentication/","title":"Authentication","text":"<p>Certain routes are secured and require authentication. When accessing any secured route an Access Token must be sent in the HTTP authorization header with the HTTP bearer scheme.</p> <p>Any other method of authentication is deprecated.</p>"},{"location":"03-endpoints/api-v2/authentication/#access-token-login-and-logout","title":"Access Token / Login and Logout","text":"<p>A client can obtain an access token by sending a POST request (e.g., <code>{\"identifier_type\":\"identifier_value\", \"password\":\"password_value\"}</code>) to the /v2/authentication route with identifier and password in the body. The <code>identifier_type</code> can be <code>iri</code>, <code>email</code>, or <code>username</code>. If the credentials are valid, a JSON WEB Token (JWT) will be sent back in the response (e.g., <code>{\"token\": \"eyJ0eXAiOiJ...\"}</code>). </p> <p>To logout, the client sends a DELETE request to the same route /v2/authentication  along with the access token. This will invalidate the access token, thus not allowing further request that would supply the invalidated token.</p>"},{"location":"03-endpoints/api-v2/authentication/#checking-credentials","title":"Checking Credentials","text":"<p>To check the credentials, send a GET request to /v2/authentication with the credentials supplied as URL parameters or HTTP authentication headers as described before.</p>"},{"location":"03-endpoints/api-v2/editing-resources/","title":"Creating and Editing Resources","text":""},{"location":"03-endpoints/api-v2/editing-resources/#creating-a-resource","title":"Creating a Resource","text":"<p>To create a new resources, use this route:</p> <pre><code>HTTP POST to http://host/v2/resources\n</code></pre> <p>The body of the request is a JSON-LD document in the complex API schema, specifying the type,<code>rdfs:label</code>, and its Knora resource properties and their values. The representation of the resource is the same as when it is returned in a <code>GET</code> request, except that its <code>knora-api:attachedToUser</code> is not given, and the resource IRI and those of its values can be optionally specified. The format of the values submitted is described in Creating and Editing Values.  If there are multiple values for a property, these must be given in an array.</p> <p>For example, here is a request to create a resource with various value types:</p> <pre><code>{\n  \"@type\" : \"anything:Thing\",\n  \"anything:hasBoolean\" : {\n    \"@type\" : \"knora-api:BooleanValue\",\n    \"knora-api:booleanValueAsBoolean\" : true\n  },\n  \"anything:hasColor\" : {\n    \"@type\" : \"knora-api:ColorValue\",\n    \"knora-api:colorValueAsColor\" : \"#ff3333\"\n  },\n  \"anything:hasDate\" : {\n    \"@type\" : \"knora-api:DateValue\",\n    \"knora-api:dateValueHasCalendar\" : \"GREGORIAN\",\n    \"knora-api:dateValueHasEndEra\" : \"CE\",\n    \"knora-api:dateValueHasEndYear\" : 1489,\n    \"knora-api:dateValueHasStartEra\" : \"CE\",\n    \"knora-api:dateValueHasStartYear\" : 1489\n  },\n  \"anything:hasDecimal\" : {\n    \"@type\" : \"knora-api:DecimalValue\",\n    \"knora-api:decimalValueAsDecimal\" : {\n      \"@type\" : \"xsd:decimal\",\n      \"@value\" : \"100000000000000.000000000000001\"\n    }\n  },\n  \"anything:hasGeometry\" : {\n    \"@type\" : \"knora-api:GeomValue\",\n    \"knora-api:geometryValueAsGeometry\" : \"{\\\"status\\\":\\\"active\\\",\\\"lineColor\\\":\\\"#ff3333\\\",\\\"lineWidth\\\":2,\\\"points\\\":[{\\\"x\\\":0.08098591549295775,\\\"y\\\":0.16741071428571427},{\\\"x\\\":0.7394366197183099,\\\"y\\\":0.7299107142857143}],\\\"type\\\":\\\"rectangle\\\",\\\"original_index\\\":0}\"\n  },\n  \"anything:hasGeoname\" : {\n    \"@type\" : \"knora-api:GeonameValue\",\n    \"knora-api:geonameValueAsGeonameCode\" : \"2661604\"\n  },\n  \"anything:hasInteger\" : [ {\n    \"@type\" : \"knora-api:IntValue\",\n    \"knora-api:hasPermissions\" : \"CR knora-admin:Creator|V http://rdfh.ch/groups/0001/thing-searcher\",\n    \"knora-api:intValueAsInt\" : 5,\n    \"knora-api:valueHasComment\" : \"this is the number five\"\n  }, {\n    \"@type\" : \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\" : 6\n  } ],\n  \"anything:hasInterval\" : {\n    \"@type\" : \"knora-api:IntervalValue\",\n    \"knora-api:intervalValueHasEnd\" : {\n      \"@type\" : \"xsd:decimal\",\n      \"@value\" : \"3.4\"\n    },\n    \"knora-api:intervalValueHasStart\" : {\n      \"@type\" : \"xsd:decimal\",\n      \"@value\" : \"1.2\"\n    }\n  },\n  \"anything:hasListItem\" : {\n    \"@type\" : \"knora-api:ListValue\",\n    \"knora-api:listValueAsListNode\" : {\n      \"@id\" : \"http://rdfh.ch/lists/0001/treeList03\"\n    }\n  },\n  \"anything:hasOtherThingValue\" : {\n    \"@type\" : \"knora-api:LinkValue\",\n    \"knora-api:linkValueHasTargetIri\" : {\n      \"@id\" : \"http://rdfh.ch/0001/a-thing\"\n    }\n  },\n  \"anything:hasRichtext\" : {\n    \"@type\" : \"knora-api:TextValue\",\n    \"knora-api:textValueAsXml\" : \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\\n&lt;text&gt;&lt;p&gt;&lt;strong&gt;this is&lt;/strong&gt; text&lt;/p&gt; with standoff&lt;/text&gt;\",\n    \"knora-api:textValueHasMapping\" : {\n      \"@id\" : \"http://rdfh.ch/standoff/mappings/StandardMapping\"\n    }\n  },\n  \"anything:hasText\" : {\n    \"@type\" : \"knora-api:TextValue\",\n    \"knora-api:valueAsString\" : \"this is text without standoff\"\n  },\n  \"anything:hasUri\" : {\n    \"@type\" : \"knora-api:UriValue\",\n    \"knora-api:uriValueAsUri\" : {\n      \"@type\" : \"xsd:anyURI\",\n      \"@value\" : \"https://www.knora.org\"\n    }\n  },\n  \"knora-api:attachedToProject\" : {\n    \"@id\" : \"http://rdfh.ch/projects/0001\"\n  },\n  \"rdfs:label\" : \"test thing\",\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>Permissions for the new resource can be given by adding <code>knora-api:hasPermissions</code>, a custom creation date can be specified by adding <code>knora-api:creationDate</code> (an xsd:dateTimeStamp), and the resource's creator can be specfied by adding <code>knora-api:attachedToUser</code>. For example:</p> <pre><code>{\n  \"@type\" : \"anything:Thing\",\n  \"anything:hasBoolean\" : {\n    \"@type\" : \"knora-api:BooleanValue\",\n    \"knora-api:booleanValueAsBoolean\" : true\n  },\n  \"knora-api:attachedToProject\" : {\n    \"@id\" : \"http://rdfh.ch/projects/0001\"\n  },\n  \"knora-api:attachedToUser\" : {\n    \"@id\" : \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n  },\n  \"rdfs:label\" : \"test thing\",\n  \"knora-api:hasPermissions\" : \"CR knora-admin:Creator|V http://rdfh.ch/groups/0001/thing-searcher\",\n  \"knora-api:creationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"2019-01-09T15:45:54.502951Z\"\n  },\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>The format of the object of <code>knora-api:hasPermissions</code> is described in Permissions.</p> <p>If permissions are not given, configurable default permissions are used (see Default Object Access Permissions ).</p> <p>To create a resource, the user must have permission to create resources of that class in that project.</p> <p>The predicate <code>knora-api:attachedToUser</code> can be used to specify a creator other than the requesting user only if the requesting user is an administrator of the project or a system administrator. The specified creator must also have permission to create resources of that class in that project.</p> <p>In addition to the creation date, in the body of the request, it is possible to specify a custom IRI ( of Knora IRI form) for a resource through the <code>@id</code> attribute which will then be assigned to the resource; otherwise the resource will get a unique random IRI.</p> <p>A custom resource IRI must be <code>http://rdfh.ch/PROJECT_SHORTCODE/</code> (where <code>PROJECT_SHORTCODE</code> is the shortcode of the project that the resource belongs to) plus a custom ID string.</p> <p>Similarly, it is possible to assign a custom IRI to the values using their <code>@id</code> attributes; if not given, random IRIs will be assigned to the values.</p> <p>A custom value IRI must be the IRI of the containing resource, followed by a <code>/values/</code> and a custom ID string.</p> <p>An optional custom UUID of a value can also be given by adding <code>knora-api:valueHasUUID</code>. Each custom UUID must be base64url-encoded without padding. Each value of the new resource can also have a custom creation date specified by adding <code>knora-api:creationDate</code> (an xsd:dateTimeStamp). For example:</p> <pre><code>{\n   \"@id\" : \"http://rdfh.ch/0001/oveR1dQltEUwNrls9Lu5Rw\",\n   \"@type\" : \"anything:Thing\",\n   \"knora-api:attachedToProject\" : {\n     \"@id\" : \"http://rdfh.ch/projects/0001\"\n   },\n   \"anything:hasInteger\" : {\n       \"@id\" : \"http://rdfh.ch/0001/oveR1dQltEUwNrls9Lu5Rw/values/IN4R19yYR0ygi3K2VEHpUQ\",\n       \"@type\" : \"knora-api:IntValue\",\n       \"knora-api:intValueAsInt\" : 10,\n       \"knora-api:valueHasUUID\" : \"IN4R19yYR0ygi3K2VEHpUQ\",\n       \"knora-api:creationDate\" : {\n               \"@type\" : \"xsd:dateTimeStamp\",\n               \"@value\" : \"2020-06-04T12:58:54.502951Z\"\n       }\n   },\n   \"rdfs:label\" : \"test thing with custom IRI\",\n   \"knora-api:creationDate\" : {\n     \"@type\" : \"xsd:dateTimeStamp\",\n     \"@value\" : \"2019-01-09T15:45:54.502951Z\"\n   },\n   \"@context\" : {\n     \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n     \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n     \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n     \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n     \"anything\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>The response is a JSON-LD document containing a preview of the resource.</p>"},{"location":"03-endpoints/api-v2/editing-resources/#modifying-a-resources-values","title":"Modifying a Resource's Values","text":"<p>See Creating and Editing Values.</p>"},{"location":"03-endpoints/api-v2/editing-resources/#modifying-a-resources-metadata","title":"Modifying a Resource's Metadata","text":"<p>You can modify the following metadata attached to a resource:</p> <ul> <li>label</li> <li>permissions</li> <li>last modification date</li> </ul> <p>To do this, use this route:</p> <pre><code>HTTP PUT to http://host/v2/resources\n</code></pre> <p>The request body is a JSON-LD object containing the following information about the resource:</p> <ul> <li><code>@id</code>: the resource's IRI</li> <li><code>@type</code>: the resource's class IRI</li> <li><code>knora-api:lastModificationDate</code>: an <code>xsd:dateTimeStamp</code> representing the last modification date that is currently   attached to the resource, if any. This is used to make sure that the resource has not been modified by someone else   since you last read it.</li> </ul> <p>The submitted JSON-LD object must also contain one or more of the following predicates, representing the metadata you want to change:</p> <ul> <li><code>rdfs:label</code>: a string</li> <li><code>knora-api:hasPermissions</code>, in the format described   in Permissions</li> <li><code>knora-api:newModificationDate</code>: an xsd:dateTimeStamp.</li> </ul> <p>Here is an example:</p> <pre><code>{\n  \"@id\" : \"http://rdfh.ch/0001/a-thing\",\n  \"@type\" : \"anything:Thing\",\n  \"rdfs:label\" : \"this is the new label\",\n  \"knora-api:hasPermissions\" : \"CR knora-admin:Creator|M knora-admin:ProjectMember|V knora-admin:ProjectMember\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"2017-11-20T15:55:17Z\"\n  },\n  \"knora-api:newModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"2018-12-21T16:56:18Z\"\n  },\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>If you submit a <code>knora-api:lastModificationDate</code> that is different from the resource's actual last modification date, you will get an HTTP 409 (Conflict) error.</p> <p>If you submit a <code>knora-api:newModificationDate</code> that is earlier than the resource's <code>knora-api:lastModificationDate</code>, you will get an HTTP 400 (Bad Request) error.</p> <p>A successful response is an HTTP 200 (OK) status containing the resource's metadata.</p>"},{"location":"03-endpoints/api-v2/editing-resources/#deleting-a-resource","title":"Deleting a Resource","text":"<p>Knora does not normally delete resources; instead, it marks them as deleted, which means that they do not appear in normal query results.</p> <p>To mark a resource as deleted, use this route:</p> <pre><code>HTTP POST to http://host/v2/resources/delete\n</code></pre> <p>The request body is a JSON-LD object containing the following information about the resource:</p> <ul> <li><code>@id</code>: the resource's IRI</li> <li><code>@type</code>: the resource's class IRI</li> <li><code>knora-api:lastModificationDate</code>: an <code>xsd:dateTimeStamp</code> representing the last modification date that is currently   attached to the resource, if any. This is used to make sure that the resource has not been modified by someone else   since you last read it.</li> </ul> <pre><code>{\n  \"@id\" : \"http://rdfh.ch/0001/a-thing\",\n  \"@type\" : \"anything:Thing\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"2019-02-05T17:05:35.776747Z\"\n  },\n  \"knora-api:deleteComment\" : \"This resource was created by mistake.\",\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>The optional property <code>knora-api:deleteComment</code> specifies a comment to be attached to the resource, explaining why it has been marked as deleted.</p> <p>The optional property <code>knora-api:deleteDate</code> (an xsd:dateTimeStamp) indicates when the resource was marked as deleted; if not given, the current time is used.</p> <p>The response is a JSON-LD document containing the predicate <code>knora-api:result</code> with a confirmation message.</p>"},{"location":"03-endpoints/api-v2/editing-resources/#requesting-deleted-resources","title":"Requesting Deleted Resources","text":"<p>Resources marked as deleted are not found in search queries. It is however possible to request them directly or from an ARK URL. In these instances, the API will not return the deleted resource, but instead a generic resource of type  <code>knora-base:DeletedResource</code>. This resource will be similar to the requested resource, having e.g. the same IRI. The resource will contain the deletion date and optionally the deletion comment.</p> <p>The response to requesting a deleted resource will look as the following example:</p> <pre><code>{\n    \"rdfs:label\": \"Deleted Resource\",\n    \"knora-api:versionArkUrl\": {\n        \"@value\": \"http://0.0.0.0:3336/ark:/72163/1/0001/a=thingO.20211214T084407677335Z\",\n        \"@type\": \"xsd:anyURI\"\n    },\n    \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/0001\"\n    },\n    \"knora-api:userHasPermission\": \"CR\",\n    \"knora-api:attachedToUser\": {\n        \"@id\": \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n    },\n    \"knora-api:hasPermissions\": \"CR knora-admin:ProjectMember|V knora-admin:ProjectMember\",\n    \"knora-api:isDeleted\": true,\n    \"@type\": \"knora-api:DeletedResource\",\n    \"@id\": \"http://rdfh.ch/0001/a-thing\",\n    \"knora-api:deleteComment\": \"This resource is too boring.\",\n    \"knora-api:arkUrl\": {\n        \"@value\": \"http://0.0.0.0:3336/ark:/72163/1/0001/a=thingO\",\n        \"@type\": \"xsd:anyURI\"\n    },\n    \"knora-api:creationDate\": {\n        \"@value\": \"2021-12-14T08:44:07.677335Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n    },\n    \"knora-api:deleteDate\": {\n        \"@type\": \"xsd:dateTimeStamp\",\n        \"@value\": \"2021-12-14T08:44:07.372543Z\"\n    },\n    \"@context\": {\n        \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n        \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n        \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/editing-resources/#links-to-deleted-resources","title":"Links to Deleted Resources","text":"<p>If resource <code>A</code> has a link to resource <code>B</code>, and resource <code>B</code> is later marked as deleted, <code>A</code>'s link will still exist. DSP-API v2 will still return the link when <code>A</code> is queried, but without any information about <code>B</code> (except for <code>B</code>'s IRI). If <code>A</code>'s link is necessary to meet the requirements of a cardinality, marking <code>B</code> as deleted will not violate the cardinality.</p> <p>The reason for this design is that <code>A</code> and <code>B</code> might be in different projects, and each project must retain control of its resources and be able to mark them as deleted, even if they are used by another project.</p>"},{"location":"03-endpoints/api-v2/editing-resources/#erasing-a-resource-from-the-triplestore","title":"Erasing a Resource from the Triplestore","text":"<p>Normally, resources are not actually removed from the triplestore; they are only marked as deleted (see Deleting a Resource). However, sometimes it is necessary to erase a resource from the triplestore. To do so, use this route:</p> <pre><code>HTTP POST to http://host/v2/resources/erase\n</code></pre> <p>The request body is the same as for Deleting a Resource, except that <code>knora-api:deleteComment</code> is not relevant and will be ignored.</p> <p>To do this, a user must be a system administrator or an administrator of the project containing the resource. The user's permissions on the resource are not otherwise checked.</p> <p>A resource cannot be erased if any other resource has a link to it. Any such links must first be changed or marked as deleted (see Updating a Value and Deleting a Value). Then, when the resource is erased, the deleted link values that referred to it will also be erased.</p> <p>This operation cannot be undone (except by restoring the repository from a backup), so use it with care.</p>"},{"location":"03-endpoints/api-v2/editing-values/","title":"Creating and Editing Values","text":""},{"location":"03-endpoints/api-v2/editing-values/#creating-a-value","title":"Creating a Value","text":"<p>To create a value in an existing resource, use this route:</p> <pre><code>HTTP POST to http://host/v2/values\n</code></pre> <p>The body of the request is a JSON-LD document in the complex API schema, specifying the resource's IRI and type, the resource property, and the content of the value. The representation of the value is the same as when it is returned in a <code>GET</code> request, except that its IRI and <code>knora-api:attachedToUser</code> are not given. For example, to create an integer value:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\": 4\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>Each value can have a comment, given in <code>knora-api:valueHasComment</code>. For example:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\": 4,\n    \"knora-api:valueHasComment\": \"This is a comment.\"\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>Permissions for the new value can be given by adding <code>knora-api:hasPermissions</code>. For example:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\": 4,\n    \"knora-api:hasPermissions\": \"CR knora-admin:Creator|V http://rdfh.ch/groups/0001/thing-searcher\"\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>Each value can have an optional custom IRI (of Knora IRI form) specified by the <code>@id</code> attribute, a custom creation date specified by adding <code>knora-api:valueCreationDate</code> (an xsd:dateTimeStamp), or a custom UUID given by <code>knora-api:valueHasUUID</code>. Each custom UUID must be base64url-encoded, without padding. If a custom UUID is provided, it will be used in value IRI. If a custom IRI is given for the value, its UUID should match the given custom UUID. If a custom IRI is provided, but there is no custom UUID provided, then the UUID given in the IRI will be assigned to the <code>knora-api:valueHasUUID</code>. A custom value IRI must be the IRI of the containing resource, followed by a <code>/values/</code> and a custom ID string. For example:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@id\": \"http://rdfh.ch/0001/a-thing/values/IN4R19yYR0ygi3K2VEHpUQ\",\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\": 21,\n    \"knora-api:valueHasUUID\": \"IN4R19yYR0ygi3K2VEHpUQ\",\n    \"knora-api:valueCreationDate\": {\n      \"@type\": \"xsd:dateTimeStamp\",\n      \"@value\": \"2020-06-04T12:58:54.502951Z\"\n    }\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\",\n    \"xsd\": \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>The format of the object of <code>knora-api:hasPermissions</code> is described in Permissions.</p> <p>If permissions are not given, configurable default permissions are used (see Default Object Access Permissions ).</p> <p>To create a value, the user must have modify permission on the containing resource.</p> <p>The response is a JSON-LD document containing:</p> <ul> <li><code>@id</code>: the IRI of the value that was created.</li> <li><code>@type</code>: the value's type.</li> <li><code>knora-api:valueHasUUID</code>, the value's UUID, which remains stable across value versions   (except for link values, as explained below).</li> </ul>"},{"location":"03-endpoints/api-v2/editing-values/#creating-a-link-between-resources","title":"Creating a Link Between Resources","text":"<p>To create a link, you must create a <code>knora-api:LinkValue</code>, which represents metadata about the link. The property that connects the resource to the <code>LinkValue</code> is a link value property, whose name is constructed by adding <code>Value</code> to the name of the link property (see Links Between Resources). The triple representing the direct link between the resources is created automatically. For example, if the link property that should connect the resources is <code>anything:hasOtherThing</code>, we can create a link like this:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasOtherThingValue\": {\n    \"@type\": \"knora-api:LinkValue\",\n    \"knora-api:linkValueHasTargetIri\": {\n      \"@id\": \"http://rdfh.ch/0001/tPfZeNMvRVujCQqbIbvO0A\"\n    }\n  },\n  \"@context\": {\n    \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>As with ordinary values, permissions on links can be specified by adding <code>knora-api:hasPermissions</code>.</p> <p>The response is a JSON-LD document containing:</p> <ul> <li><code>@id</code>: the IRI of the value that was created.</li> <li><code>@type</code>: the value's type.</li> <li><code>knora-api:valueHasUUID</code>, the value's UUID, which remains stable across value versions, unless the link is changed to   point to a different resource, in which case it is considered a new link and gets a new UUID. Changing a link's   metadata, without changing its target, creates a new version of the link value with the same UUID.</li> </ul>"},{"location":"03-endpoints/api-v2/editing-values/#creating-a-text-value-without-standoff-markup","title":"Creating a Text Value Without Standoff Markup","text":"<p>Use the predicate <code>knora-api:valueAsString</code> of <code>knora-api:TextValue</code>:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasText\": {\n    \"@type\": \"knora-api:TextValue\",\n    \"knora-api:valueAsString\": \"This is a text without markup.\"\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/editing-values/#creating-a-text-value-with-standoff-markup","title":"Creating a Text Value with Standoff Markup","text":"<p>Currently, the only way to create a text value with standoff markup is to submit it in XML format using an XML-to-standoff mapping. See the overview for more detials.</p>"},{"location":"03-endpoints/api-v2/editing-values/#creating-a-text-value-with-standard-mapping","title":"Creating a Text Value with Standard Mapping","text":"<p>To create a value with the standard mapping (<code>http://rdfh.ch/standoff/mappings/StandardMapping</code>), we can make an XML document like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;text&gt;\n    This text links to another &lt;a class=\"salsah-link\" href=\"http://rdfh.ch/0001/another-thing\"&gt;resource&lt;/a&gt;.\n&lt;/text&gt;\n</code></pre> <p>This document can then be embedded in a JSON-LD request, using the predicate <code>knora-api:textValueAsXml</code>:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasText\": {\n    \"@type\": \"knora-api:TextValue\",\n    \"knora-api:textValueAsXml\": \"&lt;?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?&gt;\\n&lt;text&gt;\\n   This text links to another &lt;a class=\\\"salsah-link\\\" href=\\\"http://rdfh.ch/0001/another-thing\\\"&gt;resource&lt;/a&gt;.\\n&lt;/text&gt;\",\n    \"knora-api:textValueHasMapping\": {\n      \"@id\": \"http://rdfh.ch/standoff/mappings/StandardMapping\"\n    }\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>Note that quotation marks and line breaks in the XML must be escaped, and that the IRI of the mapping must be provided.</p>"},{"location":"03-endpoints/api-v2/editing-values/#creating-a-text-value-with-a-custom-mapping","title":"Creating a Text Value with a Custom Mapping","text":"<p>To create a text value with custom mapping, the following steps are required:</p> <ol> <li>Optionally, an XSL transformation resource (<code>kb:XSLTransformation</code>) can be created that may be defined as the default    transformation of the mapping.</li> <li>The mapping resource (<code>kb:XMLToStandoffMapping</code>) must be created, if it does not already exist.</li> <li>The text value can be created as in the example above, using the mapping resource IRI in <code>kb:textValueHasMapping</code>.</li> </ol> <p>The <code>kb:XSLTransformation</code> resource is a subclass of <code>kb:TextRepresentation</code>, so it has a <code>kb:hasTextFileValue</code> pointing to a <code>kb:TextFileValue</code> which represents the XSLT file stored in SIPI. For more Details, see Creating File Values.</p> <p>The <code>kb:XMLToStandoffMapping</code> resource requires the mapping XML as specified in the custom standoff documentation. If an XSL transformation has been defined, the IRI the transformation can be placed in the <code>&lt;defaultXSLTransformation&gt;</code> tag of the mapping XML.</p> <p>If a mapping has been defined, then requesting the text value will return both the <code>kb:textValueAsXml</code> and the <code>kb:textValueAsHtml</code> properties, where the XML can be used for editing the value, while the HTML can be used to display it. If no mapping has been defined, only <code>kb:textValueAsXml</code> can be returned.</p>"},{"location":"03-endpoints/api-v2/editing-values/#creating-file-values","title":"Creating File Values","text":"<p>DSP-API supports the storage of certain types of data as files, using SIPI (see FileValue). DSP-API v2 currently supports using SIPI to store the following types of files:</p> <ul> <li>Images: JPEG, JPEG2000, TIFF, or PNG which are stored internally as JPEG2000</li> <li>Documents: PDF</li> <li>Audio: MPEG or Waveform audio file format (.wav, .x-wav, .vnd.wave)</li> <li>Text files: CSV, JSON, ODD, RNG, TXT, XLS, XLSX, XML, XSD, XSL</li> <li>Video files: MP4</li> <li>Archive files: ZIP, TAR, GZIP</li> </ul> <p>Support for other types of files will be added in the future.</p> <p>The following sections describe the steps for creating a file value.</p> <p>Files can be ingested into DSP using SIPI or DSP-INGEST (experimental).</p>"},{"location":"03-endpoints/api-v2/editing-values/#upload-files-to-sipi","title":"Upload Files to SIPI","text":"<p>The first step is to upload one or more files to SIPI, using a <code>multipart/form-data</code> request, where <code>sipihost</code> represents the host and port on which SIPI is running:</p> <pre><code>HTTP POST to http://sipihost/upload?token=TOKEN\n</code></pre> <p>The <code>token</code> parameter must provide the JSON Web Token that DSP-API returned when the client logged in. Each body part in the request must contain a parameter <code>filename</code>, providing the file's original filename, which both DSP-API and SIPI will store; these filenames can be descriptive and need not be unique.</p> <p>SIPI stores the file in a temporary location. If the file is an image, it is converted first to JPEG2000 format, and the converted file is stored.</p> <p>SIPI then returns a JSON response that looks something like this:</p> <pre><code>{\n  \"uploadedFiles\": [\n    {\n      \"originalFilename\": \"manuscript-1234-page-1.tiff\",\n      \"internalFilename\": \"3UIsXH9bP0j-BV0D4sN51Xz.jp2\",\n      \"temporaryBaseIIIFUrl\": \"http://sipihost/tmp\"\n    },\n    {\n      \"originalFilename\": \"manuscript-1234-page-2.tiff\",\n      \"internalFilename\": \"2RvJgguglpe-B45EOk0Gx8H.jp2\",\n      \"temporaryBaseIIIFUrl\": \"http://sipihost/tmp\"\n    }\n  ]\n}\n</code></pre> <p>In this example, we uploaded two files to SIPI, so <code>uploadedFiles</code> is an array with two elements. For each file, we have:</p> <ul> <li>the <code>originalFilename</code>, which we submitted when uploading the file</li> <li>the unique <code>internalFilename</code> that SIPI has randomly generated for the file</li> <li>the <code>temporaryBaseIIIFUrl</code>, which we can use to construct a IIIF URL for previewing the file</li> </ul> <p>In the case of an image file, the client may now wish to get a thumbnail of each uploaded image, to allow the user to confirm that the correct files have been uploaded. This can be done by adding IIIF parameters to <code>temporaryBaseIIIFUrl</code>. For example, to get a JPG thumbnail image that is 150 pixels wide, you would add <code>/full/150,/0/default.jpg</code>.</p>"},{"location":"03-endpoints/api-v2/editing-values/#upload-files-to-dsp-ingest","title":"Upload Files to DSP-INGEST","text":"<p>Support for uploads with DSP-INGEST is now the preferred method of uploading files (and also for ingesting large amounts of data internally).</p>"},{"location":"03-endpoints/api-v2/editing-values/#submit-a-file-value-to-dsp-api","title":"Submit A File Value to DSP-API","text":"<p>A DSP-API <code>Representation</code> (i.e. a resource containing information about a file) must always have exactly one file value attached to it. (see Representations). Therefore, a request to create a new file value must always be submitted as part of a request to create a new resource (see Creating a Resource). You can also update a file value in an existing <code>Representation</code>; see Updating a Value.</p> <p>Instead of providing the file's complete metadata to DSP-API, you just provide the unique internal filename generated by SIPI.</p>"},{"location":"03-endpoints/api-v2/editing-values/#still-images","title":"Still Images","text":"<p>Still Image may be stored in SIPI or in an external IIIF server.</p>"},{"location":"03-endpoints/api-v2/editing-values/#images-stored-in-sipi","title":"Images stored in SIPI","text":"<p>Here is an example of a request to create a resource of class <code>anything:ThingPicture</code> with a still image stored in SIPI. The resource's class is a subclass of <code>knora-api:StillImageRepresentation</code> and therefore has the property <code>knora-api:hasStillImageFileValue</code>. The file value is of type <code>knora-api:StillImageFileValue</code>:</p> <pre><code>{\n  \"@type\": \"anything:ThingPicture\",\n  \"knora-api:hasStillImageFileValue\": {\n    \"@type\": \"knora-api:StillImageFileValue\",\n    \"knora-api:fileValueHasFilename\": \"3UIsXH9bP0j-BV0D4sN51Xz.jp2\"\n  },\n  \"knora-api:attachedToProject\": {\n    \"@id\": \"http://rdfh.ch/projects/0001\"\n  },\n  \"rdfs:label\": \"test thing\",\n  \"@context\": {\n    \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>In the case of a <code>knora-api:StillImageFileValue</code> DSP-API gets the rest of the file's metadata from SIPI. If the client's request to DSP-API is valid, DSP-API saves the file value in the triplestore and instructs SIPI to move the file to permanent storage. Otherwise, the temporary file that was stored by SIPI is deleted.</p>"},{"location":"03-endpoints/api-v2/editing-values/#images-stored-in-an-external-iiif-server","title":"Images stored in an external IIIF server","text":"<p>In the case of a Still image stored in an external IIIF server, the request is similar to the one above, but the file value is of type <code>knora-api:StillImageExternalFileValue</code> and the <code>knora-api:externalUrl</code> property is used to provide the URL of the image in the IIIF server:</p> <pre><code>{\n  \"@type\": \"anything:ThingPicture\",\n  \"knora-api:hasStillImageFileValue\": {\n    \"@type\": \"knora-api:StillImageExternalFileValue\",\n    \"knora-api:stillImageFileValueHasExternalUrl\": {\n      \"@type\": \"xsd:anyURI\",\n      \"@value\": \"https://example.com/iiif/3UIsXH9bP0j-BV0D4sN51Xz.jp2/full/max/0/default.jpg\"\n    }\n  },\n  \"knora-api:attachedToProject\": {\n    \"@id\": \"http://rdfh.ch/projects/0001\"\n  },\n  \"rdfs:label\": \"test thing\",\n  \"@context\": {\n    \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>Note</p> <p>For backwards compatibility, we support using <code>knora-api:fileValueHasExternalUrl</code> and  <code>knora-api:stillImageFileValueExternalFileValue</code> properties if the value is submitted as a <code>String</code> literal, i.e.  <code>\"knora-api:stillImageFileValueExternalFileValue\" : \"https://example.com/iiif/3UIsXH9bP0j-BV0D4sN51Xz.jp2/full/max/0/default.jpg\"</code>.</p> <p>Support for <code>String</code> literals and the <code>knora-api:fileValueHasExternalUrl</code> property  is deprecated and will be removed in the future. The <code>knora-api:stillImageFileValueHasExternalUrl</code> property with a <code>xsd:anyURI</code> type  is correct and must be used for reading and writing.</p>"},{"location":"03-endpoints/api-v2/editing-values/#pdf-documents","title":"PDF Documents","text":"<p>If you're submitting a PDF document, use the resource class <code>knora-api:DocumentRepresentation</code>, which has the property <code>knora-api:hasDocumentFileValue</code>, pointing to a <code>knora-api:DocumentFileValue</code>.</p>"},{"location":"03-endpoints/api-v2/editing-values/#text-files","title":"Text Files","text":"<p>For a text file, use <code>knora-api:TextRepresentation</code>, which has the property <code>knora-api:hasTextFileValue</code>, pointing to a <code>knora-api:TextFileValue</code>.</p>"},{"location":"03-endpoints/api-v2/editing-values/#archive-files","title":"Archive Files","text":"<p>For an archive like zip, use <code>knora-api:ArchiveRepresentation</code>, which has the property <code>knora-api:hasArchiveFileValue</code>, pointing to a <code>knora-api:ArchiveFileValue</code>.</p>"},{"location":"03-endpoints/api-v2/editing-values/#updating-a-value","title":"Updating a Value","text":"<p>To update a value, use this route:</p> <pre><code>HTTP PUT to http://host/v2/values\n</code></pre> <p>Updating a value means creating a new version of an existing value. The new version will have a different IRI. The request is the same as for creating a value, except that the <code>@id</code> of the current value version is given. For example, to update an integer value:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@id\": \"http://rdfh.ch/0001/a-thing/values/vp96riPIRnmQcbMhgpv_Rg\",\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\": 5\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>The value can be given a comment by using <code>knora-api:valueHasComment</code>. To change only the comment of a value, you can resubmit the existing value with the updated comment.</p> <p>Permissions can be specified by adding <code>knora-api:hasPermissions</code>. Otherwise, the new version has the same permissions as the previous one. To change the permissions on a value, the user must have change rights permission on the value.</p> <p>To update only the permissions on a value, submit it with the new permissions and with its <code>@id</code> and <code>@type</code> but without any other content, like this:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@id\": \"http://rdfh.ch/0001/a-thing/values/vp96riPIRnmQcbMhgpv_Rg\",\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:hasPermissions\": \"CR knora-admin:Creator|V knora-admin:KnownUser\"\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>To update a link, the user must have modify permission on the containing resource as well as on the value.</p> <p>To update a value and give it a custom timestamp, add <code>knora-api:valueCreationDate</code> (an xsd:dateTimeStamp).</p> <p>To update a value and give the new version a custom IRI, add <code>knora-api:newValueVersionIri</code>, like this:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@id\": \"http://rdfh.ch/0001/a-thing/values/vp96riPIRnmQcbMhgpv_Rg\",\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:intValueAsInt\": 21,\n    \"knora-api:newValueVersionIri\": {\n      \"@id\": \"http://rdfh.ch/0001/a-thing/values/int-value-IRI\"\n    }\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>A custom value IRI must be the IRI of the containing resource, followed by a <code>/values/</code> and a custom ID string.</p> <p>The response is a JSON-LD document containing only <code>@id</code> and <code>@type</code>, returning the IRI and type of the new value version.</p> <p>If you submit an outdated value ID in a request to update a value, the response will be an HTTP 404 (Not Found) error.</p> <p>The response to a value update request contains:</p> <ul> <li><code>@id</code>: the IRI of the value that was created.</li> <li><code>@type</code>: the value's type.</li> <li><code>knora-api:valueHasUUID</code>, the value's UUID, which remains stable across value versions, unless the value is a link   value and is changed to point to a different resource, in which case it is considered a new link and gets a new UUID.</li> </ul>"},{"location":"03-endpoints/api-v2/editing-values/#deleting-a-value","title":"Deleting a Value","text":"<p>DSP-API does not normally delete values; instead, it marks them as deleted, which means that they do not appear in normal query results.</p> <p>To mark a value as deleted, use this route:</p> <pre><code>HTTP POST to http://host/v2/values/delete\n</code></pre> <p>The request must include the resource's ID and type, the property that points from the resource to the value, and the value's ID and type. For example:</p> <pre><code>{\n  \"@id\": \"http://rdfh.ch/0001/a-thing\",\n  \"@type\": \"anything:Thing\",\n  \"anything:hasInteger\": {\n    \"@id\": \"http://rdfh.ch/0001/a-thing/values/vp96riPIRnmQcbMhgpv_Rg\",\n    \"@type\": \"knora-api:IntValue\",\n    \"knora-api:deleteComment\": \"This value was created by mistake.\"\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre> <p>The optional property <code>knora-api:deleteComment</code> specifies a comment to be attached to the value, explaining why it has been marked as deleted</p> <p>The optional property <code>knora-api:deleteDate</code> (an xsd:dateTimeStamp) specifies a custom timestamp indicating when the value was deleted. If not specified, the current time is used.</p> <p>The response is a JSON-LD document containing the predicate <code>knora-api:result</code> with a confirmation message.</p>"},{"location":"03-endpoints/api-v2/editing-values/#requesting-deleted-values","title":"Requesting Deleted Values","text":"<p>Values marked as deleted are not found in search queries. But when requesting a resource that has deleted values, these will show up as generic <code>knora-api:DeletedValue</code> values. This value will be similar to the deleted value, having e.g. the same IRI. The <code>DeletedValue</code> will contain the deletion date and optionally the deletion comment.</p> <p>The response to requesting a deleted resource will look as the following example:</p> <pre><code>{\n  \"knora-api:DeletedValue\": [\n    {\n      \"knora-api:versionArkUrl\": {\n        \"@value\": \"http://0.0.0.0:3336/ark:/72163/1/0001/a=thingO/sWSymIzAS_qXqyHLhwbwwAU.20211216T18193124797Z\",\n        \"@type\": \"xsd:anyURI\"\n      },\n      \"knora-api:userHasPermission\": \"RV\",\n      \"knora-api:valueCreationDate\": {\n        \"@value\": \"2021-12-16T18:19:31.247970Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"knora-api:deleteDate\": {\n        \"@type\": \"xsd:dateTimeStamp\",\n        \"@value\": \"2021-12-16T18:20:02.550828Z\"\n      },\n      \"knora-api:attachedToUser\": {\n        \"@id\": \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n      },\n      \"knora-api:valueHasUUID\": \"sWSymIzAS_qXqyHLhwbwwA\",\n      \"knora-api:hasPermissions\": \"CR knora-admin:Creator|M knora-admin:ProjectMember|V knora-admin:KnownUser|RV knora-admin:UnknownUser\",\n      \"knora-api:isDeleted\": true,\n      \"@type\": \"knora-api:DeletedValue\",\n      \"http://www.knora.org/ontology/knora-base#DeletedValue\": \"DeletedValue\",\n      \"@id\": \"http://rdfh.ch/0001/a-thing/values/DrXts3Up3DijGriI403nhg\",\n      \"knora-api:deleteComment\": \"This value is obsolete\",\n      \"knora-api:arkUrl\": {\n        \"@value\": \"http://0.0.0.0:3336/ark:/72163/1/0001/a=thingO/sWSymIzAS_qXqyHLhwbwwAU\",\n        \"@type\": \"xsd:anyURI\"\n      }\n    },\n    {}\n  ]\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/getting-lists/","title":"Getting Lists","text":""},{"location":"03-endpoints/api-v2/getting-lists/#getting-a-complete-list","title":"Getting a complete List","text":"<p>In order to request a complete list, make a HTTP GET request to the <code>lists</code> route,  appending the Iri of the list's root node (URL-encoded):</p> <pre><code>HTTP GET to http://host/v2/lists/listRootNodeIri\n</code></pre> <p>Lists are only returned in the complex schema.  The response to a list request is a <code>List</code> (see interface <code>List</code> in module <code>ListResponse</code>). </p>"},{"location":"03-endpoints/api-v2/getting-lists/#getting-a-single-node","title":"Getting a single Node","text":"<p>In order to request a single node of a list, make a HTTP GET request to the <code>node</code> route,  appending the node's Iri (URL-encoded):</p> <pre><code>HTTP GET to http://host/v2/node/nodeIri\n</code></pre> <p>Nodes are only returned in the complex schema.  The response to a node request is a <code>ListNode</code> (see interface <code>List</code> in module <code>ListResponse</code>).</p>"},{"location":"03-endpoints/api-v2/introduction/","title":"Introduction: Using API v2","text":""},{"location":"03-endpoints/api-v2/introduction/#api-v2-path-segment","title":"API v2 Path Segment","text":"<p>Every request to API v2 includes <code>v2</code> as a path segment, e.g. <code>http://host/v2/resources/http%3A%2F%2Frdfh.ch%2Fc5058f3a</code>. Accordingly, requests using any other version of the API will require another path segment.</p>"},{"location":"03-endpoints/api-v2/introduction/#response-formats","title":"Response Formats","text":"<p>All API v2 responses can be returned in JSON-LD, Turtle, or RDF/XML, using HTTP content negotiation. The client can request these formats using the following MIME types:</p> Format MIME Type JSON-LD <code>application/ld+json</code> Turtle <code>text/turtle</code> RDF/XML <code>application/rdf+xml</code>"},{"location":"03-endpoints/api-v2/introduction/#json-ld","title":"JSON-LD","text":"<p>Our preferred format for data exchange is JSON-LD. JSON-LD allows the DSP-API server to provide responses that are relatively easy for automated processes to interpret, since their structure and semantics is explicitly defined. For example, each user-created Knora resource property is identified by an IRI, which can be dereferenced to get more information about it (e.g. its label in different languages). Moreover, each value has a type represented by an IRI. These are either standard RDF types (e.g. XSD datatypes) or more complex types whose IRIs can be dereferenced to get more information about their structure.</p> <p>At the same time, JSON-LD responses are relatively easy for software developers to work with, and are more concise and easier to read than the equivalent XML. Items in a response can have human-readable names, which can nevertheless be expanded to full IRIs. Also, while a format such as Turtle just provides a set of RDF triples, an equivalent JSON-LD response can explicitly provide data in a hierarchical structure, with objects nested inside other objects.</p>"},{"location":"03-endpoints/api-v2/introduction/#hierarchical-vs-flat-json-ld","title":"Hierarchical vs. Flat JSON-LD","text":"<p>The client can choose between hierarchical and flat JSON-LD. In hierarchical JSON-LD, entities with IRIs are inlined (nested) where they are used. If the same entity is used in more than one place, it is inlined only once, and other uses just refer to its IRI. In Knora's flat JSON-LD, all entities with IRIs are located at the top level of the document (in a <code>@graph</code> if there is more than one of them). This setting does not affect blank nodes, which are always inlined (unlike in standard flat JSON-LD). DSP ontologies are always returned in the <code>flat</code> rendering; other kinds of responses default to <code>hierarchical</code>. To use this setting, submit the HTTP header <code>X-Knora-JSON-LD-Rendering</code> with the value <code>hierarchical</code> or <code>flat</code>.</p>"},{"location":"03-endpoints/api-v2/introduction/#knora-iris","title":"Knora IRIs","text":"<p>Resources and entities are identified by IRIs. The format of these IRIs is explained in Knora IRIs.</p>"},{"location":"03-endpoints/api-v2/introduction/#api-schema","title":"API Schema","text":"<p>DSP-API v2 uses RDF data structures that are simpler than the ones actually stored in the triplestore, and more suitable for the development of client software. Thus we refer to the internal schema of data as it is stored in the triplestore, and to external schemas which are used to represent that data in API v2.</p> <p>DSP-API v2 offers a complex schema and a simple one. The main difference is that the complex schema exposes the complexity of value objects, while the simple version does not. A client that needs to edit values must use the complex schema in order to obtain the IRI of each value. A client that reads but does not update data can use the simplified schema. The simple schema is mainly intended to facilitate interoperability with other RDF-based systems in the context of Linked Open Data. It is therefore designed to use the simplest possible datatypes and to require minimal knowledge of Knora.</p> <p>In either case, the client deals only with data whose structure and semantics are defined by external DSP-API ontologies, which are distinct from the internal ontologies that are used to store date in the triplestore. The Knora API server automatically converts back and forth between these internal and external representations. This approach encapsulates the internals and adds a layer of abstraction to them.</p> <p>IRIs representing ontologies and ontology entities are different in different schemas; see Knora IRIs.</p> <p>Some API operations inherently require the client to accept responses in the complex schema. For example, if an ontology is requested using an IRI indicating the simple schema, the ontology will be returned in the simple schema (see Querying, Creating, and Updating Ontologies).</p> <p>Other API operations can return data in either schema. In this case, the complex schema is used by default in the response, unless the request specifically asks for the simple schema. The client can specify the desired schema by using an HTTP header or a URL parameter:</p> <ul> <li>the HTTP header <code>X-Knora-Accept-Schema</code></li> <li>the URL parameter <code>schema</code></li> </ul> <p>Both the HTTP header and the URL parameter accept the values <code>simple</code> or <code>complex</code>.</p>"},{"location":"03-endpoints/api-v2/knora-iris/","title":"Knora IRIs","text":"<p>The IRIs used in Knora repositories and in the DSP-API v2 follow certain conventions.</p>"},{"location":"03-endpoints/api-v2/knora-iris/#project-short-codes","title":"Project Short-Codes","text":"<p>A project short-code is a hexadecimal number of at least four digits, assigned by the DaSCH to uniquely identify a Knora project regardless of where it is hosted. The IRIs of ontologies that are built into Knora do not contain shortcodes; these ontologies implicitly belong to the Knora system project.</p> <p>A user-created ontology IRI must always include its project shortcode.</p> <p>Project ID <code>0000</code> is reserved for shared ontologies (see Shared Ontologies).</p> <p>The range of project IDs from <code>0001</code> to <code>00FF</code> inclusive is reserved for local testing. Thus, the first useful project will be <code>0100</code>.</p> <p>In the beginning, Unil will use the IDs <code>0100</code> to <code>07FF</code>, and Unibas <code>0800</code> to <code>08FF</code>.</p>"},{"location":"03-endpoints/api-v2/knora-iris/#iris-for-ontologies-and-ontology-entities","title":"IRIs for Ontologies and Ontology Entities","text":""},{"location":"03-endpoints/api-v2/knora-iris/#internal-ontology-iris","title":"Internal Ontology IRIs","text":"<p>Knora makes a distinction between internal and external ontologies. Internal ontologies are used in the triplestore, while external ontologies are used in API v2. For each internal ontology, there is a corresponding external ontology. Some internal ontologies are built into Knora, while others are user-created. Knora automatically generates external ontologies based on user-created internal ontologies.</p> <p>Each internal ontology has an IRI, which is also the IRI of the named graph that contains the ontology in the triplestore. An internal ontology IRI has the form:</p> <pre><code>http://www.knora.org/ontology/PROJECT_SHORTCODE/ONTOLOGY_NAME\n</code></pre> <p>For example, the internal ontology IRI based on project code <code>0001</code> and ontology name <code>example</code> would be:</p> <pre><code>http://www.knora.org/ontology/0001/example\n</code></pre> <p>An ontology name must be a valid XML NCName and must be URL safe. The following names are reserved for built-in internal DSP ontologies:</p> <ul> <li><code>knora-base</code></li> <li><code>standoff</code></li> <li><code>salsah-gui</code></li> </ul> <p>Names starting with <code>knora</code> are reserved for future built-in Knora ontologies. A user-created ontology name may not start with the letter <code>v</code> followed by a digit, and may not contain these reserved words:</p> <ul> <li><code>knora</code></li> <li><code>ontology</code></li> <li><code>simple</code></li> <li><code>shared</code></li> </ul>"},{"location":"03-endpoints/api-v2/knora-iris/#external-ontology-iris","title":"External Ontology IRIs","text":"<p>Unlike internal ontology IRIs, external ontology IRIs are meant to be dereferenced as URLs. When an ontology IRI is dereferenced, the ontology itself can be served either in a machine-readable format or as human-readable documentation.</p> <p>The IRI of an external Knora ontology has the form:</p> <pre><code>http://HOST[:PORT]/ontology/PROJECT_SHORTCODE/ONTOLOGY_NAME/API_VERSION\n</code></pre> <p>For built-in and shared ontologies, the host is always <code>api.knora.org</code>. Otherwise, the hostname and port configured in <code>application.conf</code> under <code>app.http.knora-api.host</code> and <code>app.http.knora-api.http-port</code> are used (the port is omitted if it is 80).</p> <p>This means that when a built-in or shared external ontology IRI is dereferenced, the ontology can be served by a DSP-API server running at <code>api.knora.org</code>. When the external IRI of a non-shared, project-specific ontology is dereferenced, the ontology can be served by Knora that hosts the project. During development and testing, this could be <code>localhost</code>.</p> <p>The name of an external ontology is the same as the name of the corresponding internal ontology, with one exception: the external form of <code>knora-base</code> is called <code>knora-api</code>.</p> <p>The API version identifier indicates not only the version of the API, but also an API 'schema'. The DSP-API v2 is available in two schemas:</p> <ul> <li>A complex schema, which is suitable both for reading and for editing   data. The complex schema represents values primarily as complex   objects. Its version identifier is <code>v2</code>.</li> <li>A simple schema, which is suitable for reading data but not for   editing it. The simple schema facilitates interoperability between   DSP ontologies and non-DSP ontologies, since it represents   values primarily as literals. Its version identifier is <code>simple/v2</code>.</li> </ul> <p>Other schemas could be added in the future for more specific use cases.</p> <p>When requesting an ontology, the client requests a particular schema. (This will also be true of most DSP-API v2 requests: the client will be able to specify which schema the response should be provided in.)</p> <p>For example, suppose a DSP-API server is running at <code>knora.example.org</code> and hosts an ontology whose internal IRI is <code>http://www.knora.org/ontology/0001/example</code>. That ontology can then be requested using either of these IRIs:</p> <ul> <li><code>http://knora.example.org/ontology/0001/example/v2</code> (in the complex schema)</li> <li><code>http://knora.example.org/ontology/0001/example/simple/v2</code> (in the simple schema)</li> </ul> <p>While the internal <code>example</code> ontology refers to definitions in <code>knora-base</code>, the external <code>example</code> ontology that is served by the API refers instead to a <code>knora-api</code> ontology, whose IRI depends on the schema being used:</p> <ul> <li><code>http://api.knora.org/ontology/knora-api/v2</code> (in the complex schema)</li> <li><code>http://api.knora.org/ontology/knora-api/simple/v2</code> (in the simple schema)</li> </ul>"},{"location":"03-endpoints/api-v2/knora-iris/#ontology-entity-iris","title":"Ontology Entity IRIs","text":"<p>DSP ontologies use 'hash namespaces' (see URI Namespaces). This means that the IRI of an ontology entity (a class or property definition) is constructed by adding a hash character (<code>#</code>) to the ontology IRI, followed by the name of the entity. In Knora, an entity name must be a valid XML NCName. Thus, if there is a class called <code>ExampleThing</code> in an ontology whose internal IRI is <code>http://www.knora.org/ontology/0001/example</code>, that class has the following IRIs:</p> <ul> <li><code>http://www.knora.org/ontology/0001/example#ExampleThing</code> (in the internal ontology)</li> <li><code>http://HOST[:PORT]/ontology/0001/example/v2#ExampleThing</code> (in the API v2 complex schema)</li> <li><code>http://HOST[:PORT]/ontology/0001/example/simple/v2#ExampleThing</code> (in the API v2 simple schema)</li> </ul>"},{"location":"03-endpoints/api-v2/knora-iris/#shared-ontology-iris","title":"Shared Ontology IRIs","text":"<p>As explained in Shared Ontologies, a user-created ontology can be defined as shared, meaning that it can be used by multiple projects, and that its creators will not change it in ways that could affect other ontologies or data that are based on it.</p> <p>There is currently one project for shared ontologies:</p> <pre><code>http://www.knora.org/ontology/knora-base#DefaultSharedOntologiesProject\n</code></pre> <p>Its project code is <code>0000</code>. Additional projects for shared ontologies may be supported in future.</p> <p>The internal and external IRIs of shared ontologies always use the hostname <code>api.knora.org</code>, and have an additional segment, <code>shared</code>, after <code>ontology</code>. The project code can be omitted, in which case the default shared ontology project, <code>0000</code>, is assumed. The sample shared ontology, <code>example-box</code>, has these IRIs:</p> <ul> <li><code>http://www.knora.org/ontology/shared/example-box</code> (internal)</li> <li><code>http://api.knora.org/ontology/shared/example-box/v2</code> (external, complex schema)</li> <li><code>http://api.knora.org/ontology/shared/example-box/simple/v2</code> (external, simple schema)</li> </ul>"},{"location":"03-endpoints/api-v2/knora-iris/#iris-for-data","title":"IRIs for Data","text":"<p>Knora generates IRIs for data that it creates in the triplestore. Each generated data IRI contains one or more UUID identifiers to make it unique. To keep data IRIs relatively short, each UUID is base64url-encoded, without padding; thus each UUID is a 22-character string. DSP-API supports UUID version 4 or 5.</p> <p>Data IRIs are not currently intended to be dereferenced as URLs. Instead, each Knora resource has a separate permalink.</p> <p>A Knora value does not have a stable IRI throughout its version history. Each time a new version of a value is made, the new version gets a new IRI. Therefore, it would not make sense to publish Knora value IRIs. When designing ontologies for Knora projects, keep in mind that if you want something be directly citable, it needs to be a resource, not a value.</p> <p>The formats of generated data IRIs for different types of objects are as follows:</p> <ul> <li>Resource: <code>http://rdfh.ch/PROJECT_SHORTCODE/RESOURCE_UUID</code>.</li> <li>Value:   <code>http://rdfh.ch/PROJECT_SHORTCODE/RESOURCE_UUID/values/VALUE_UUID</code></li> <li>Standoff tag:   <code>http://rdfh.ch/PROJECT_SHORTCODE/RESOURCE_UUID/values/VALUE_UUID/STANDOFF_UUID</code></li> <li>XML-to-standoff mapping:   <code>http://rdfh.ch/projects/PROJECT_SHORTCODE/mappings/MAPPING_NAME</code></li> <li>XML-to-standoff mapping element:   <code>http://rdfh.ch/projects/PROJECT_SHORTCODE/mappings/MAPPING_NAME/elements/MAPPING_ELEMENT_UUID</code></li> <li>Project: <code>http://rdfh.ch/projects/PROJECT_UUID</code></li> <li>Group: <code>http://rdfh.ch/groups/PROJECT_SHORTCODE/GROUP_UUID</code></li> <li>Permission:   <code>http://rdfh.ch/permissions/PROJECT_SHORTCODE/PERMISSION_UUID</code></li> <li>Lists: <code>http://rdfh.ch/lists/PROJECT_SHORTCODE/LIST_UUID</code></li> <li>User: <code>http://rdfh.ch/users/USER_UUID</code></li> </ul>"},{"location":"03-endpoints/api-v2/ontology-information/","title":"Querying, Creating, and Updating Ontologies","text":""},{"location":"03-endpoints/api-v2/ontology-information/#querying-ontology-information","title":"Querying Ontology Information","text":"<p>Before reading this document, you should have a basic understanding of DSP-API v2 external ontology schemas (see API Schema).</p> <p>Each request returns a single RDF graph, which can be represented in JSON-LD, Turtle, or RDF/XML, using HTTP content negotiation (see Response Formats).</p> <p>The response format uses prefixes to shorten IRIs, making them more human-readable. A client may wish to convert these to full IRIs for processing. This can be done with responses in JSON-LD by using a library that implements the JSON-LD API to compact the document with an empty JSON-LD <code>@context</code>.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#querying-ontology-metadata","title":"Querying Ontology Metadata","text":"<p>Requests for ontology metadata can return information about more than one ontology, unlike other requests for ontology information. To get metadata about all ontologies:</p> <pre><code>HTTP GET to http://host/v2/ontologies/metadata\n</code></pre> <p>If you submit a project IRI in the <code>X-Knora-Accept-Project</code> header, only the ontologies for that project will be returned.</p> <p>The response is in the complex API v2 schema. Sample response:</p> <pre><code>{\n  \"@graph\": [\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2017-12-19T15:23:42.166Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The anything ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/0001\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0001/anything/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The something ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/0001\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0001/something/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The images demo ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/00FF\" \n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/00FF/images/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The BEOL ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0801/beol/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The Biblio ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0801/biblio/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The Newton-Project ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/yTerZGyxjZVqFMNNKXCDPF\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0801/newton/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The incunabula ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/0803\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0803/incunabula/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The dokubib ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/0804\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/0804/dokubib/v2\"\n    },\n    {\n      \"knora-api:lastModificationDate\": {\n        \"@value\": \"2022-03-23T07:14:17.445208Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n      },\n      \"rdfs:label\": \"The Anton Webern project ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/08AE\"\n      },\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://0.0.0.0:3333/ontology/08AE/webern/v2\"\n    },\n    {\n      \"rdfs:label\": \"The Knora admin ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://www.knora.org/ontology/knora-admin#SystemProject\"\n      },\n      \"knora-api:isBuiltIn\": true,\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://api.knora.org/ontology/knora-admin/v2\"\n    },\n    {\n      \"rdfs:label\": \"The knora-api ontology in the complex schema\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://www.knora.org/ontology/knora-admin#SystemProject\"\n      },\n      \"knora-api:isBuiltIn\": true,\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://api.knora.org/ontology/knora-api/v2\"\n    },\n    {\n      \"rdfs:label\": \"The salsah-gui ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://www.knora.org/ontology/knora-admin#SystemProject\"\n      },\n      \"knora-api:isBuiltIn\": true,\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://api.knora.org/ontology/salsah-gui/v2\"\n    },\n    {\n      \"rdfs:label\": \"The standoff ontology\",\n      \"knora-api:attachedToProject\": {\n        \"@id\": \"http://www.knora.org/ontology/knora-admin#SystemProject\"\n      },\n      \"knora-api:isBuiltIn\": true,\n      \"@type\": \"owl:Ontology\",\n      \"@id\": \"http://api.knora.org/ontology/standoff/v2\"\n    }\n  ],\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"xsd\": \"http://www.w3.org/2001/XMLSchema#\",\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"owl\": \"http://www.w3.org/2002/07/owl#\"\n  }\n}\n</code></pre> <p>To get metadata about the ontologies that belong to one or more particular projects:</p> <pre><code>HTTP GET to http://host/v2/ontologies/metadata/PROJECT_IRI[/PROJECT_IRI...]\n</code></pre> <p>The project IRIs must be URL-encoded.</p> <p>Example response for the <code>anything</code> test project (project IRI <code>http://rdfh.ch/projects/0001</code>):</p> <pre><code>{\n  \"@id\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:attachedToProject\" : {\n    \"@id\" : \"http://rdfh.ch/projects/0001\"\n  },\n  \"knora-api:lastModificationDate\": \"2017-12-19T15:23:42.166Z\",\n  \"rdfs:label\" : \"The anything ontology\",\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\"\n  }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/ontology-information/#querying-an-ontology","title":"Querying an Ontology","text":"<p>An ontology can be queried either by using an API route directly or by simply dereferencing the ontology IRI. The API route is as follows:</p> <pre><code>HTTP GET to http://host/v2/ontologies/allentities/ONTOLOGY_IRI\n</code></pre> <p>The ontology IRI must be URL-encoded, and may be in either the complex or the simple schema. The response will be in the same schema. For example, if the server is running on <code>0.0.0.0:3333</code>, you can request the <code>knora-api</code> ontology in the complex schema as follows:</p> <pre><code>HTTP GET to http://0.0.0.0:3333/v2/ontologies/allentities/http%3A%2F%2Fapi.knora.org%2Fontology%2Fknora-api%2Fv2\n</code></pre> <p>By default, this returns the ontology in JSON-LD; to request Turtle or RDF/XML, add an HTTP <code>Accept</code> header (see Response Formats).</p> <p>If the client dereferences a project-specific ontology IRI as a URL, the DSP-API server running on the hostname in the IRI will serve the ontology. For example, if the server is running on <code>0.0.0.0:3333</code>, the IRI <code>http://0.0.0.0:3333/ontology/00FF/images/simple/v2</code> can be dereferenced to request the <code>images</code> sample ontology in the simple schema.</p> <p>If the client dereferences a built-in Knora ontology, such as <code>http://api.knora.org/ontology/knora-api/simple/v2</code>, there must be a DSP-API server running at <code>api.knora.org</code> that can serve the ontology. The DaSCH intends to run such as server. For testing, you can configure your local <code>/etc/hosts</code> file to resolve <code>api.knora.org</code> as <code>localhost</code>.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#differences-between-internal-and-external-ontologies","title":"Differences Between Internal and External Ontologies","text":"<p>The external ontologies used by DSP-API v2 are different to the internal ontologies that are actually stored in the triplestore (see API Schema). In general, the external ontologies use simpler data structures, but they also provide additional information to make it easier for clients to use them. This is illustrated in the examples in the next sections.</p> <p>The internal predicates <code>knora-base:subjectClassConstraint</code> and <code>knora-base:objectClassConstraint</code> (see Constraints on the Types of Property Subjects and Objects) are represented as <code>knora-api:subjectType</code> and <code>knora-api:objectType</code> in external ontologies.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#json-ld-representation-of-an-ontology-in-the-simple-schema","title":"JSON-LD Representation of an Ontology in the Simple Schema","text":"<p>The simple schema is suitable for client applications that need to read but not update data in Knora. For example, here is the response for the <code>images</code> sample ontology in the simple schema, <code>http://0.0.0.0:3333/ontology/00FF/images/simple/v2</code> (simplified for clarity):</p> <pre><code>{\n  \"@id\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2\",\n  \"@type\" : \"owl:Ontology\",\n  \"rdfs:label\" : \"The images demo ontology\",\n  \"@graph\" : [ {\n    \"@id\" : \"images:bild\",\n    \"@type\" : \"owl:Class\",\n    \"knora-api:resourceIcon\" : \"bild.png\",\n    \"rdfs:comment\" : \"An image of the demo image collection\",\n    \"rdfs:label\" : \"Image\",\n    \"rdfs:subClassOf\" : [ {\n      \"@id\" : \"knora-api:StillImageRepresentation\"\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:creationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasIncomingLink\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStandoffLinkTo\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:minCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStillImageFile\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:lastModificationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"rdfs:label\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:description\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:erfassungsdatum\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:urheber\"\n      }\n    } ]\n  }, {\n    \"@id\" : \"images:description\",\n    \"@type\" : \"owl:DatatypeProperty\",\n    \"knora-api:objectType\" : {\n      \"@id\" : \"xsd:string\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"rdfs:label\" : \"Description\",\n    \"rdfs:subPropertyOf\" : [ {\n      \"@id\" : \"knora-api:hasValue\"\n    }, {\n      \"@id\" : \"http://purl.org/dc/terms/description\"\n    } ]\n  }, {\n    \"@id\" : \"images:erfassungsdatum\",\n    \"@type\" : \"owl:DatatypeProperty\",\n    \"knora-api:objectType\" : {\n      \"@id\" : \"knora-api:Date\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"rdfs:label\" : \"Date of acquisition\",\n    \"rdfs:subPropertyOf\" : [ {\n      \"@id\" : \"knora-api:hasValue\"\n    }, {\n      \"@id\" : \"http://purl.org/dc/terms/date\"\n    } ]\n  }, {\n    \"@id\" : \"images:firstname\",\n    \"@type\" : \"owl:DatatypeProperty\",\n    \"knora-api:objectType\" : {\n      \"@id\" : \"xsd:string\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:person\"\n    },\n    \"rdfs:comment\" : \"First name of a person\",\n    \"rdfs:label\" : \"First name\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasValue\"\n    }\n  }, {\n    \"@id\" : \"images:lastname\",\n    \"@type\" : \"owl:DatatypeProperty\",\n    \"knora-api:objectType\" : {\n      \"@id\" : \"xsd:string\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:person\"\n    },\n    \"rdfs:comment\" : \"Last name of a person\",\n    \"rdfs:label\" : \"Name\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasValue\"\n    }\n  }, {\n    \"@id\" : \"images:person\",\n    \"@type\" : \"owl:Class\",\n    \"knora-api:resourceIcon\" : \"person.png\",\n    \"rdfs:comment\" : \"Person\",\n    \"rdfs:label\" : \"Person\",\n    \"rdfs:subClassOf\" : [ {\n      \"@id\" : \"knora-api:Resource\"\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:creationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasIncomingLink\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStandoffLinkTo\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:lastModificationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"rdfs:label\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:lastname\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:firstname\"\n      }\n    } ]\n  }, {\n    \"@id\" : \"images:urheber\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:objectType\" : {\n      \"@id\" : \"images:person\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"rdfs:comment\" : \"An entity primarily responsible for making the resource. Examples of a Creator include a person, an organization, or a service. Typically, the name of a Creator should be used to indicate the entity.\",\n    \"rdfs:label\" : \"Creator\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasLinkTo\"\n    }\n  } ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"images\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/simple/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>The response format is an RDF graph. The top level object describes the ontology itself, providing its IRI (in the <code>@id</code> member) and its <code>rdfs:label</code>. The <code>@graph</code> member (see Named Graphs in the JSON-LD specification) contains an array of entities that belong to the ontology.</p> <p>In a class definition, cardinalities for properties of the class are represented as in OWL, using objects of type <code>owl:Restriction</code>. The supported cardinalities are the ones indicated in OWL Cardinalities.</p> <p>The class definitions include cardinalities that are directly defined on each class, as well as cardinalities inherited from base classes. For example, we can see cardinalities inherited from <code>knora-api:Resource</code>, such as <code>knora-api:hasStandoffLinkTo</code> and <code>http://schema.org/name</code> (which represents <code>rdfs:label</code>).</p> <p>In the simple schema, Knora value properties can be datatype properties. The <code>knora-base:objectType</code> of a Knora value property such as <code>images:description</code> is a literal datatype, in this case <code>xsd:string</code>. Moreover, <code>images:description</code> is a subproperty of the standard property <code>dcterms:description</code>, whose object can be a literal value. A client that understands <code>rdfs:subPropertyOf</code>, and is familiar with <code>dcterms:description</code>, can then work with <code>images:description</code> on the basis of its knowledge about <code>dcterms:description</code>.</p> <p>By default, values for <code>rdfs:label</code> and <code>rdfs:comment</code> are returned only in the user's preferred language, or in the system default language. To obtain these values in all available languages, add the URL parameter <code>?allLanguages=true</code>. For example, with this parameter, the definition of <code>images:description</code> becomes:</p> <pre><code>{\n  \"@id\" : \"images:description\",\n  \"@type\" : \"owl:DatatypeProperty\",\n  \"knora-api:objectType\" : {\n    \"@id\" : \"xsd:string\"\n  },\n  \"knora-api:subjectType\" : {\n    \"@id\" : \"images:bild\"\n  },\n  \"rdfs:label\" : [ {\n    \"@language\" : \"en\",\n    \"@value\" : \"Description\"\n  }, {\n    \"@language\" : \"de\",\n    \"@value\" : \"Beschreibung\"\n  }, {\n    \"@language\" : \"fr\",\n    \"@value\" : \"Description\"\n  }, {\n    \"@language\" : \"it\",\n    \"@value\" : \"Descrizione\"\n  } ],\n  \"rdfs:subPropertyOf\" : [ {\n    \"@id\" : \"knora-api:hasValue\"\n  }, {\n    \"@id\" : \"http://purl.org/dc/terms/description\"\n  } ]\n}\n</code></pre> <p>To find out more about the <code>knora-api</code> entities used in the response, the client can request the <code>knora-api</code> ontology in the simple schema: <code>http://api.knora.org/ontology/knora-api/simple/v2</code>. For example, <code>images:erfassungsdatum</code> has a <code>knora-api:objectType</code> of <code>knora-api:Date</code>, which is a subtype of <code>xsd:string</code> with a Knora-specific, human-readable format. In the <code>knora-api</code> simple ontology, there is a definition of this type:</p> <pre><code>{\n  \"@id\" : \"http://api.knora.org/ontology/knora-api/simple/v2\",\n  \"@type\" : \"owl:Ontology\",\n  \"rdfs:label\" : \"The knora-api ontology in the simple schema\",\n  \"@graph\" : [ {\n    \"@id\" : \"knora-api:Date\",\n    \"@type\" : \"rdfs:Datatype\",\n    \"rdfs:comment\" : \"Represents a date as a period with different possible precisions.\",\n    \"rdfs:label\" : \"Date literal\",\n    \"rdfs:subClassOf\" : {\n      \"@type\" : \"rdfs:Datatype\",\n      \"owl:onDatatype\" : {\n        \"@id\" : \"xsd:string\"\n      },\n      \"owl:withRestrictions\" : {\n        \"xsd:pattern\" : \"(GREGORIAN|JULIAN|ISLAMIC):\\\\d{1,4}(-\\\\d{1,2}(-\\\\d{1,2})?)?( BC| AD| BCE| CE)?(:\\\\d{1,4}(-\\\\d{1,2}(-\\\\d{1,2})?)?( BC| AD| BCE| CE)?)?\"\n      }\n    }\n  } ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/simple/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/ontology-information/#json-ld-representation-of-an-ontology-in-the-complex-schema","title":"JSON-LD Representation of an Ontology in the Complex Schema","text":"<p>The complex schema is suitable for client applications that need to update data in Knora. For example, here is the response for the <code>images</code> sample ontology in the complex schema, <code>http://0.0.0.0:3333/ontology/00FF/images/v2</code> (simplified for clarity):</p> <pre><code>{\n  \"@id\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:attachedToProject\" : {\n    \"@id\" : \"http://rdfh.ch/projects/00FF\"\n  },\n  \"rdfs:label\" : \"The images demo ontology\",\n  \"@graph\" : [ {\n    \"@id\" : \"images:bild\",\n    \"@type\" : \"owl:Class\",\n    \"knora-api:canBeInstantiated\" : true,\n    \"knora-api:isResourceClass\" : true,\n    \"knora-api:resourceIcon\" : \"bild.png\",\n    \"rdfs:comment\" : \"An image of the demo image collection\",\n    \"rdfs:label\" : \"Image\",\n    \"rdfs:subClassOf\" : [ {\n      \"@id\" : \"knora-api:StillImageRepresentation\"\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:attachedToProject\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:attachedToUser\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:creationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasIncomingLink\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasPermissions\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStandoffLinkTo\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStandoffLinkToValue\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStillImageFileValue\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:lastModificationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"rdfs:label\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"salsah-gui:guiOrder\" : 3,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:description\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"salsah-gui:guiOrder\" : 8,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:erfassungsdatum\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"salsah-gui:guiOrder\" : 12,\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:urheber\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"salsah-gui:guiOrder\" : 12,\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:urheberValue\"\n      }\n    } ]\n  }, {\n    \"@id\" : \"images:description\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:isEditable\" : true,\n    \"knora-api:isResourceProperty\" : true,\n    \"knora-api:objectType\" : {\n      \"@id\" : \"knora-api:TextValue\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"salsah-gui:guiAttribute\" : [ \"rows=10\", \"width=95%\", \"wrap=soft\" ],\n    \"salsah-gui:guiElement\" : {\n      \"@id\" : \"salsah-gui:Textarea\"\n    },\n    \"rdfs:label\" : \"Description\",\n    \"rdfs:subPropertyOf\" : [ {\n      \"@id\" : \"knora-api:hasValue\"\n    }, {\n      \"@id\" : \"http://purl.org/dc/terms/description\"\n    } ]\n  }, {\n    \"@id\" : \"images:erfassungsdatum\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:isEditable\" : true,\n    \"knora-api:isResourceProperty\" : true,\n    \"knora-api:objectType\" : {\n      \"@id\" : \"knora-api:DateValue\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"salsah-gui:guiElement\" : {\n      \"@id\" : \"salsah-gui:Date\"\n    },\n    \"rdfs:label\" : \"Date of acquisition\",\n    \"rdfs:subPropertyOf\" : [ {\n      \"@id\" : \"knora-api:hasValue\"\n    }, {\n      \"@id\" : \"http://purl.org/dc/terms/date\"\n    } ]\n  }, {\n    \"@id\" : \"images:firstname\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:isEditable\" : true,\n    \"knora-api:isResourceProperty\" : true,\n    \"knora-api:objectType\" : {\n      \"@id\" : \"knora-api:TextValue\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:person\"\n    },\n    \"salsah-gui:guiAttribute\" : [ \"maxlength=32\", \"size=32\" ],\n    \"salsah-gui:guiElement\" : {\n      \"@id\" : \"salsah-gui:SimpleText\"\n    },\n    \"rdfs:comment\" : \"First name of a person\",\n    \"rdfs:label\" : \"First name\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasValue\"\n    }\n  }, {\n    \"@id\" : \"images:lastname\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:isEditable\" : true,\n    \"knora-api:isResourceProperty\" : true,\n    \"knora-api:objectType\" : {\n      \"@id\" : \"knora-api:TextValue\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:person\"\n    },\n    \"salsah-gui:guiAttribute\" : [ \"maxlength=32\", \"size=32\" ],\n    \"salsah-gui:guiElement\" : {\n      \"@id\" : \"salsah-gui:SimpleText\"\n    },\n    \"rdfs:comment\" : \"Last name of a person\",\n    \"rdfs:label\" : \"Name\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasValue\"\n    }\n  }, {\n    \"@id\" : \"images:person\",\n    \"@type\" : \"owl:Class\",\n    \"knora-api:canBeInstantiated\" : true,\n    \"knora-api:isResourceClass\" : true,\n    \"knora-api:resourceIcon\" : \"person.png\",\n    \"rdfs:comment\" : \"Person\",\n    \"rdfs:label\" : \"Person\",\n    \"rdfs:subClassOf\" : [ {\n      \"@id\" : \"knora-api:Resource\"\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:attachedToProject\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:attachedToUser\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:creationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasIncomingLink\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasPermissions\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStandoffLinkTo\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:minCardinality\" : 0,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:hasStandoffLinkToValue\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:maxCardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"knora-api:lastModificationDate\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"knora-api:isInherited\" : true,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"rdfs:label\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"salsah-gui:guiOrder\" : 0,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:lastname\"\n      }\n    }, {\n      \"@type\" : \"owl:Restriction\",\n      \"salsah-gui:guiOrder\" : 1,\n      \"owl:cardinality\" : 1,\n      \"owl:onProperty\" : {\n        \"@id\" : \"images:firstname\"\n      }\n    } ]\n  }, {\n    \"@id\" : \"images:urheber\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:isEditable\" : true,\n    \"knora-api:isLinkProperty\" : true,\n    \"knora-api:isResourceProperty\" : true,\n    \"knora-api:objectType\" : {\n      \"@id\" : \"images:person\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"salsah-gui:guiAttribute\" : \"numprops=2\",\n    \"salsah-gui:guiElement\" : {\n      \"@id\" : \"salsah-gui:Searchbox\"\n    },\n    \"rdfs:comment\" : \"An entity primarily responsible for making the resource. Examples of a Creator include a person, an organization, or a service. Typically, the name of a Creator should be used to indicate the entity.\",\n    \"rdfs:label\" : \"Creator\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasLinkTo\"\n    }\n  }, {\n    \"@id\" : \"images:urheberValue\",\n    \"@type\" : \"owl:ObjectProperty\",\n    \"knora-api:isEditable\" : true,\n    \"knora-api:isLinkValueProperty\" : true,\n    \"knora-api:isResourceProperty\" : true,\n    \"knora-api:objectType\" : {\n      \"@id\" : \"knora-api:LinkValue\"\n    },\n    \"knora-api:subjectType\" : {\n      \"@id\" : \"images:bild\"\n    },\n    \"salsah-gui:guiAttribute\" : \"numprops=2\",\n    \"salsah-gui:guiElement\" : {\n      \"@id\" : \"salsah-gui:Searchbox\"\n    },\n    \"rdfs:comment\" : \"An entity primarily responsible for making the resource. Examples of a Creator include a person, an organization, or a service. Typically, the name of a Creator should be used to indicate the entity.\",\n    \"rdfs:label\" : \"Creator\",\n    \"rdfs:subPropertyOf\" : {\n      \"@id\" : \"knora-api:hasLinkToValue\"\n    }\n  } ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"images\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"salsah-gui\" : \"http://api.knora.org/ontology/salsah-gui/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>In the complex schema, all Knora value properties are object properties, whose objects are IRIs, each of which uniquely identifies a value that contains metadata and can potentially be edited. The <code>knora-base:objectType</code> of a Knora value property such as <code>images:description</code> is a Knora value class, in this case <code>knora-api:TextValue</code>. Similarly, <code>images:erfassungsdatum</code> has a <code>knora-api:objectType</code> of <code>knora-api:DateValue</code>, which has a more complex structure than the <code>knora-api:Date</code> datatype shown in the previous section. A client can find out more about these value classes by requesting the <code>knora-api</code> ontology in the complex schema, <code>http://api.knora.org/ontology/knora-api/v2</code>.</p> <p>Moreover, additional information is provided in the complex schema, to help clients that wish to create or update resources and values. A Knora resource class that can be instantiated is identified with the boolean properties <code>knora-api:isResourceClass</code> and <code>knora-api:canBeInstantiated</code>, to distinguish it from built-in abstract classes. Knora resource properties whose values can be edited by clients are identified with <code>knora-api:isResourceProperty</code> and <code>knora-api:isEditable</code>, to distinguish them from properties whose values are maintained automatically by Knora. Link value properties are shown along with link properties, because a client that updates links will need the IRIs of their link values. The predicate <code>salsah-gui:guiOrder</code> tells a GUI client in what order to display the properties of a class, and the predicates <code>salsah-gui:guiElement</code> and <code>salsah-gui:guiAttribute</code> specify how to configure a GUI element for editing the value of a property. For more information on the <code>salsah-gui</code> ontology, see The SALSAH GUI Ontology.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#querying-class-definition","title":"Querying class definition","text":"<p>To get the definition of a class, use the following route:</p> <pre><code>HTTP GET to http://host/v2/ontologies/classes/CLASS_IRI\n</code></pre> <p>Sample response:</p> <pre><code>{\n    \"knora-api:lastModificationDate\": {\n        \"@value\": \"2023-01-09T15:39:48.548298041Z\",\n        \"@type\": \"xsd:dateTimeStamp\"\n    },\n    \"rdfs:label\": \"The anything ontology\",\n    \"@graph\": [\n        {\n            \"knora-api:isResourceClass\": true,\n            \"rdfs:label\": \"Institution\",\n            \"knora-api:canBeInstantiated\": true,\n            \"rdfs:subClassOf\": [\n                {\n                    \"@id\": \"knora-api:Resource\"\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:arkUrl\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:attachedToProject\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:attachedToUser\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:creationDate\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:deleteComment\"\n                    },\n                    \"owl:maxCardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:deleteDate\"\n                    },\n                    \"owl:maxCardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:deletedBy\"\n                    },\n                    \"owl:maxCardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:hasIncomingLinkValue\"\n                    },\n                    \"owl:minCardinality\": 0,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:hasPermissions\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:hasStandoffLinkTo\"\n                    },\n                    \"owl:minCardinality\": 0,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:hasStandoffLinkToValue\"\n                    },\n                    \"owl:minCardinality\": 0,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:isDeleted\"\n                    },\n                    \"owl:maxCardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:lastModificationDate\"\n                    },\n                    \"owl:maxCardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:userHasPermission\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:versionArkUrl\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"knora-api:versionDate\"\n                    },\n                    \"owl:maxCardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"rdfs:label\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"knora-api:isInherited\": true\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"anything:hasName\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"salsah-gui:guiOrder\": 1\n                },\n                {\n                    \"@type\": \"owl:Restriction\",\n                    \"owl:onProperty\": {\n                        \"@id\": \"anything:hasLocation\"\n                    },\n                    \"owl:cardinality\": 1,\n                    \"salsah-gui:guiOrder\": 2\n                }\n            ],\n            \"rdfs:comment\": \"some comment\",\n            \"@type\": \"owl:Class\",\n            \"@id\": \"anything:Institution\"\n        }\n    ],\n    \"knora-api:attachedToProject\": {\n        \"@id\": \"http://rdfh.ch/projects/0001\"\n    },\n    \"@type\": \"owl:Ontology\",\n    \"@id\": \"http://0.0.0.0:3333/ontology/0001/anything/v2\",\n    \"@context\": {\n        \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n        \"anything\": \"http://0.0.0.0:3333/ontology/0001/anything/v2#\",\n        \"owl\": \"http://www.w3.org/2002/07/owl#\",\n        \"salsah-gui\": \"http://api.knora.org/ontology/salsah-gui/v2#\",\n        \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n        \"xsd\": \"http://www.w3.org/2001/XMLSchema#\"\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/ontology-information/#ontology-updates","title":"Ontology Updates","text":"<p>The ontology update API must ensure that the ontologies it creates are valid and consistent, and that existing data is not invalidated by a change to an ontology. To make this easier to enforce, the ontology update API allows only one entity to be created or modified at a time. It is not possible to submit an entire ontology all at once. Each update request is a JSON-LD document providing only the information that is relevant to the update.</p> <p>Moreover, the API enforces the following rules:</p> <ul> <li>An entity (i.e. a class or property) cannot be referred to until it has been created.</li> <li>An entity cannot be modified or deleted if it is used in data,   except for changes to its <code>rdfs:label</code> or <code>rdfs:comment</code>.</li> <li>An entity cannot be modified if another entity refers to it, with   one exception: a <code>knora-api:subjectType</code> or <code>knora-api:objectType</code>   that refers to a class will not prevent the class's cardinalities   from being modified.</li> </ul> <p>Because of these rules, some operations have to be done in a specific order:</p> <ul> <li>Properties have to be defined before they can be used in the   cardinalities of a class, but a property's <code>knora-api:subjectType</code>   cannot refer to a class that does not yet exist. The recommended   approach is to first create a class with no cardinalities, then   create the properties that it needs, then add cardinalities for   those properties to the class.</li> <li>To delete a class along with its properties, the client must first   remove the cardinalities from the class, then delete the property   definitions, then delete the class definition.</li> </ul> <p>When changing an existing ontology, the client must always supply the ontology's <code>knora-api:lastModificationDate</code>, which is returned in the response to each update or when querying the ontology. If user A attempts to update an ontology, but user B has already updated it since the last time user A received the ontology's <code>knora-api:lastModificationDate</code>, user A's update will be rejected with an HTTP 409 Conflict error. This means that it is possible for two different users to work concurrently on the same ontology, but this is discouraged since it is likely to lead to confusion.</p> <p>An ontology can be created or updated only by a system administrator, or by a project administrator in the ontology's project.</p> <p>Ontology updates always use the complex schema.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#creating-a-new-ontology","title":"Creating a New Ontology","text":"<p>An ontology is always created within a particular project.</p> <pre><code>HTTP POST to http://host/v2/ontologies\n</code></pre> <pre><code>{\n  \"knora-api:ontologyName\" : \"ONTOLOGY_NAME\",\n  \"knora-api:attachedToProject\" : {\n    \"@id\" : \"PROJECT_IRI\"\n  },\n  \"rdfs:label\" : \"ONTOLOGY_NAME\",\n  \"@context\" : {\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\n</code></pre> <p>The ontology name must follow the rules given in Knora IRIs.</p> <p>The ontology metadata can have an optional comment given in the request  body as:</p> <pre><code>\"rdfs:comment\": \"some comment\",\n</code></pre> <p>If the ontology is to be shared by multiple projects, it must be created in the default shared ontologies project, <code>http://www.knora.org/ontology/knora-base#DefaultSharedOntologiesProject</code>, and the request must have this additional boolean property:</p> <pre><code>\"knora-api:isShared\" : true\n</code></pre> <p>See Shared Ontologies for details about shared ontologies.</p> <p>A successful response will be a JSON-LD document providing only the ontology's metadata, which includes the ontology's IRI. When the client makes further requests to create entities (classes and properties) in the ontology, it must construct entity IRIs by concatenating the ontology IRI, a <code>#</code> character, and the entity name. An entity name must be a valid XML NCName.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-an-ontologys-metadata","title":"Changing an Ontology's Metadata","text":"<p>One can modify an ontology's metadata by updating its <code>rdfs:label</code> or <code>rdfs:comment</code>  or both. The example below shows the request for changing the label of an ontology.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/metadata\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"rdfs:label\" : \"NEW_ONTOLOGY_LABEL\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\n</code></pre> <p>Similarly, a user can change an ontology's existing comment or add one by specifying  the new comment in the request body:</p> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"rdfs:comment\" : \"NEW_ONTOLOGY_COMMENT\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\n</code></pre> <p>The request body can also contain a new label and a new comment for the ontology's metadata.  A successful response will be a JSON-LD document providing only the ontology's metadata.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#deleting-an-ontologys-comment","title":"Deleting an Ontology's comment","text":"<pre><code>HTTP DELETE to http://host/v2/ontologies/comment/ONTOLOGY_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\n</code></pre> <p>The ontology IRI and the ontology's last modification date must be URL-encoded.</p> <p>A successful response will be a JSON-LD document containing the ontology's updated metadata.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#deleting-an-ontology","title":"Deleting an Ontology","text":"<p>An ontology can be deleted only if it is not used in data.</p> <pre><code>HTTP DELETE to http://host/v2/ontologies/ONTOLOGY_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\n</code></pre> <p>The ontology IRI and the ontology's last modification date must be URL-encoded.</p> <p>A successful response will be a JSON-LD document containing a confirmation message.</p> <p>To check whether an ontology can be deleted:</p> <pre><code>HTTP GET to http://host/v2/ontologies/candeleteontology/ONTOLOGY_IRI\n</code></pre> <p>The response will look like this:</p> <pre><code>{\n    \"knora-api:canDo\": false,\n    \"@context\": {\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/ontology-information/#creating-a-class-without-cardinalities","title":"Creating a Class Without Cardinalities","text":"<pre><code>HTTP POST to http://host/v2/ontologies/classes\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"CLASS_IRI\",\n      \"@type\" : \"owl:Class\",\n      \"rdfs:label\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"LABEL\"\n      },\n      \"rdfs:comment\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"COMMENT\"\n      },\n      \"rdfs:subClassOf\" : {\n        \"@id\" : \"BASE_CLASS_IRI\"\n      }\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Values for <code>rdfs:label</code> must be submitted in at least one language, either as an object or as an array of objects.</p> <p>Values for <code>rdfs:comment</code> are optional, but if they are provided, they must include a language code.</p> <p>At least one base class must be provided, which can be <code>knora-api:Resource</code> or any of its subclasses.</p> <p>A successful response will be a JSON-LD document providing the new class definition (but not any of the other entities in the ontology).</p>"},{"location":"03-endpoints/api-v2/ontology-information/#creating-a-class-with-cardinalities","title":"Creating a Class With Cardinalities","text":"<p>This can work if the new class will have cardinalities for properties that have no <code>knora-api:subjectType</code>, or if the new class will be a subclass of their <code>knora-api:subjectType</code>.</p> <pre><code>HTTP POST to http://host/v2/ontologies/classes\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"CLASS_IRI\",\n      \"@type\" : \"owl:Class\",\n      \"rdfs:label\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"LABEL\"\n      },\n      \"rdfs:comment\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"COMMENT\"\n      },\n      \"rdfs:subClassOf\" : [ {\n        \"@id\" : \"BASE_CLASS_IRI\"\n      }, {\n        \"@type\": \"owl:Restriction\",\n        \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n        \"owl:onProperty\": {\n          \"@id\" : \"PROPERTY_IRI\"\n        }\n      } ]\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p><code>OWL_CARDINALITY_PREDICATE</code> and <code>OWL_CARDINALITY_VALUE</code> must correspond to the supported combinations given in OWL Cardinalities. (The placeholder <code>OWL_CARDINALITY_VALUE</code> is shown here in quotes, but it should be an unquoted integer.)</p> <p>Values for <code>rdfs:label</code> must be submitted in at least one language, either as an object or as an array of objects.</p> <p>Values for <code>rdfs:comment</code> are optional, but if they are provided, they must include a language code.</p> <p>At least one base class must be provided.</p> <p>When a cardinality on a link property is submitted, an identical cardinality on the corresponding link value property is automatically added (see Links Between Resources).</p> <p>A successful response will be a JSON-LD document providing the new class definition (but not any of the other entities in the ontology).</p>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-the-labels-of-a-class","title":"Changing the Labels of a Class","text":"<p>This operation is permitted even if the class is used in data.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/classes\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"CLASS_IRI\",\n      \"@type\" : \"owl:Class\",\n      \"rdfs:label\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"LABEL\"\n      }\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Values for <code>rdfs:label</code> must be submitted in at least one language, either as an object or as an array of objects. The submitted labels will replace the existing ones.</p> <p>To get the current labels use the class definition.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-the-comments-of-a-class","title":"Changing the Comments of a Class","text":"<p>This operation is permitted even if the class is used in data.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/classes\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"CLASS_IRI\",\n      \"@type\" : \"owl:Class\",\n      \"rdfs:comment\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"COMMENT\"\n      }\n    }\n  ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Values for <code>rdfs:comment</code> must be submitted in at least one language, either as an object or as an array of objects. The submitted comments will replace the existing ones.</p> <p>To get the current comments use the class definition.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#deleting-the-comments-of-a-class","title":"Deleting the Comments of a Class","text":"<p>This operation is permitted even if the class is used in data.</p> <pre><code>HTTP DELETE to http://host/v2/ontologies/classes/comment/CLASS_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\n</code></pre> <p>The class IRI and the ontology's last modification date must be URL-encoded.</p> <p>All values i.e. all languages for <code>rdfs:comment</code> are deleted.</p> <p>A successful response will be a JSON-LD document providing the class definition.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#creating-a-property","title":"Creating a Property","text":"<pre><code>HTTP POST to http://host/v2/ontologies/properties\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"PROPERTY_IRI\",\n      \"@type\" : \"owl:ObjectProperty\",\n      \"knora-api:subjectType\" : {\n        \"@id\" : \"SUBJECT_TYPE\"\n      },\n      \"knora-api:objectType\" : {\n        \"@id\" : \"OBJECT_TYPE\"\n      },\n      \"rdfs:label\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"LABEL\"\n      },\n      \"rdfs:comment\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"COMMENT\"\n      },\n      \"rdfs:subPropertyOf\" : {\n        \"@id\" : \"BASE_PROPERTY_IRI\"\n      },\n      \"salsah-gui:guiElement\" : {\n        \"@id\" : \"GUI_ELEMENT_IRI\"\n      },\n      \"salsah-gui:guiAttribute\" : [ \"GUI_ATTRIBUTE\" ]\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"salsah-gui\" : \"http://api.knora.org/ontology/salsah-gui/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Values for <code>rdfs:label</code> must be submitted in at least one language, either as an object or as an array of objects.</p> <p>Values for <code>rdfs:comment</code> are optional, but if they are provided, they must include a language code.</p> <p>At least one base property must be provided, which can be <code>knora-api:hasValue</code>, <code>knora-api:hasLinkTo</code>, or any of their subproperties, with the exception of file properties (subproperties of <code>knora-api:hasFileValue</code>) and link value properties (subproperties of <code>knora-api:hasLinkToValue</code>).</p> <p>If the property is a link property, the corresponding link value property (see Links Between Resources) will automatically be created.</p> <p>The property definition must specify its <code>knora-api:objectType</code>. If the new property is a subproperty of <code>knora-api:hasValue</code>, its <code>knora-api:objectType</code> must be one of the built-in subclasses of <code>knora-api:Value</code>, which are defined in the <code>knora-api</code> ontology in the complex schema. If the new property is a subproperty of <code>knora-base:hasLinkTo</code>, its <code>knora-api:objectType</code> must be a subclass of <code>knora-api:Resource</code>.</p> <p>To improve consistency checking, it is recommended, but not required, to provide <code>knora-api:subjectType</code>, which must be a subclass of <code>knora-api:Resource</code>.</p> <p>The predicates <code>salsah-gui:guiElement</code> and <code>salsah-gui:guiAttribute</code> are optional. If provided, the object of <code>guiElement</code> must be one of the OWL named individuals defined in The SALSAH GUI Ontology. Some GUI elements take required or optional attributes, which are provided as objects of <code>salsah-gui:guiAttribute</code>; see The SALSAH GUI Ontology for details.</p> <p>A successful response will be a JSON-LD document providing the new property definition (but not any of the other entities in the ontology).</p>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-the-labels-of-a-property","title":"Changing the Labels of a Property","text":"<p>This operation is permitted even if the property is used in data.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/properties\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"PROPERTY_IRI\",\n      \"@type\" : \"owl:ObjectProperty\",\n      \"rdfs:label\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"LABEL\"\n      }\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Values for <code>rdfs:label</code> must be submitted in at least one language, either as an object or as an array of objects.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-the-comments-of-a-property","title":"Changing the Comments of a Property","text":"<p>This operation is permitted even if the property is used in data.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/properties\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [\n    {\n      \"@id\" : \"PROPERTY_IRI\",\n      \"@type\" : \"owl:ObjectProperty\",\n      \"rdfs:comment\" : {\n        \"@language\" : \"LANGUAGE_CODE\",\n        \"@value\" : \"COMMENT\"\n      }\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Values for <code>rdfs:comment</code> must be submitted in at least one language, either as an object or as an array of objects.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#deleting-the-comments-of-a-property","title":"Deleting the Comments of a Property","text":"<p>This operation is permitted even if the property is used in data.</p> <pre><code>HTTP DELETE to http://host/v2/ontologies/properties/comment/PROPERTY_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\n</code></pre> <p>The property IRI and the ontology's last modification date must be URL-encoded.</p> <p>All values i.e. all languages for <code>rdfs:comment</code> are deleted.</p> <p>If the property is a link property, the <code>rdfs:comment</code> of its corresponding link value property will automatically be deleted.</p> <p>A successful response will be a JSON-LD document providing the property definition.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-the-gui-element-and-gui-attributes-of-a-property","title":"Changing the GUI Element and GUI Attributes of a Property","text":"<p>This operation is permitted even if the property is used in data.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/properties/guielement\n</code></pre> <pre><code>{\n  \"@id\": \"ONTOLOGY_IRI\",\n  \"@type\": \"owl:Ontology\",\n  \"knora-api:lastModificationDate\": {\n    \"@type\": \"xsd:dateTimeStamp\",\n    \"@value\": \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\": [\n    {\n      \"@id\": \"PROPERTY_IRI\",\n      \"@type\": \"owl:ObjectProperty\",\n      \"salsah-gui:guiElement\": {\n        \"@id\": \"salsah-gui:Textarea\"\n      },\n      \"salsah-gui:guiAttribute\": [\n        \"cols=80\",\n        \"rows=24\"\n      ]\n    }\n  ],\n  \"@context\": {\n    \"rdf\": \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"salsah-gui\": \"http://api.knora.org/ontology/salsah-gui/v2#\",\n    \"owl\": \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\": \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>To remove the values of <code>salsah-gui:guiElement</code> and <code>salsah-gui:guiAttribute</code> from the property definition, submit the request without those predicates.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#adding-cardinalities-to-a-class","title":"Adding Cardinalities to a Class","text":"<p>If the class (or any of its sub-classes) is used in data,  it is not allowed to add cardinalities <code>owl:minCardinality</code> greater than 0 or <code>owl:cardinality 1</code> to the class.</p> <pre><code>HTTP POST to http://host/v2/ontologies/cardinalities\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [ \n    {\n      \"@id\" : \"CLASS_IRI\",\n      \"@type\" : \"owl:Class\",\n      \"rdfs:subClassOf\" : {\n        \"@type\": \"owl:Restriction\",\n        \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n        \"owl:onProperty\": {\n          \"@id\" : \"PROPERTY_IRI\"\n        }\n      }\n    }\n  ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>At least one cardinality must be submitted.</p> <p><code>OWL_CARDINALITY_PREDICATE</code> and <code>OWL_CARDINALITY_VALUE</code> must correspond to the supported combinations given in OWL Cardinalities. (The placeholder <code>OWL_CARDINALITY_VALUE</code> is shown here in quotes, but it should be an unquoted integer.)</p> <p>When a cardinality on a link property is submitted, an identical cardinality on the corresponding link value property is automatically added (see Links Between Resources).</p> <p>A successful response will be a JSON-LD document providing the new class definition (but not any of the other entities in the ontology).</p>"},{"location":"03-endpoints/api-v2/ontology-information/#replacing-the-cardinalities-of-a-class","title":"Replacing the Cardinalities of a Class","text":"<p>It is possible to replace all cardinalities on properties used by a class. If it succeeds the request will effectively replace all direct cardinalities of the class as specified. That is, it removes all the cardinalities from the class and replaces them with the submitted cardinalities.  Meaning that, if no cardinalities are submitted (i.e. the request contains no <code>rdfs:subClassOf</code>),  the class is left with no cardinalities.</p> <p>The request will fail if any of the \"Pre-Update Checks\" fails.  A partial update of the ontology will not be performed.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#pre-update-checks","title":"Pre-Update Checks","text":"<ul> <li>Ontology Check<ul> <li>Any given cardinality on a property must be included in any of the existing cardinalities    for the same property of the super-classes.</li> <li>Any given cardinality on a property must include the effective cardinalities    for the same property of all subclasses,    taking into account the respective inherited cardinalities from the class hierarchy of the subclasses.</li> </ul> </li> <li>Consistency Check with existing data<ul> <li>Given that instances of the class or any of its subclasses exist,   then these instances are checked if they conform to the given cardinality.</li> </ul> </li> </ul> <p>Subproperty handling for cardinality pre-update checks</p> <p>The Pre-Update check does not take into account any <code>subproperty</code> relations between the properties.  Every cardinality is checked against only the given property and not its subproperties,  neither in the ontology nor the consistency check with existing data.  This means that currently it is necessary to maintain the cardinalities on all subproperties of a property  in sync with the cardinalities on the superproperty.</p> <pre><code>HTTP PUT to http://host/v2/ontologies/cardinalities\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [ {\n    \"@id\" : \"CLASS_IRI\",\n    \"@type\" : \"owl:Class\",\n    \"rdfs:subClassOf\" : {\n      \"@type\": \"owl:Restriction\",\n      \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n      \"owl:onProperty\": {\n        \"@id\" : \"PROPERTY_IRI\"\n      }\n    }\n  } ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p><code>OWL_CARDINALITY_PREDICATE</code> and <code>OWL_CARDINALITY_VALUE</code> must correspond to the supported combinations given in OWL Cardinalities. (The placeholder <code>OWL_CARDINALITY_VALUE</code> is shown here in quotes, but it should be an unquoted integer.)</p> <p>When a cardinality on a link property is submitted, an identical cardinality on the corresponding link value property is automatically added (see Links Between Resources).</p> <p>A successful response will be a JSON-LD document providing the new class definition (but not any of the other entities in the ontology). If any of the \"Pre-Update Checks\" fail the endpoint will respond with a 400 Bad Request containing the reasons why the update failed.</p> <p>The \"Pre-Update Checks\" are available on a dedicated endpoint. For a check whether a particular cardinality can be set on a class/property combination, use the following request:</p> <pre><code>HTTP GET to http://host/v2/ontologies/canreplacecardinalities/CLASS_IRI?propertyIri=PROPERTY_IRI&amp;newCardinality=[0-1|1|1-n|0-n]\n</code></pre> <p>The response will look like this:</p> <p>Failure:</p> <pre><code>{\n  \"knora-api:canDo\": false,\n  \"knora-api:cannotDoReason\": \"An explanation, understandable to humans, why the update cannot be carried out.\",\n  \"knora-api:cannotDoContext\": {\n    \"knora-api:canSetCardinalityCheckFailure\": [\n      {\n        \"knora-api:canSetCardinalityOntologySuperClassCheckFailed\": [\n          {\n            \"@id\": \"http://0.0.0.0:3333/ontology/0801/biblio/v2#somePublicationInstance\"\n          },\n          {\n            \"@id\": \"http://0.0.0.0:3333/ontology/0801/biblio/v2#someArticleInstance\"\n          }\n        ]\n      },\n      {\n        \"knora-api:canSetCardinalityOntologySubclassCheckFailed\": {\n          \"@id\": \"http://0.0.0.0:3333/ontology/0801/biblio/v2#someJournalArticleInstance\"\n        }\n      }\n    ]\n  },\n  \"@context\": {\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\n</code></pre> <p>Success:</p> <pre><code>{\n    \"knora-api:canDo\": true,\n    \"@context\": {\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    } \n}\n</code></pre> <p>Note</p> <p>The following check is still available but deprecated - use the more detailed check above. This request is only checking if the class is in use. </p> <p>To check whether all class's cardinalities can be replaced:</p> <pre><code>HTTP GET to http://host/v2/ontologies/canreplacecardinalities/CLASS_IRI\n</code></pre> <p>The response will look like this:</p> <pre><code>{\n    \"knora-api:canDo\": false,\n    \"@context\": {\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\n</code></pre> <p>The <code>ontologies/canreplacecardinalities/CLASS_IRI</code> request is only checking if the class is in use. </p>"},{"location":"03-endpoints/api-v2/ontology-information/#delete-a-single-cardinality-from-a-class","title":"Delete a single cardinality from a class","text":"<p>If a class is used in data, it is only allowed to delete a cardinality, if the property a cardinality refers to, is not used inside the data. Also, the property isn't allowed to be used inside the data in any subclasses of this class.</p> <pre><code>HTTP PATCH to http://host/v2/ontologies/cardinalities\n</code></pre> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [ {\n    \"@id\" : \"CLASS_IRI\",\n    \"@type\" : \"owl:Class\",\n    \"rdfs:subClassOf\" : {\n      \"@type\": \"owl:Restriction\",\n      \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n      \"owl:onProperty\": {\n        \"@id\" : \"PROPERTY_IRI\"\n      }\n    }\n  } ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p><code>OWL_CARDINALITY_PREDICATE</code> and <code>OWL_CARDINALITY_VALUE</code> must correspond to the supported combinations given in OWL Cardinalities. (The placeholder <code>OWL_CARDINALITY_VALUE</code> is shown here in quotes, but it should be an unquoted integer.)</p> <p>When a cardinality on a link property is submitted, an identical cardinality on the corresponding link value property is automatically added (see Links Between Resources).</p> <p>A successful response will be a JSON-LD document providing the new class definition (but not any of the other entities in the ontology).</p> <p>To check whether a class's cardinality can be deleted:</p> <pre><code>HTTP POST to http://host/v2/ontologies/candeletecardinalities\n</code></pre> <p>The response will look like this:</p> <pre><code>{\n    \"knora-api:canDo\": false,\n    \"@context\": {\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/ontology-information/#changing-the-gui-order-of-cardinalities","title":"Changing the GUI Order of Cardinalities","text":"<p>To change the GUI order of one or more cardinalities in a class:</p> <pre><code>HTTP PUT to http://host/v2/ontologies/guiorder\n</code></pre> <p>This can be done even if the class is used in data.</p> <p>The request body includes the cardinalities whose GUI order should be changed, using the predicate <code>salsah-gui:guiOrder</code>, whose object is an integer:</p> <pre><code>{\n  \"@id\" : \"ONTOLOGY_IRI\",\n  \"@type\" : \"owl:Ontology\",\n  \"knora-api:lastModificationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@graph\" : [ {\n    \"@id\" : \"CLASS_IRI\",\n    \"@type\" : \"owl:Class\",\n    \"rdfs:subClassOf\" : {\n      \"@type\": \"owl:Restriction\",\n      \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n      \"owl:onProperty\": {\n        \"@id\" : \"PROPERTY_IRI\"\n      },\n      \"salsah-gui:guiOrder\": \"GUI_ORDER_VALUE\"\n    }\n  } ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"salsah-gui\" : \"http://api.knora.org/ontology/salsah-gui/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>Only the cardinalities whose GUI order is to be changed need to be included in the request. The <code>OWL_CARDINALITY_PREDICATE</code> and <code>OWL_CARDINALITY_VALUE</code> are ignored; only the <code>GUI_ORDER_VALUE</code> is changed.</p>"},{"location":"03-endpoints/api-v2/ontology-information/#deleting-a-property","title":"Deleting a Property","text":"<p>A property can be deleted only if no other ontology entity refers to it, and if it is not used in data.</p> <pre><code>HTTP DELETE to http://host/v2/ontologies/properties/PROPERTY_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\n</code></pre> <p>The property IRI and the ontology's last modification date must be URL-encoded.</p> <p>If the property is a link property, the corresponding link value property (see Links Between Resources) will automatically be deleted.</p> <p>A successful response will be a JSON-LD document providing only the ontology's metadata.</p> <p>To check whether a property can be deleted:</p> <pre><code>HTTP GET to http://host/v2/ontologies/candeleteproperty/PROPERTY_IRI\n</code></pre> <p>The response will look like this:</p> <pre><code>{\n    \"knora-api:canDo\": false,\n    \"@context\": {\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/ontology-information/#deleting-a-class","title":"Deleting a Class","text":"<p>A class can be deleted only if no other ontology entity refers to it, and if it is not used in data.</p> <pre><code>HTTP DELETE to http://host/v2/ontologies/classes/CLASS_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\n</code></pre> <p>The class IRI and the ontology's last modification date must be URL-encoded.</p> <p>A successful response will be a JSON-LD document providing only the ontology's metadata.</p> <p>To check whether a class can be deleted:</p> <pre><code>HTTP GET to http://host/v2/ontologies/candeleteclass/CLASS_IRI\n</code></pre> <p>The response will look like this:</p> <pre><code>{\n    \"knora-api:canDo\": false,\n    \"@context\": {\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/permalinks/","title":"Permalinks","text":"<p>Knora provides a permanent, citable URL for each resource and value. These URLs use Archival Resource Key (ARK) Identifiers, and are designed to remain valid even if the resource itself is moved from one Knora repository to another.</p>"},{"location":"03-endpoints/api-v2/permalinks/#obtaining-ark-urls","title":"Obtaining ARK URLs","text":"<p>In the complex schema, a resource or value is always returned with two ARK URLs: one that will always refer to the latest version of the resource or value (<code>knora-api:arkUrl</code>), and one that refers specifically to the version being returned (<code>knora-api:versionArkUrl</code>). For example:</p> <pre><code>{\n  \"@id\" : \"http://rdfh.ch/0803/2a6221216701\",\n  \"@type\" : \"incunabula:book\",\n  \"incunabula:book_comment\" : {\n    \"@id\" : \"http://rdfh.ch/0803/2a6221216701/values/56c287fc9505\",\n    \"@type\" : \"knora-api:TextValue\",\n    \"knora-api:arkUrl\" : {\n      \"@type\" : \"xsd:anyURI\",\n      \"@value\" : \"http://ark.dasch.swiss/ark:/72163/1/0803/2a6221216701W/dhaRsvZATjmOxhCOOzHqewB\"\n    },\n    \"knora-api:versionArkUrl\" : {\n      \"@type\" : \"xsd:anyURI\",\n      \"@value\" : \"http://ark.dasch.swiss/ark:/72163/1/0803/2a6221216701W/dhaRsvZATjmOxhCOOzHqewB.20160302T150521Z\"\n    },\n    \"knora-api:attachedToUser\" : {\n      \"@id\" : \"http://rdfh.ch/users/91e19f1e01\"\n    },\n    \"knora-api:hasPermissions\" : \"CR knora-admin:Creator|M knora-admin:ProjectMember|V knora-admin:UnknownUser\",\n    \"knora-api:userHasPermission\" : \"V\",\n    \"knora-api:valueAsString\" : \"Katalogaufnahme anhand ISTC und v.d.Haegen\",\n    \"knora-api:valueCreationDate\" : {\n      \"@type\" : \"xsd:dateTimeStamp\",\n      \"@value\" : \"2016-03-02T15:05:21Z\"\n    },\n    \"knora-api:valueHasUUID\" : \"dhaRsvZATjmOxhCOOzHqew\"\n  },\n  \"knora-api:arkUrl\" : {\n    \"@type\" : \"xsd:anyURI\",\n    \"@value\" : \"http://ark.dasch.swiss/ark:/72163/1/0803/2a6221216701W\"\n  },\n  \"knora-api:versionArkUrl\" : {\n    \"@type\" : \"xsd:anyURI\",\n    \"@value\" : \"http://ark.dasch.swiss/ark:/72163/1/0803/2a6221216701W.20160302T150521Z\"\n  },\n  \"knora-api:attachedToProject\" : {\n    \"@id\" : \"http://rdfh.ch/projects/0803\"\n  },\n  \"knora-api:attachedToUser\" : {\n    \"@id\" : \"http://rdfh.ch/users/91e19f1e01\"\n  },\n  \"knora-api:creationDate\" : {\n    \"@type\" : \"xsd:dateTimeStamp\",\n    \"@value\" : \"2016-03-02T15:05:21Z\"\n  },\n  \"knora-api:hasPermissions\" : \"CR knora-admin:Creator|M knora-admin:ProjectMember|V knora-admin:UnknownUser\",\n  \"knora-api:userHasPermission\" : \"V\",\n  \"rdfs:label\" : \"Reise ins Heilige Land\",\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"incunabula\" : \"http://0.0.0.0:3333/ontology/0803/incunabula/v2#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\n</code></pre> <p>In the simple schema, resources are returned with ARK URLs, but values are returned as literals, so ARK URLs are not provided for values.</p> <p>For more information on getting past versions of resources and values, see:</p> <ul> <li>Get a Full Representation of a Version of a Resource by IRI</li> <li>Get a Version of a Value in a Resource</li> <li>Get the Version History of a Resource</li> </ul>"},{"location":"03-endpoints/api-v2/permalinks/#resolving-knora-ark-urls","title":"Resolving Knora ARK URLs","text":"<p>A Knora ARK URL is intended to be resolved by the Knora ARK resolver.</p>"},{"location":"03-endpoints/api-v2/permalinks/#knora-ark-url-format","title":"Knora ARK URL Format","text":"<p>For details, see Archival Resource Key (ARK) Identifiers.</p>"},{"location":"03-endpoints/api-v2/permalinks/#ark-urls-for-projects","title":"ARK URLs for Projects","text":"<p>The format of a Knora project ARK URL is as follows:</p> <pre><code>http://HOST/ark:/NAAN/VERSION/PROJECT\n</code></pre> <p><code>NAAN</code> is a Name Assigning Authority Number, <code>VERSION</code> is the version number of the Knora ARK URL format (currently always 1), and <code>PROJECT</code> is the project's short-code.</p> <p>For example, given a project with ID <code>0001</code>, and using the DaSCH's ARK resolver hostname and NAAN, the ARK URL for the project itself is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001\n</code></pre> <p>This could redirect to a page describing the project.</p>"},{"location":"03-endpoints/api-v2/permalinks/#ark-urls-for-resources","title":"ARK URLs for Resources","text":"<p>The format of a Knora resource ARK URL is as follows:</p> <pre><code>http://HOST/ark:/NAAN/VERSION/PROJECT/RESOURCE_UUID[.TIMESTAMP]\n</code></pre> <p><code>NAAN</code> is a Name Assigning Authority Number, <code>VERSION</code> is the version number of the Knora ARK URL format (currently always 1), <code>PROJECT</code> is the project's short-code, and <code>RESOURCE_UUID</code> is the resource's UUID.</p> <p>For example, given the Knora resource IRI <code>http://rdfh.ch/0001/0C-0L1kORryKzJAJxxRyRQ</code>, and using the DaSCH's ARK resolver hostname and NAAN, the corresponding ARK URL without a timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY\n</code></pre> <p>The same ARK URL with an optional timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY.20180604T085622513Z\n</code></pre> <p>Without a timestamp, a Knora resource ARK URL refers to the latest version of the resource at the time when the URL is resolved.</p>"},{"location":"03-endpoints/api-v2/permalinks/#ark-urls-for-values","title":"ARK URLs for Values","text":"<p>The format of a Knora value ARK URL is as follows:</p> <pre><code>http://HOST/ark:/NAAN/VERSION/PROJECT/RESOURCE_UUID/VALUE_UUID[.TIMESTAMP]\n</code></pre> <p><code>NAAN</code> is a Name Assigning Authority Number, <code>VERSION</code> is the version number of the Knora ARK URL format (currently always 1), <code>PROJECT</code> is the project's short-code, <code>RESOURCE_UUID</code> is the resource's UUID, and <code>VALUE_UUID</code> is the value's <code>knora-api:valueHasUUID</code>.</p> <p>For example, given a value with <code>knora-api:valueHasUUID \"4OOf3qJUTnCDXlPNnygSzQ\"</code> in the resource <code>http://rdfh.ch/0001/0C-0L1kORryKzJAJxxRyRQ</code>, and using the DaSCH's ARK resolver hostname and NAAN, the corresponding ARK URL without a timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY/4OOf3qJUTnCDXlPNnygSzQX\n</code></pre> <p>The same ARK URL with an optional timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY/4OOf3qJUTnCDXlPNnygSzQX.20180604T085622513Z\n</code></pre> <p>Without a timestamp, a Knora value ARK URL refers to the latest version of the value at the time when the URL is resolved.</p>"},{"location":"03-endpoints/api-v2/query-language/","title":"Gravsearch: Virtual Graph Search","text":""},{"location":"03-endpoints/api-v2/query-language/#basic-concept","title":"Basic Concept","text":"<p>Gravsearch is intended to offer the advantages of SPARQL endpoints (particularly the ability to perform queries using complex search criteria) while avoiding their drawbacks in terms of performance and security (see The Enduring Myth of the SPARQL Endpoint). It also has the benefit of enabling clients to work with a simpler RDF data model than the one the API actually uses to store data in the triplestore and makes it possible to provide better error-checking.</p> <p>Rather than being processed directly by the triplestore, a Gravsearch query is interpreted by the API, which enforces certain restrictions on the query, and implements paging and permission checking. The API server generates SPARQL based on the Gravsearch query submitted, queries the triplestore, filters the results according to the user's permissions, and returns each page of query results as an API response. Thus, Gravsearch is a hybrid between a RESTful API and a SPARQL endpoint.</p> <p>A Gravsearch query conforms to a subset of the syntax of a SPARQL CONSTRUCT query, with some additional restrictions and functionality. In particular, the variable representing the top-level (or 'main') resource that will appear in each search result must be identified, statements must be included to specify the types of the entities being queried, OFFSET is used to control paging, and <code>ORDER BY</code> is used to sort the results.</p> <p>It is certainly possible to write Gravsearch queries by hand, but we expect that in general, they will be automatically generated by client software, e.g. by a client user interface.</p> <p>For a more detailed overview of Gravsearch, see Gravsearch: Transforming SPARQL to query humanities data.</p>"},{"location":"03-endpoints/api-v2/query-language/#submitting-gravsearch-queries","title":"Submitting Gravsearch Queries","text":"<p>The recommended way to submit a Gravsearch query is via HTTP POST:</p> <pre><code>HTTP POST to http://host/v2/searchextended\n</code></pre> <p>This works like query via POST directly in the SPARQL 1.1 Protocol: the query is sent unencoded as the HTTP request message body, in the UTF-8 charset.</p> <p>It is also possible to submit a Gravsearch query using HTTP GET. The entire query must be URL-encoded and included as the last element of the URL path:</p> <pre><code>HTTP GET to http://host/v2/searchextended/QUERY\n</code></pre> <p>The response to a Gravsearch query is an RDF graph, which can be requested in various formats (see Responses Describing Resources).</p> <p>To request the number of results rather than the results themselves, you can do a count query:</p> <pre><code>HTTP POST to http://host/v2/searchextended/count\n</code></pre> <p>The response to a count query request is an object with one predicate, <code>http://schema.org/numberOfItems</code>, with an integer value.</p> <p>If a gravsearch query times out, a <code>504 Gateway Timeout</code> will be returned.</p>"},{"location":"03-endpoints/api-v2/query-language/#gravsearch-and-api-schemas","title":"Gravsearch and API Schemas","text":"<p>A Gravsearch query can be written in either of the two DSP-API v2 schemas. The simple schema is easier to work with, and is sufficient if you don't need to query anything below the level of a DSP-API value. If your query needs to refer to standoff markup, you must use the complex schema. Each query must use a single schema, with one exception (see Date Comparisons).</p> <p>Gravsearch query results can be requested in the simple or complex schema; see API Schema.</p> <p>All examples hereafter run with the DSP stack started locally. If you access another stack, you can check  the IRI of the ontology you are targeting by requesting the ontologies metadata.</p>"},{"location":"03-endpoints/api-v2/query-language/#using-the-simple-schema","title":"Using the Simple Schema","text":"<p>To write a query in the simple schema, use the <code>knora-api</code> ontology in the simple schema, and use the simple schema for any other DSP ontologies the query refers to, e.g.:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\n</code></pre> <p>In the simple schema, DSP-API values are represented as literals, which can be used in <code>FILTER</code> expressions (see Filtering on Values in the Simple Schema).</p>"},{"location":"03-endpoints/api-v2/query-language/#using-the-complex-schema","title":"Using the Complex Schema","text":"<p>To write a query in the complex schema, use the <code>knora-api</code> ontology in the complex schema, and use the complex schema for any other DSP ontologies the query refers to, e.g.:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/v2#&gt;\n</code></pre> <p>In the complex schema, DSP-API values are represented as objects belonging to subclasses of <code>knora-api:Value</code>, e.g. <code>knora-api:TextValue</code>, and have predicates of their own, which can be used in <code>FILTER</code> expressions (see Filtering on Values in the Complex Schema).</p>"},{"location":"03-endpoints/api-v2/query-language/#main-and-dependent-resources","title":"Main and Dependent Resources","text":"<p>The main resource is the top-level resource in a search result. Other resources that are in some way connected to the main resource are referred to as dependent resources. If the client asks for a resource A relating to a resource B, then all matches for A will be presented as main resources and those for B as dependent resources. The main resource must be represented by a variable, marked with <code>knora-api:isMainResource</code>, as explained under CONSTRUCT Clause.</p>"},{"location":"03-endpoints/api-v2/query-language/#virtual-incoming-links","title":"Virtual incoming Links","text":"<p>Depending on the ontology design, a resource A points to B or vice versa. For example, a page A is part of a book B using the property <code>incunabula:partOf</code>. If A is marked as the main resource, then B is nested as a dependent resource in its link value <code>incunabula:partOfValue</code>. But in case B is marked as the main resource, B does not have a link value pointing to A because in fact B is pointed to by A. Instead, B has a virtual property <code>knora-api:hasIncomingLink</code> containing A's link value:</p> <pre><code>\"knora-api:hasIncomingLinkValue\" : {\n    \"@id\" : \"http://rdfh.ch/A/values/xy\",\n    \"@type\" : \"knora-api:LinkValue\",\n    \"knora-api:linkValueHasSource\" : {\n      \"@id\" : \"http://rdfh.ch/A\",\n      \"@type\" : \"incunabula:page\",\n      \"incunabula:partOfValue\" : {\n        \"@id\" : \"http://rdfh.ch/A/values/xy\",\n        \"@type\" : \"knora-api:LinkValue\",\n        \"knora-api:linkValueHasTargetIri\" : {\n          \"@id\" : \"http://rdfh.ch/B\"\n        }\n      }\n    }\n  },\n</code></pre> <p>Note that the virtually inserted link value inverts the relation by using <code>knora-api:linkValueHasSource</code>. The source of the link is A and its target B is only represented by an IRI (<code>knora-api:linkValueHasTargetIri</code>) since B is the main resource.</p>"},{"location":"03-endpoints/api-v2/query-language/#dedicated-endpoint-for-querying-the-incoming-links","title":"Dedicated endpoint for querying the incoming links","text":"<p>Internal use only</p> <p>This endpoint is intended for internal use only and may be subject to change.</p> <p>The dedicated endpoint for querying the incoming links was introduced in DSP-API version v31.10.0.</p> <pre><code>HTTP GET to http://host/v2/searchIncomingLinks/[resourceIri]?offset=[pageNumber]\n</code></pre> <p>The route have two parameters, the resource IRI and the page number which translates to the SPARQL <code>OFFSET</code>. The default value for the page numbers is 0. The entire query must be URL-encoded and included as the last element of the URL path. Here is an example of the request for the resource <code>http://rdfh.ch/0001/a-thing-picture</code> with the page number 1:</p> <pre><code>http://host/v2/searchIncomingLinks/http%3A%2F%2Frdfh.ch%2F0001%2Fa-thing-picture?offset=1\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#graph-patterns-and-result-graphs","title":"Graph Patterns and Result Graphs","text":"<p>The WHERE clause of a Gravsearch query specifies a graph pattern. Each query result will match this graph pattern, and will have the form of a graph whose starting point is a main resource. The query's graph pattern, and hence each query result graph, can span zero more levels of relations between resources. For example, a query could request regions in images on pages of books written by a certain author, articles by authors who were students of a particular professor, or authors of texts that refer to events that took place within a certain date range.</p>"},{"location":"03-endpoints/api-v2/query-language/#permission-checking","title":"Permission Checking","text":"<p>Each matching resource is returned with the values that the user has permission to see. If the user does not have permission to see a matching main resource, it is hidden in the results. If a user does not have permission to see a matching dependent resource, the link value is hidden.</p>"},{"location":"03-endpoints/api-v2/query-language/#paging","title":"Paging","text":"<p>Gravsearch results are returned in pages. The maximum number of main resources per page is determined by the API (and can be configured in <code>application.conf</code> via the setting <code>app/v2/resources-sequence/results-per-page</code>). If some resources have been filtered out because the user does not have permission to see them, a page could contain fewer results, or no results. If it is possible that more results are available in subsequent pages, the Gravsearch response will contain the predicate <code>knora-api:mayHaveMoreResults</code> with the boolean value <code>true</code>, otherwise it will not contain this predicate. Therefore, to retrieve all available results, the client must request each page one at a time, until the response does not contain <code>knora-api:mayHaveMoreResults</code>.</p>"},{"location":"03-endpoints/api-v2/query-language/#inference","title":"Inference","text":"<p>Gravsearch queries are understood to imply a subset of RDFS reasoning. This is done by the API by expanding the incoming query.</p> <p>Specifically, if a statement pattern specifies a property, the pattern will also match subproperties of that property, and if a statement specifies that a subject has a particular <code>rdf:type</code>, the statement will also match subjects belonging to subclasses of that type.</p> <p>If you know that reasoning will not return any additional results for your query, you can disable it by adding this line to the <code>WHERE</code> clause, which may improve query performance:</p> <pre><code>knora-api:GravsearchOptions knora-api:useInference false .\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#gravsearch-syntax","title":"Gravsearch Syntax","text":"<p>Every Gravsearch query is a valid SPARQL 1.1 CONSTRUCT query. However, Gravsearch only supports a subset of the elements that can be used in a SPARQL Construct query, and a Gravsearch CONSTRUCT Clause has to indicate which variable is to be used for the main resource in each search result.</p>"},{"location":"03-endpoints/api-v2/query-language/#supported-sparql-syntax","title":"Supported SPARQL Syntax","text":"<p>The current version of Gravsearch accepts <code>CONSTRUCT</code> queries whose <code>WHERE</code> clauses use the following patterns, with the specified restrictions:</p> <ul> <li><code>OPTIONAL</code>: cannot be nested in a <code>UNION</code>.</li> <li><code>UNION</code>: cannot be nested in a <code>UNION</code>.</li> <li><code>FILTER</code>: may contain a complex expression using the Boolean   operators AND and OR, as well as comparison operators. The left   argument of a comparison operator must be a query variable.   A Knora ontology entity IRI used in a <code>FILTER</code> must be a property IRI.</li> <li><code>FILTER NOT EXISTS</code></li> <li><code>MINUS</code></li> <li><code>OFFSET</code>: the <code>OFFSET</code> is needed for paging. It does not actually   refer to the number of triples to be returned, but to the   requested page of results. The default value is 0, which refers   to the first page of results.</li> <li><code>ORDER BY</code>: In SPARQL, the result of a <code>CONSTRUCT</code> query is an   unordered set of triples. However, a Gravsearch query returns an   ordered list of resources, which can be ordered by the values of   specified properties. If the query is written in the complex schema,   items below the level of DSP-API values may not be used in <code>ORDER BY</code>.</li> <li><code>BIND</code>: The value assigned must be a DSP resource IRI.</li> </ul>"},{"location":"03-endpoints/api-v2/query-language/#resources-properties-and-values","title":"Resources, Properties, and Values","text":"<p>Resources can be represented either by an IRI or by a variable, except for the main resource, which must be represented by a variable.</p> <p>It is possible to do a Gravsearch query in which the IRI of the main resource is already known, e.g. to request specific information about that resource and perhaps about linked resources. In this case, the IRI of the main resource must be assigned to a variable using <code>BIND</code>. Note that <code>BIND</code> statements slow the query down, therefore we recommend that you do not use them unless you have to.</p> <p>Properties can be represented by an IRI or a query variable. If a property is represented by a query variable, it can be restricted to certain property IRIs using a <code>FILTER</code>.</p> <p>A Knora value (i.e. a value attached to a <code>knora-api:Resource</code>) must be represented as a query variable.</p>"},{"location":"03-endpoints/api-v2/query-language/#filtering-on-values","title":"Filtering on Values","text":""},{"location":"03-endpoints/api-v2/query-language/#filtering-on-values-in-the-simple-schema","title":"Filtering on Values in the Simple Schema","text":"<p>In the simple schema, a variable representing a DSP-API value can be used directly in a <code>FILTER</code> expression. For example:</p> <pre><code>?book incunabula:title ?title .\nFILTER(?title = \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\")\n</code></pre> <p>Here the type of <code>?title</code> is <code>xsd:string</code>.</p> <p>The following value types can be compared with literals in <code>FILTER</code> expressions in the simple schema:</p> <ul> <li>Text values (<code>xsd:string</code>)</li> <li>URI values (<code>xsd:anyURI</code>)</li> <li>Integer values (<code>xsd:integer</code>)</li> <li>Decimal values (<code>xsd:decimal</code>)</li> <li>Boolean values (<code>xsd:boolean</code>)</li> <li>Date values (<code>knora-api:Date</code>)</li> <li>List values (<code>knora-api:ListNode</code>)</li> </ul> <p>List values can only be searched for using the equal operator (<code>=</code>), performing an exact match on a list node's label. Labels can be given in different languages for a specific list node. If one of the given list node labels matches, it is considered a match. Note that in the simple schema, uniqueness is not guaranteed (as opposed to the complex schema).</p> <p>A DSP-API value may not be represented as the literal object of a predicate; for example, this is not allowed:</p> <pre><code>?book incunabula:title \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\" .\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#filtering-on-values-in-the-complex-schema","title":"Filtering on Values in the Complex Schema","text":"<p>In the complex schema, variables representing DSP-API values are not literals. You must add something to the query (generally a statement) to get a literal from a DSP-API value. For example:</p> <pre><code>?book incunabula:title ?title .\n?title knora-api:valueAsString \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\" .\n</code></pre> <p>Here the type of <code>?title</code> is <code>knora-api:TextValue</code>. Note that no <code>FILTER</code> is needed in this example. But if you want to use a different comparison operator, you need a <code>FILTER</code>:</p> <pre><code>?page incunabula:seqnum ?seqnum .\n?seqnum knora-api:intValueAsInt ?seqnumInt .\nFILTER(?seqnumInt &lt;= 10)\n</code></pre> <p>To match a date value in the complex schema, you must use the <code>knora-api:toSimpleDate</code> function in a <code>FILTER</code> (see Date Comparisons). The predicates of <code>knora-api:DateValue</code> (<code>knora-api:dateValueHasStartYear</code>, etc.) are not available in Gravsearch.</p>"},{"location":"03-endpoints/api-v2/query-language/#date-comparisons","title":"Date Comparisons","text":"<p>In the simple schema, you can compare a date value directly with a <code>knora-api:Date</code> in a <code>FILTER</code>:</p> <pre><code>?book incunabula:pubdate ?pubdate .\nFILTER(?pubdate &lt; \"JULIAN:1497\"^^knora-api:Date)\n</code></pre> <p>In the complex schema, you must use the function <code>knora-api:toSimpleDate</code>, passing it the variable representing the date value. The date literal used in the comparison must still be a <code>knora-api:Date</code> in the simple schema. This is the only case in which you can use both schemas in a single query:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX knora-api-simple: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n    ?book knora-api:isMainResource true .\n    ?book incunabula:pubdate ?pubdate .\n} WHERE {\n    ?book a incunabula:book .\n    ?book incunabula:pubdate ?pubdate .\n    FILTER(knora-api:toSimpleDate(?pubdate) &lt; \"JULIAN:1497\"^^knora-api-simple:Date)\n} ORDER BY ?pubdate\n</code></pre> <p>You can also use <code>knora-api:toSimpleDate</code> with to search for date tags in standoff text markup (see Matching Standoff Dates).</p> <p>Note that the given date value for comparison must have the following format: </p> <pre><code>(GREGORIAN|JULIAN|ISLAMIC):\\d{1,4}(-\\d{1,2}(-\\d{1,2})?)?( BC| AD| BCE| CE)?(:\\d{1,4}(-\\d{1,2}(-\\d{1,2})?)?( BC| AD| BCE| CE)?)?\n</code></pre> <p>E.g. an exact date like <code>GREGORIAN:2015-12-03</code> or a period like <code>GREGORIAN:2015-12-03:2015-12-04</code>. Dates may also have month or year precision, e.g. <code>ISLAMIC:1407-02</code> (the whole month of december) or <code>JULIAN:1330</code>  (the whole year 1330). An optional ERA indicator term (<code>BCE</code>, <code>CE</code>, or <code>BC</code>, <code>AD</code>) can be added to the date, when no  era is provided the default era <code>AD</code> will be considered. Era can be given as <code>GREGORIAN:1220 BC</code> or in range as  <code>GREGORIAN:600 BC:480 BC</code>.</p>"},{"location":"03-endpoints/api-v2/query-language/#searching-for-matching-words","title":"Searching for Matching Words","text":"<p>The function <code>knora-api:matchText</code> searches for matching words anywhere in a text value and is implemented using a full-text search index if available. The first argument must represent a text value (a <code>knore-api:TextValue</code> in the complex schema, or an <code>xsd:string</code> in the simple schema). The second argument is a string literal containing the words to be matched, separated by spaces. The function supports the Lucene Query Parser syntax. Note that Lucene's default operator is a logical OR when submitting several search terms.</p> <p>This function can only be used as the top-level expression in a <code>FILTER</code>.</p> <p>For example, to search for titles that contain the words 'Zeitgl\u00f6cklein' and 'Lebens':</p> <pre><code>?book incunabule:title ?title .\nFILTER knora-api:matchText(?title, \"Zeitgl\u00f6cklein Lebens\")\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#filtering-text-by-language","title":"Filtering Text by Language","text":"<p>To filter a text value by language in the simple schema, use the SPARQL <code>lang</code> function on the text value, e.g.:</p> <pre><code>FILTER(lang(?text) = \"fr\")\n</code></pre> <p>In the complex schema, the <code>lang</code> function is not supported. Use the text value's <code>knora-api:textValueHasLanguage</code> predicate instead:</p> <pre><code>?text knora-api:textValueHasLanguage \"fr\" .\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#regular-expressions","title":"Regular Expressions","text":"<p>The SPARQL <code>regex</code> function is supported. In the simple schema, you can use it directly on the text value, e.g.</p> <pre><code>?book incunabula:title ?title .\nFILTER regex(?title, \"Zeit\", \"i\")\n</code></pre> <p>In the complex schema, use it on the object of the text value's <code>knora-api:valueAsString</code> predicate:</p> <pre><code>?book incunabula:title ?title .\n?title knora-api:valueAsString ?titleStr .\nFILTER regex(?titleStr, \"Zeit\", \"i\")\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#searching-for-text-markup","title":"Searching for Text Markup","text":"<p>To refer to standoff markup in text values, you must write your query in the complex schema.</p> <p>A <code>knora-api:TextValue</code> can have the property <code>knora-api:textValueHasStandoff</code>, whose objects are the standoff markup tags in the text. You can match the tags you're interested in using <code>rdf:type</code> or other properties of each tag.</p>"},{"location":"03-endpoints/api-v2/query-language/#matching-text-in-a-standoff-tag","title":"Matching Text in a Standoff Tag","text":"<p>The function <code>knora-api:matchTextInStandoff</code> searches for standoff tags containing certain terms. The implementation is optimised using the full-text search index if available. The function takes three arguments:</p> <ol> <li>A variable representing a text value.</li> <li>A variable representing a standoff tag.</li> <li>A string literal containing space-separated search terms.</li> </ol> <p>This function can only be used as the top-level expression in a <code>FILTER</code>. For example:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;\nPREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\n\nCONSTRUCT {\n    ?letter knora-api:isMainResource true .\n    ?letter beol:hasText ?text .\n} WHERE {\n    ?letter a beol:letter .\n    ?letter beol:hasText ?text .\n    ?text knora-api:textValueHasStandoff ?standoffParagraphTag .\n    ?standoffParagraphTag a standoff:StandoffParagraphTag .\n    FILTER knora-api:matchTextInStandoff(?text, ?standoffParagraphTag, \"Grund Richtigkeit\")\n}\n</code></pre> <p>Here we are looking for letters containing the words \"Grund\" and \"Richtigkeit\" within a single paragraph.</p>"},{"location":"03-endpoints/api-v2/query-language/#matching-standoff-links","title":"Matching Standoff Links","text":"<p>If you are only interested in specifying that a resource has some text value containing a standoff link to another resource, the most efficient way is to use the property <code>knora-api:hasStandoffLinkTo</code>, whose subjects and objects are resources. This property is automatically maintained by the API. For example:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\n\nCONSTRUCT {\n    ?letter knora-api:isMainResource true .\n    ?letter beol:hasText ?text .\n} WHERE {\n    ?letter a beol:letter .\n    ?letter beol:hasText ?text .\n    ?letter knora-api:hasStandoffLinkTo ?person .\n    ?person a beol:person .\n    ?person beol:hasIAFIdentifier ?iafIdentifier .\n    ?iafIdentifier knora-api:valueAsString \"(VIAF)271899510\" .\n}\n</code></pre> <p>Here we are looking for letters containing a link to the historian Claude Jordan, who is identified by his Integrated Authority File identifier, <code>(VIAF)271899510</code>.</p> <p>However, if you need to specify the context in which the link tag occurs, you must use the function <code>knora-api:standoffLink</code>. It takes three arguments:</p> <ol> <li>A variable or IRI representing the resource that is the source of the link.</li> <li>A variable representing the standoff link tag.</li> <li>A variable or IRI representing the resource that is the target of the link.</li> </ol> <p>This function can only be used as the top-level expression in a <code>FILTER</code>. For example:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;\nPREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\n\nCONSTRUCT {\n    ?letter knora-api:isMainResource true .\n    ?letter beol:hasText ?text .\n} WHERE {\n    ?letter a beol:letter .\n    ?letter beol:hasText ?text .\n    ?text knora-api:textValueHasStandoff ?standoffLinkTag .\n    ?standoffLinkTag a knora-api:StandoffLinkTag .\n    FILTER knora-api:standoffLink(?letter, ?standoffLinkTag, ?person)\n    ?person a beol:person .\n    ?person beol:hasIAFIdentifier ?iafIdentifier .\n    ?iafIdentifier knora-api:valueAsString \"(VIAF)271899510\" .\n    ?standoffLinkTag knora-api:standoffTagHasStartParent ?standoffItalicTag .\n    ?standoffItalicTag a standoff:StandoffItalicTag .\n}\n</code></pre> <p>This has the same effect as the previous example, except that because we are matching the link tag itself, we can specify that its immediate parent is a <code>StandoffItalicTag</code>.</p> <p>If you actually want to get the target of the link (in this example, <code>?person</code>) in the search results, you need to add a statement like <code>?letter knora-api:hasStandoffLinkTo ?person .</code> to the <code>WHERE</code> clause and to the <code>CONSTRUCT</code> clause:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;\nPREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\n\nCONSTRUCT {\n    ?letter knora-api:isMainResource true .\n    ?letter beol:hasText ?text .\n    ?letter knora-api:hasStandoffLinkTo ?person .\n} WHERE {\n    ?letter a beol:letter .\n    ?letter beol:hasText ?text .\n    ?text knora-api:textValueHasStandoff ?standoffLinkTag .\n    ?standoffLinkTag a knora-api:StandoffLinkTag .\n    FILTER knora-api:standoffLink(?letter, ?standoffLinkTag, ?person)\n    ?person a beol:person .\n    ?person beol:hasIAFIdentifier ?iafIdentifier .\n    ?iafIdentifier knora-api:valueAsString \"(VIAF)271899510\" .\n    ?standoffLinkTag knora-api:standoffTagHasStartParent ?standoffItalicTag .\n    ?standoffItalicTag a standoff:StandoffItalicTag .\n    ?letter knora-api:hasStandoffLinkTo ?person .\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#matching-standoff-dates","title":"Matching Standoff Dates","text":"<p>You can use the <code>knora-api:toSimpleDate</code> function (see @refDate Comparisons) to match dates in standoff date tags, i.e. instances of <code>knora-api:StandoffDateTag</code> or of one of its subclasses. For example, here we are looking for a text containing an <code>anything:StandoffEventTag</code> (which is a project-specific subclass of <code>knora-api:StandoffDateTag</code>) representing an event that occurred sometime during the month of December 2016:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;\nPREFIX knora-api-simple: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n    ?thing knora-api:isMainResource true .\n    ?thing anything:hasText ?text .\n} WHERE {\n    ?thing a anything:Thing .\n    ?thing anything:hasText ?text .\n    ?text knora-api:textValueHasStandoff ?standoffEventTag .\n    ?standoffEventTag a anything:StandoffEventTag .\n    FILTER(knora-api:toSimpleDate(?standoffEventTag) = \"GREGORIAN:2016-12 CE\"^^knora-api-simple:Date)\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#matching-ancestor-tags","title":"Matching Ancestor Tags","text":"<p>Suppose we want to search for a standoff date in a paragraph, but we know that the paragraph tag might not be the immediate parent of the date tag. For example, the date tag might be in an italics tag, which is in a paragraph tag. In that case, we can use the inferred property <code>knora-api:standoffTagHasStartAncestor</code>. We can modify the previous example to do this:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;\nPREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;\nPREFIX knora-api-simple: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n    ?thing knora-api:isMainResource true .\n    ?thing anything:hasText ?text .\n} WHERE {\n    ?thing a anything:Thing .\n    ?thing anything:hasText ?text .\n    ?text knora-api:textValueHasStandoff ?standoffDateTag .\n    ?standoffDateTag a knora-api:StandoffDateTag .\n    FILTER(knora-api:toSimpleDate(?standoffDateTag) = \"GREGORIAN:2016-12-24 CE\"^^knora-api-simple:Date)\n    ?standoffDateTag knora-api:standoffTagHasStartAncestor ?standoffParagraphTag .\n    ?standoffParagraphTag a standoff:StandoffParagraphTag .\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#filtering-on-rdfslabel","title":"Filtering on <code>rdfs:label</code>","text":"<p>The <code>rdfs:label</code> of a resource is not a DSP-API value, but you can still search for it. This can be done in the same ways in the simple or complex schema:</p> <p>Using a string literal object:</p> <pre><code>?book rdfs:label \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\" .\n</code></pre> <p>Using a variable and a FILTER:</p> <pre><code>?book rdfs:label ?label .\nFILTER(?label = \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\")\n</code></pre> <p>Using the <code>regex</code> function:</p> <pre><code>?book rdfs:label ?bookLabel .\nFILTER regex(?bookLabel, \"Zeit\", \"i\")\n</code></pre> <p>To match words in an <code>rdfs:label</code> using the full-text search index, use the <code>knora-api:matchLabel</code> function, which works like <code>knora-api:matchText</code>, except that the first argument is a variable representing a resource:</p> <pre><code>FILTER knora-api:matchLabel(?book, \"Zeitgl\u00f6cklein\")\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#filtering-on-resource-iris","title":"Filtering on Resource IRIs","text":"<p>A <code>FILTER</code> can compare a variable with another variable or IRI representing a resource. For example, to find a letter whose author and recipient are different persons:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n\nCONSTRUCT {\n    ?letter knora-api:isMainResource true .\n    ?letter beol:hasAuthor ?person1 .\n    ?letter beol:hasRecipient ?person2 .\n} WHERE {\n    ?letter a beol:letter .\n    ?letter beol:hasAuthor ?person1 .\n    ?letter beol:hasRecipient ?person2 .\n    FILTER(?person1 != ?person2) .\n}\nOFFSET 0\n</code></pre> <p>To find a letter whose author is not a person with a specified IRI:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n\nCONSTRUCT {\n    ?letter knora-api:isMainResource true .\n    ?letter beol:hasAuthor ?person1 .\n    ?letter beol:hasRecipient ?person2 .\n} WHERE {\n    ?letter a beol:letter .\n    ?letter beol:hasAuthor ?person1 .\n    ?letter beol:hasRecipient ?person2 .\n    FILTER(?person1 != &lt;http://rdfh.ch/0801/F4n1xKa3TCiR4llJeElAGA&gt;) .\n}\nOFFSET 0\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#construct-clause","title":"CONSTRUCT Clause","text":"<p>In the <code>CONSTRUCT</code> clause of a Gravsearch query, the variable representing the main resource must be indicated with <code>knora-api:isMainResource true</code>. Exactly one variable representing a resource must be marked in this way.</p> <p>Any other statements in the <code>CONSTRUCT</code> clause must also be present in the WHERE clause. If a variable representing a resource or value is used in the <code>WHERE</code> clause but not in the <code>CONSTRUCT</code> clause, the matching resources or values will not be included in the results.</p> <p>If the query is written in the complex schema, all variables in the <code>CONSTRUCT</code> clause must refer to DSP-API resources, DSP-API values, or properties. Data below the level of values may not be mentioned in the <code>CONSTRUCT</code> clause.</p> <p>Predicates from the <code>rdf</code>, <code>rdfs</code>, and <code>owl</code> ontologies may not be used in the <code>CONSTRUCT</code> clause. The <code>rdfs:label</code> of each matching resource is always returned, so there is no need to mention it in the query.</p>"},{"location":"03-endpoints/api-v2/query-language/#gravsearch-by-example","title":"Gravsearch by Example","text":"<p>In this section, we provide some sample queries of different complexity to illustrate the usage of Gravsearch.</p>"},{"location":"03-endpoints/api-v2/query-language/#getting-all-the-components-of-a-compound-resource","title":"Getting All the Components of a Compound Resource","text":"<p>In order to get all the components of a compound resource, the following Gravsearch query can be sent to the API.</p> <p>In this case, the compound resource is an <code>incunabula:book</code> identified by the IRI <code>http://rdfh.ch/0803/c5058f3a</code> and the components are of type <code>incunabula:page</code> (test data for the Incunabula project). Since inference is assumed, we can use <code>knora-api:StillImageRepresentation</code> (<code>incunabula:page</code> is one of its subclasses). This makes the query more generic and allows for reuse (for instance, a client would like to query different types of compound resources defined in different ontologies).</p> <p><code>ORDER BY</code> is used to sort the components by their sequence number.</p> <p><code>OFFSET</code> is set to 0 to get the first page of results.</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n   ?component knora-api:isMainResource true . # marking of the component searched for as the main resource, required\n   ?component knora-api:seqnum ?seqnum . # return the sequence number in the response\n   ?component knora-api:hasStillImageFileValue ?file . # return the StillImageFile in the response\n} WHERE {\n   ?component a knora-api:StillImageRepresentation . # restriction of the type of component\n   ?component knora-api:isPartOf &lt;http://rdfh.ch/0803/c5058f3a&gt; . # component relates to a compound resource via this property\n   ?component knora-api:seqnum ?seqnum . # component must have a sequence number\n   ?component knora-api:hasStillImageFileValue ?file . # component must have a StillImageFile\n}\nORDER BY ASC(?seqnum) # order by sequence number, ascending\nOFFSET 0 # get first page of results\n</code></pre> <p>The <code>incunabula:book</code> with the IRI <code>http://rdfh.ch/0803/c5058f3a</code> has 402 pages. (This result can be obtained by doing a count query; see Submitting Gravsearch Queries.) However, with <code>OFFSET 0</code>, only the first page of results is returned. The same query can be sent again with <code>OFFSET 1</code> to get the next page of results, and so forth. When a page of results is not full (see settings in <code>app/v2</code> in <code>application.conf</code>) or is empty, no more results are available.</p> <p>By design, it is not possible for the client to get more than one page of results at a time; this is intended to prevent performance problems that would be caused by huge responses. A client that wants to download all the results of a query must request each page sequentially.</p> <p>Let's assume the client is not interested in all of the book's pages, but just in first ten of them. In that case, the sequence number can be restricted using a <code>FILTER</code> that is added to the query's <code>WHERE</code> clause:</p> <pre><code>FILTER (?seqnum &lt;= 10)\n</code></pre> <p>The first page starts with sequence number 1, so with this <code>FILTER</code> only the first ten pages are returned.</p> <p>This query would be exactly the same in the complex schema, except for the expansion of the <code>knora-api</code> prefix:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#traversing-multiple-links","title":"Traversing Multiple Links","text":"<p>Here we are looking for regions of pages that are part of books that have a particular title. In the simple schema:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n  ?region knora-api:isMainResource true ;\n    knora-api:isRegionOf ?page .\n\n  ?page incunabula:partOf ?book .\n\n  ?book incunabula:title ?title .\n} WHERE {\n  ?region a knora-api:Region ;\n    knora-api:isRegionOf ?page .\n\n  ?page a incunabula:page ;\n    incunabula:partOf ?book .\n\n  ?book incunabula:title ?title .\n\n  FILTER(?title = \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\")\n}\n</code></pre> <p>In the complex schema:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n\nCONSTRUCT {\n  ?region knora-api:isMainResource true ;\n    knora-api:isRegionOf ?page .\n\n  ?page incunabula:partOf ?book .\n\n  ?book incunabula:title ?title .\n} WHERE {\n  ?region a knora-api:Region ;\n    knora-api:isRegionOf ?page .\n\n  ?page a incunabula:page ;\n    incunabula:partOf ?book .\n\n  ?book incunabula:title ?title .\n\n  ?title knora-api:valueAsString \"Zeitgl\u00f6cklein des Lebens und Leidens Christi\" .\n}\n</code></pre> <p>If we remove the line <code>?book incunabula:title ?title .</code> from the <code>CONSTRUCT</code> clause, so that the <code>CONSTRUCT</code> clause no longer mentions <code>?title</code>, the response will contain the same matching resources, but the titles of those resources will not be included in the response.</p>"},{"location":"03-endpoints/api-v2/query-language/#requesting-a-graph-starting-with-a-known-resource","title":"Requesting a Graph Starting with a Known Resource","text":"<p>Here the IRI of the main resource is already known and we want specific information about it, as well as about related resources. In this case, the IRI of the main resource must be assigned to a variable using <code>BIND</code>:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n  ?letter knora-api:isMainResource true ;\n    beol:creationDate ?date ;\n    ?linkingProp1 ?person1 .\n\n  ?person1 beol:hasFamilyName ?familyName .\n} WHERE {\n  BIND(&lt;http://rdfh.ch/0801/_B3lQa6tSymIq7_7SowBsA&gt; AS ?letter)\n\n  ?letter a beol:letter ;\n    beol:creationDate ?date ;\n    ?linkingProp1 ?person1 .\n\n  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient)\n\n  ?person1 beol:hasFamilyName ?familyName .\n} ORDER BY ?date\n</code></pre> <p>This query would be the same in the complex schema, except for the prefix expansions:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#searching-for-a-list-value-referring-to-a-particular-list-node","title":"Searching for a List Value Referring to a Particular List Node","text":"<p>Since list nodes are represented by their IRI in the complex schema, uniqueness is guranteed (as opposed to the simple schema). Also all the subnodes of the given list node are considered a match.</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;\n\nCONSTRUCT {\n    ?thing knora-api:isMainResource true .\n    ?thing anything:hasListItem ?listItem .\n} WHERE {\n    ?thing anything:hasListItem ?listItem .\n    ?listItem knora-api:listValueAsListNode &lt;http://rdfh.ch/lists/0001/treeList02&gt; .\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#type-inference","title":"Type Inference","text":"<p>Gravsearch needs to be able to determine the types of the entities that query variables and IRIs refer to in the <code>WHERE</code> clause. In most cases, it can infer these from context and from the ontologies used. In particular, it needs to know:</p> <ul> <li>The type of the subject and object of each statement.</li> <li>The type that is expected as the object of each predicate.</li> </ul>"},{"location":"03-endpoints/api-v2/query-language/#type-annotations","title":"Type Annotations","text":"<p>When one or more types cannot be inferred, Gravsearch will return an error message indicating the entities for which it could not determine types. The missing information must then be given by adding type annotations to the query. This can always done by adding statements with the predicate <code>rdf:type</code>. The subject must be a resource or value, and the object must either be <code>knora-api:Resource</code> (if the subject is a resource) or the subject's specific type (if it is a value).</p> <p>For example, consider this query that uses a non-DSP property:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;\n\nCONSTRUCT {\n    ?book knora-api:isMainResource true ;\n        dcterms:title ?title .\n\n} WHERE {\n    ?book dcterms:title ?title .\n}\n</code></pre> <p>This produces the error message:</p> <pre><code>The types of one or more entities could not be determined:\n  ?book, &lt;http://purl.org/dc/terms/title&gt;, ?title\n</code></pre> <p>To solve this problem, it is enough to specify the types of <code>?book</code> and <code>?title</code>; the type of the expected object of <code>dcterms:title</code> can then be inferred from the type of <code>?title</code>.</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;\n\nCONSTRUCT {\n    ?book knora-api:isMainResource true ;\n        dcterms:title ?title .\n\n} WHERE {\n\n    ?book rdf:type incunabula:book ;\n        dcterms:title ?title .\n\n    ?title rdf:type xsd:string .\n\n}\n</code></pre> <p>It would also be possible to annotate the property itself, using the predicate <code>knora-api:objectType</code>; then the type of <code>?title</code> would be inferred:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;\n\nCONSTRUCT {\n    ?book knora-api:isMainResource true ;\n        dcterms:title ?title .\n\n} WHERE {\n\n    ?book rdf:type incunabula:book ;\n        dcterms:title ?title .\n\n    dcterms:title knora-api:objectType xsd:string .\n\n}\n</code></pre> <p>Note that it only makes sense to use <code>dcterms:title</code> in the simple schema, because its object is supposed to be a literal.</p> <p>Here is another example, using a non-DSP class:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;\n\nCONSTRUCT {\n    ?person knora-api:isMainResource true .\n} WHERE {\n    ?person a foaf:Person .\n    ?person foaf:familyName ?familyName .\n    FILTER(?familyName = \"Meier\")\n}\n</code></pre> <p>This produces the error message:</p> <pre><code>Types could not be determined for one or more entities: ?person\n</code></pre> <p>The solution is to specify that <code>?person</code> is a <code>knora-api:Resource</code>:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;\n\nCONSTRUCT {\n    ?person knora-api:isMainResource true .\n} WHERE {\n    ?person a foaf:Person .\n    ?person a knora-api:Resource .\n    ?person foaf:familyName ?familyName .\n    FILTER(?familyName = \"Meier\")\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#inconsistent-types","title":"Inconsistent Types","text":"<p>Gravsearch will also reject a query if an entity is used with inconsistent types. For example:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n    ?book knora-api:isMainResource true ;\n        incunabula:pubdate ?pubdate .\n} WHERE {\n    ?book a incunabula:book ;\n        incunabula:pubdate ?pubdate .\n\n  FILTER(?pubdate = \"JULIAN:1497-03-01\") .\n}\n</code></pre> <p>This returns the error message:</p> <pre><code>One or more entities have inconsistent types:\n\n&lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#pubdate&gt;\n  knora-api:objectType &lt;http://api.knora.org/ontology/knora-api/simple/v2#Date&gt; ;\n  knora-api:objectType &lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n\n?pubdate rdf:type &lt;http://api.knora.org/ontology/knora-api/simple/v2#Date&gt; ;\n  rdf:type &lt;http://www.w3.org/2001/XMLSchema#string&gt; .\n</code></pre> <p>This is because the <code>incunabula</code> ontology says that the object of <code>incunabula:pubdate</code> must be a <code>knora-api:Date</code>, but the <code>FILTER</code> expression compares <code>?pubdate</code> with an <code>xsd:string</code>. The solution is to specify the type of the literal in the <code>FILTER</code>:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n    ?book knora-api:isMainResource true ;\n        incunabula:pubdate ?pubdate .\n} WHERE {\n    ?book a incunabula:book ;\n        incunabula:pubdate ?pubdate .\n\n  FILTER(?pubdate = \"JULIAN:1497-03-01\"^^knora-api:Date) .\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#scoping-issues","title":"Scoping Issues","text":"<p>SPARQL is evaluated from the bottom up. A <code>UNION</code> block therefore opens a new scope, in which variables bound at higher levels are not necessarily in scope. This can cause unexpected results if queries are not carefully designed. Gravsearch tries to prevent this by rejecting queries in the following cases.</p>"},{"location":"03-endpoints/api-v2/query-language/#filter-in-union","title":"FILTER in UNION","text":"<p>A <code>FILTER</code> in a <code>UNION</code> block can only use variables that are bound in the same block, otherwise the query will be rejected. This query is invalid because <code>?text</code> is not bound in the <code>UNION</code> block containing the <code>FILTER</code> where the variable is used:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX mls: &lt;http://0.0.0.0:3333/ontology/0807/mls/simple/v2#&gt;\n\nCONSTRUCT {\n    ?lemma knora-api:isMainResource true .\n    ?lemma mls:hasLemmaText ?text .        \n} WHERE {\n    ?lemma a mls:Lemma .\n    ?lemma mls:hasLemmaText ?text .\n\n    {\n        ?lemma mls:hasPseudonym ?pseudo .\n        FILTER regex(?pseudo, \"Abel\", \"i\") .\n    } UNION {\n        FILTER regex(?text, \"Abel\", \"i\") .\n    }\n}\nORDER BY ASC(?text)\nOFFSET 0\n</code></pre> <p>It can be corrected like this:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX mls: &lt;http://0.0.0.0:3333/ontology/0807/mls/simple/v2#&gt;\n\nCONSTRUCT {\n    ?lemma knora-api:isMainResource true .\n    ?lemma mls:hasLemmaText ?text .        \n} WHERE {\n    ?lemma a mls:Lemma .\n    ?lemma mls:hasLemmaText ?text .\n\n    {\n        ?lemma mls:hasPseudonym ?pseudo .\n        FILTER regex(?pseudo, \"Abel\", \"i\") .\n    } UNION {\n        ?lemma mls:hasLemmaText ?text .\n        FILTER regex(?text, \"Abel\", \"i\") .\n    }\n}\nORDER BY ASC(?text)\nOFFSET 0\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#order-by","title":"ORDER BY","text":"<p>A variable used in <code>ORDER BY</code> must be bound at the top level of the <code>WHERE</code> clause. This query is invalid, because <code>?int</code> is not bound at the top level of the <code>WHERE</code> clause:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;\n\nCONSTRUCT {\n    ?thing knora-api:isMainResource true .\n    ?thing anything:hasInteger ?int .\n    ?thing anything:hasRichtext ?richtext .\n    ?thing anything:hasText ?text .\n} WHERE {\n    ?thing a knora-api:Resource .\n    ?thing a anything:Thing .\n\n    {\n        ?thing anything:hasRichtext ?richtext .\n        FILTER knora-api:matchText(?richtext, \"test\")\n        ?thing anything:hasInteger ?int .\n    }\n    UNION\n    {\n        ?thing anything:hasText ?text .\n        FILTER knora-api:matchText(?text, \"test\")\n        ?thing anything:hasInteger ?int .\n    }\n}\nORDER BY (?int)\n</code></pre> <p>It can be corrected like this:</p> <pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\nPREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;\n\nCONSTRUCT {\n    ?thing knora-api:isMainResource true .\n    ?thing anything:hasInteger ?int .\n    ?thing anything:hasRichtext ?richtext .\n    ?thing anything:hasText ?text .\n} WHERE {\n    ?thing a knora-api:Resource .\n    ?thing a anything:Thing .\n    ?thing anything:hasInteger ?int .\n\n    {\n        ?thing anything:hasRichtext ?richtext .\n        FILTER knora-api:matchText(?richtext, \"test\")\n    }\n    UNION\n    {\n        ?thing anything:hasText ?text .\n        FILTER knora-api:matchText(?text, \"test\")\n    }\n}\nORDER BY (?int)\n</code></pre>"},{"location":"03-endpoints/api-v2/query-language/#query-optimization-by-dependency","title":"Query Optimization by Dependency","text":"<p>The query performance of triplestores, such as Fuseki, is highly dependent on the order of query patterns. To improve performance, Gravsearch automatically reorders the statement patterns in the WHERE clause according to their dependencies on each other, to minimise the number of possible matches for each pattern.</p> <p>Consider the following Gravsearch query:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n\nCONSTRUCT {\n  ?letter knora-api:isMainResource true .\n  ?letter ?linkingProp1  ?person1 .\n  ?letter ?linkingProp2  ?person2 .\n  ?letter beol:creationDate ?date .\n} WHERE {\n  ?letter beol:creationDate ?date .\n\n  ?letter ?linkingProp1 ?person1 .\n  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient )\n\n  ?letter ?linkingProp2 ?person2 .\n  FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient )\n\n  ?person1 beol:hasIAFIdentifier ?gnd1 .\n  ?gnd1 knora-api:valueAsString \"(DE-588)118531379\" .\n\n  ?person2 beol:hasIAFIdentifier ?gnd2 .\n  ?gnd2 knora-api:valueAsString \"(DE-588)118696149\" .\n} ORDER BY ?date\n</code></pre> <p>Gravsearch optimises the performance of this query by moving these statements to the top of the WHERE clause:</p> <pre><code>  ?gnd1 knora-api:valueAsString \"(DE-588)118531379\" .\n  ?gnd2 knora-api:valueAsString \"(DE-588)118696149\" .\n</code></pre> <p>The rest of the WHERE clause then reads:</p> <pre><code>  ?person1 beol:hasIAFIdentifier ?gnd1 .\n  ?person2 beol:hasIAFIdentifier ?gnd2 .\n  ?letter ?linkingProp1 ?person1 .\n  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient )\n\n  ?letter ?linkingProp2 ?person2 .\n  FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient )\n ?letter beol:creationDate ?date .\n</code></pre>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/","title":"Reading and Searching Resources","text":"<p>To retrieve an existing resource, the HTTP method <code>GET</code> has to be used. Reading resources may require authentication, since some resources may have restricted viewing permissions.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#responses-describing-resources","title":"Responses Describing Resources","text":"<p>Resources can be returned in JSON-LD, Turtle, or RDF/XML, using HTTP content negotiation (see Response Formats).</p> <p>Operations for reading and searching resources can return responses in either the simple or the complex ontology schema. The complex schema is used by default. To receive a response in the simple schema, use the HTTP request header or URL parameter described in API Schema.</p> <p>Each DSP-API v2 response describing one or more resources returns a single RDF graph. For example, a request for a single resource returns that resource and all its values. In a full-text search, the resource is returned with the values that matched the search criteria. A response to an extended search may represent a whole graph of interconnected resources.</p> <p>In JSON-LD, if only one resource is returned, it is the top-level object; if more than one resource is returned, they are represented as an array of objects of the <code>@graph</code> member of the top-level object (see Named Graphs in the JSON-LD specification).</p> <p>In the complex schema, dependent resources, i.e. resources that are referred to by other resources on the top level, are nested in link value objects. If resources on the top level are referred to by other resources and  these links are part of the response, virtual incoming links are generated; see Gravsearch: Virtual Graph Search).</p> <p>See the interfaces <code>Resource</code> and <code>ResourcesSequence</code> in module <code>ResourcesResponse</code> (exists for both API schemas: <code>ApiV2Simple</code> and <code>ApiV2WithValueObjects</code>).</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#requesting-text-markup-as-xml","title":"Requesting Text Markup as XML","text":"<p>When requesting a text value with standoff markup, there are three possibilities:</p> <ol> <li>The text value uses standard mapping.</li> <li>The text value uses a custom mapping which does not specify an XSL transformation.</li> <li>The text value uses a custom mapping which specifies an XSL transformation.</li> </ol> <p>In the first case, the mapping will be defined as:</p> <pre><code>\"kb:textValueHasMapping\": {\n        \"@id\": \"http://rdfh.ch/standoff/mappings/StandardMapping\"\n    }\n</code></pre> <p>the text value will only be available as <code>kb:textValueAsXml</code>, which will be of the following structure:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;text documentType=\"html\"&gt;\n   ...\n&lt;/text&gt;\n</code></pre> <p>where the content of <code>&lt;text&gt;</code> is a limited set of HTML tags that can be handled by CKEditor in DSP-APP. This allows for both displaying and editing the text value.</p> <p>In the second and third case, <code>kb:textValueHasMapping</code> will point to the custom mapping  that may or may not specify an XSL transformation.</p> <p>If no transformation is specified (second case), the text value will be returned only as <code>kb:textValueAsXml</code>. This property will be a string containing the contents of the initially uploaded XML.</p> <p>Note: The returned XML document is equivalent to the uploaded document but it is not necessarily identical - the order of the attributes in one element may vary from the original.</p> <p>In the third case, when a transformation is specified, both <code>kb:textValueAsXml</code> and <code>kb:textValueAsHtml</code> will be returned. <code>kb:textValueAsHtml</code> is the result of the XSL transformation applied to <code>kb:textValueAsXml</code>. The HTML representation is intended to display the text value in a human readable and properly styled way,  while the XML representation can be used to update the text value.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-the-representation-of-a-resource-by-iri","title":"Get the Representation of a Resource by IRI","text":""},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-a-full-representation-of-a-resource-by-iri","title":"Get a Full Representation of a Resource by IRI","text":"<p>A full representation of resource can be obtained by making a GET request to the API providing its IRI. Because a DSP IRI has the format of a URL, its IRI has to be URL-encoded.</p> <p>To get the resource with the IRI <code>http://rdfh.ch/c5058f3a</code> (a book from the sample Incunabula project, which is included in the DSP-API  server's test data), make a HTTP GET request to the <code>resources</code> route (path segment <code>resources</code> in the API call) and append the URL-encoded IRI:</p> <pre><code>HTTP GET to http://host/v2/resources/http%3A%2F%2Frdfh.ch%2Fc5058f3a\n</code></pre> <p>If necessary, several resources can be queried at the same time, their IRIs separated by slashes. Please note that the amount of resources that can be queried in one requested is limited. See the settings for <code>app/v2</code> in <code>application.conf</code>.</p> <p>More formally, the URL looks like this:</p> <pre><code>HTTP GET to http://host/v2/resources/resourceIRI(/anotherResourceIri)*\n</code></pre>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-a-full-representation-of-a-version-of-a-resource-by-iri","title":"Get a Full Representation of a Version of a Resource by IRI","text":"<p>To get a specific past version of a resource, use the route described in Get a Full Representation of a Resource by IRI, and add the URL parameter <code>?version=TIMESTAMP</code>, where <code>TIMESTAMP</code> is an xsd:dateTimeStamp in the UTC timezone. The timestamp can either be URL-encoded, or submitted with all punctuation (<code>-</code>, <code>:</code>, and <code>.</code>) removed (this is to accept timestamps from DSP's ARK URLs).</p> <p>The resource will be returned with the values that it had at the specified time. Since DSP only versions values, not resource metadata (e.g. <code>rdfs:label</code>), the current metadata will be returned.</p> <p>Each value will be returned with the permissions that are attached to the current version of the value (see Permissions).</p> <p>The returned resource will include the predicate <code>knora-api:versionDate</code>, containing the timestamp that was submitted, and its <code>knora-api:versionArkUrl</code> (see Resource Permalinks) will contain the same timestamp.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-a-value-in-a-resource","title":"Get a Value in a Resource","text":"<p>To get a specific value of a resource, use this route:</p> <pre><code>HTTP GET to http://host/v2/values/resourceIRI/valueUUID\n</code></pre> <p>The resource IRI must be URL-encoded. The path element <code>valueUUID</code> is the string object of the value's <code>knora-api:valueHasUUID</code>.</p> <p>The value will be returned within its containing resource, in the same format as for Responses Describing Resources, but without any of the resource's other values.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-a-version-of-a-value-in-a-resource","title":"Get a Version of a Value in a Resource","text":"<p>To get a particular version of a specific value of a resource, use the route described in Get a Value in a Resource, and add the URL parameter <code>?version=TIMESTAMP</code>, where <code>TIMESTAMP</code> is an xsd:dateTimeStamp in the UTC timezone. The timestamp can either be URL-encoded, or submitted with all punctuation (<code>-</code>, <code>:</code>, and <code>.</code>) removed (this is to accept timestamps from DSP's ARK URLs).</p> <p>The value will be returned within its containing resource, in the same format as for Responses Describing Resources, but without any of the resource's other values.</p> <p>Since DSP only versions values, not resource metadata (e.g. <code>rdfs:label</code>), the current resource metadata will be returned.</p> <p>The value will be returned with the permissions that are attached to its current version (see Permissions).</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-the-version-history-of-a-resource","title":"Get the Version History of a Resource","text":"<p>To get a list of the changes that have been made to a resource since its creation, use this route:</p> <pre><code>HTTP GET to http://host/v2/resources/history/resourceIRI[?startDate=START_DATE&amp;endDate=END_DATE]\n</code></pre> <p>The resource IRI must be URL-encoded. The start and end dates are optional, and are URL-encoded timestamps in xsd:dateTimeStamp format. The start date is inclusive, and the end date is exclusive. If the start date is not provided, the resource's history since its creation is returned. If the end date is not provided, the resource's history up to the present is returned.</p> <p>The response is a list of changes made to the resource, in reverse chronological order. Each entry has the properties <code>knora-api:author</code> (the IRI of the user who made the change) and <code>knora-api:versionDate</code> (the date when the change was made). For example:</p> <pre><code>{\n  \"@graph\" : [ {\n    \"knora-api:author\" : {\n      \"@id\" : \"http://rdfh.ch/users/BhkfBc3hTeS_IDo-JgXRbQ\"\n    },\n    \"knora-api:versionDate\" : {\n      \"@type\" : \"xsd:dateTimeStamp\",\n      \"@value\" : \"2019-02-11T09:05:10Z\"\n    }\n  }, {\n    \"knora-api:author\" : {\n      \"@id\" : \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n    },\n    \"knora-api:versionDate\" : {\n      \"@type\" : \"xsd:dateTimeStamp\",\n      \"@value\" : \"2019-02-10T10:30:10Z\"\n    }\n  }, {\n    \"knora-api:author\" : {\n      \"@id\" : \"http://rdfh.ch/users/BhkfBc3hTeS_IDo-JgXRbQ\"\n    },\n    \"knora-api:versionDate\" : {\n      \"@type\" : \"xsd:dateTimeStamp\",\n      \"@value\" : \"2019-02-10T10:05:10Z\"\n    }\n  } ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\n</code></pre> <p>The entries include all the dates when the resource's values were created or modified (within the requested date range), as well as the date when the resource was created (if the requested date range allows it). Each date is included only once. Since DSP only versions values, not resource metadata (e.g. <code>rdfs:label</code>), changes to a resource's metadata are not included in its version history.</p> <p>To request the resource as it was at each of these dates, see Get a Full Representation of a Version of a Resource by IRI.  For consistency in citation, we recommend using these dates when requesting resource versions.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-the-preview-of-a-resource-by-iri","title":"Get the preview of a resource by IRI","text":"<p>In some cases, the client may only want to request the preview of a resource, which just provides its metadata (e.g. its IRI, <code>rdfs:label</code>, and type), without its values.</p> <p>This works exactly like making a conventional resource request, using the path segment <code>resourcespreview</code>:</p> <pre><code>HTTP GET to http://host/v2/resourcespreview/resourceIRI(/anotherResourceIri)*\n</code></pre>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-a-graph-of-resources","title":"Get a Graph of Resources","text":"<p>DSP can return a graph of connections between resources, e.g. for generating a network diagram.</p> <pre><code>HTTP GET to http://host/v2/graph/resourceIRI[depth=Integer]\n[direction=outbound|inbound|both][excludeProperty=propertyIri]\n</code></pre> <p>The first parameter must be preceded by a question mark <code>?</code>, any following parameter by an ampersand <code>&amp;</code>.</p> <ul> <li><code>depth</code> must be at least 1. The maximum depth is a DSP configuration setting.   The default is 4.</li> <li><code>direction</code> specifies the direction of the links to be queried, i.e. links to   and/or from the given resource. The default is <code>outbound</code>.</li> <li><code>excludeProperty</code> is an optional link property to be excluded from the   results.</li> </ul> <p>To accommodate large graphs, the graph response format is very concise, and is therefore simpler than the usual resources response format. Each resource represented only by its IRI, class, and label. Direct links are shown instead of link values. For example:</p> <pre><code>{\n  \"@graph\" : [ {\n    \"@id\" : \"http://rdfh.ch/0001/0C-0L1kORryKzJAJxxRyRQ\",\n    \"@type\" : \"anything:Thing\",\n    \"rdfs:label\" : \"Sierra\"\n  }, {\n    \"@id\" : \"http://rdfh.ch/0001/A67ka6UQRHWf313tbhQBjw\",\n    \"@type\" : \"anything:Thing\",\n    \"rdfs:label\" : \"Victor\"\n  }, {\n    \"@id\" : \"http://rdfh.ch/0001/Lz7WEqJETJqqsUZQYexBQg\",\n    \"@type\" : \"anything:Thing\",\n    \"rdfs:label\" : \"Foxtrot\"\n  }, {\n    \"@id\" : \"http://rdfh.ch/0001/WLSHxQUgTOmG1T0lBU2r5w\",\n    \"@type\" : \"anything:Thing\",\n    \"anything:hasOtherThing\" : {\n      \"@id\" : \"http://rdfh.ch/0001/A67ka6UQRHWf313tbhQBjw\"\n    },\n    \"rdfs:label\" : \"Tango\"\n  }, {\n    \"@id\" : \"http://rdfh.ch/0001/start\",\n    \"@type\" : \"anything:Thing\",\n    \"anything:hasOtherThing\" : [ {\n      \"@id\" : \"http://rdfh.ch/0001/0C-0L1kORryKzJAJxxRyRQ\"\n    }, {\n      \"@id\" : \"http://rdfh.ch/0001/WLSHxQUgTOmG1T0lBU2r5w\"\n    }, {\n      \"@id\" : \"http://rdfh.ch/0001/tPfZeNMvRVujCQqbIbvO0A\"\n    } ],\n    \"rdfs:label\" : \"Romeo\"\n  }, {\n    \"@id\" : \"http://rdfh.ch/0001/tPfZeNMvRVujCQqbIbvO0A\",\n    \"@type\" : \"anything:Thing\",\n    \"anything:hasOtherThing\" : {\n      \"@id\" : \"http://rdfh.ch/0001/Lz7WEqJETJqqsUZQYexBQg\"\n    },\n    \"rdfs:label\" : \"Echo\"\n  } ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"anything\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\"\n  }\n}\n</code></pre>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#search-for-resources","title":"Search for Resources","text":""},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#search-for-a-resource-by-its-rdfslabel","title":"Search for a Resource by its <code>rdfs:label</code>","text":"<p>DSP offers the possibility to search for resources by their <code>rdfs:label</code>. The use case for this search is to find a specific resource as you type. E.g., the user wants to get a list of resources whose <code>rdfs:label</code> contain some search terms separated by a whitespace character:</p> <ul> <li>Zeit</li> <li>Zeitg</li> <li>...</li> <li>Zeitgl\u00f6cklein d</li> <li>...</li> <li>Zeitgl\u00f6cklein des Lebens</li> </ul> <p>With each character added to the last term, the selection gets more specific. The first term should at least contain three characters. To make this kind of \"search as you type\" possible, a wildcard character is automatically added to the last search term. </p> <p>Characters provided by the user that have a special meaning in the Lucene Query Parser  syntax need to be escaped. If a user wants to search for the string \"Zeit-Gl\u00f6cklein\", she needs to type \"Zeit-Gl\u00f6cklein\". The special characters that need escaping are:  <code>+</code>, <code>-</code>, <code>&amp;</code>, <code>|</code>, <code>!</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>^</code>, <code>\"</code>, <code>~</code>, <code>*</code>, <code>?</code>, <code>:</code>, <code>\\</code>, <code>/</code></p> <pre><code>HTTP GET to http://host/v2/searchbylabel/searchValue[limitToResourceClass=resourceClassIRI]\n[limitToProject=projectIRI][offset=Integer]\n</code></pre> <p>The first parameter must be preceded by a question mark <code>?</code>, any following parameter by an ampersand <code>&amp;</code>.</p> <p>The default value for the parameter <code>offset</code> is 0, which returns the first page of search results. Subsequent pages of results can be fetched by increasing <code>offset</code> by one. The amount of results per page is defined in <code>app/v2</code> in <code>application.conf</code>.</p> <p>For performance reasons, standoff markup is not queried for this route.</p> <p>To request the number of results rather than the results themselves, you can do a count query:</p> <pre><code>HTTP GET to http://host/v2/searchbylabel/count/searchValue[limitToResourceClass=resourceClassIRI][limitToProject=projectIRI][offset=Integer]\n</code></pre> <p>The response to a count query request is an object with one predicate, <code>http://schema.org/numberOfItems</code>, with an integer value.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#full-text-search","title":"Full-text Search","text":"<p>DSP offers a full-text search that searches through all textual representations of values and <code>rdfs:label</code> of resources.  Full-text search supports the  Lucene Query Parser syntax. Note that Lucene's default operator is a logical OR when submitting several search terms.</p> <p>The search index used by DSP transforms all text into lower case characters and splits text into tokens by whitespace.  For example, if a text value is: <code>The cake needs flour, sugar, and butter.</code>,  the tokens are <code>the</code>, <code>cake</code>, <code>needs</code>, <code>flour,</code>, <code>sugar,</code>, <code>and</code>, <code>butter.</code>. Note that punctuation marks like <code>,</code> and <code>.</code> are left with the word where they occurred. Therefore, if you search for <code>sugar</code> you would have to use <code>sugar*</code> or <code>sugar?</code>  to get results that contain <code>sugar,</code> or <code>sugar.</code> as well. The reason for this kind of tokenization is  that some users need to be able to search explicitly for special characters including punctuation marks.</p> <p>Alphabetic, numeric, symbolic, and diacritical Unicode characters  which are not in the first 127 ASCII characters (the \"Basic Latin\" Unicode block)  are converted into their ASCII equivalents, if one exists, e.g. <code>\u00e9</code> or <code>\u00e4</code> are converted into <code>e</code> and <code>a</code>.</p> <p>Please note that the search terms have to be URL-encoded.</p> <pre><code>HTTP GET to http://host/v2/search/searchValue[limitToResourceClass=resourceClassIRI]\n[limitToStandoffClass=standoffClassIri][limitToProject=projectIRI][offset=Integer]\n</code></pre> <p>The first parameter has to be preceded by a question mark <code>?</code>, any following parameter by an ampersand <code>&amp;</code>.</p> <p>A search value must have a minimal length of three characters (default value)  as defined in <code>search-value-min-length</code> in <code>application.conf</code>.</p> <p>A search term may contain wildcards. A <code>?</code> represents a single character.  It has to be URL-encoded as <code>%3F</code> since it has a special meaning in the URL syntax.  For example, the term <code>Uniform</code> can be search for like this:</p> <pre><code>HTTP GET to http://host/v2/search/Unif%3Frm\n</code></pre> <p>A <code>*</code> represents zero, one or multiple characters. For example, the term <code>Uniform</code> can be searched for like this:</p> <pre><code>HTTP GET to http://host/v2/search/Uni*m\n</code></pre> <p>The default value for the parameter <code>offset</code> is 0 which returns the first page of search results. Subsequent pages of results can be fetched by increasing <code>offset</code> by one. The amount of results per page is defined in <code>results-per-page</code> in <code>application.conf</code>.</p> <p>If the parameter <code>limitToStandoffClass</code> is provided, DSP will look for search terms that are marked up with the indicated standoff class.</p> <p>If the parameter <code>returnFiles=true</code> is provided, DSP will return any file value attached to each matching resource.</p> <p>To request the number of results rather than the results themselves, you can do a count query:</p> <pre><code>HTTP GET to http://host/v2/search/count/searchValue[limitToResourceClass=resourceClassIRI][limitToStandoffClass=standoffClassIri][limitToProject=projectIRI][offset=Integer]\n</code></pre> <p>The first parameter has to be preceded by a question mark <code>?</code>, any following parameter by an ampersand <code>&amp;</code>.</p> <p>The response to a count query request is an object with one predicate, <code>http://schema.org/numberOfItems</code>, with an integer value.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#gravsearch","title":"Gravsearch","text":"<p>For more complex queries than a full-text search, DSP offers a query language called Gravsearch: Virtual Graph Search).</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#support-of-teixml","title":"Support of TEI/XML","text":"<p>To convert standoff markup to TEI/XML, see TEI/XML.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#iiif-manifests","title":"IIIF Manifests","text":"<p>This is an experimental feature and may change.</p> <p>To generate a IIIF manifest for a resource, containing the still image representations that have <code>knora-api:isPartOf</code> (or a subproperty) pointing to that resource:</p> <pre><code>HTTP GET to http://host/v2/resources//iiifmanifest/RESOURCE_IRI\n</code></pre>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#reading-resources-by-class-from-a-project","title":"Reading Resources by Class from a Project","text":"<p>To facilitate the development of tabular user interfaces for data entry, it is possible to get a paged list of all the resources belonging to a particular class in a given project, sorted by the value of a property:</p> <pre><code>HTTP GET to http://host/v2/resources?resourceClass=RESOURCE_CLASS_IRI&amp;page=PAGE[&amp;orderByProperty=PROPERTY_IRI]\n</code></pre> <p>This is useful only if the project does not contain a large amount of data; otherwise, you should use Gravsearch to search using more specific criteria.</p> <p>The specified class and property are used without inference; they will not match subclasses or subproperties.</p> <p>The HTTP header <code>X-Knora-Accept-Project</code> must be submitted; its value is a DSP project IRI. In the request URL, the values of <code>resourceClass</code> and <code>orderByProperty</code> are URL-encoded IRIs in the complex schema. The <code>orderByProperty</code> parameter is optional; if it is not supplied, resources will be sorted alphabetically by resource IRI (an arbitrary but consistent order). The value of <code>page</code> is a 0-based integer page number. Paging works as it does in Gravsearch).</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-the-full-history-of-a-resource-and-its-values-as-events","title":"Get the Full History of a Resource and its Values as Events","text":"<p>To get a list of the changes that have been made to a resource and its values since its creation as events ordered by  date:</p> <pre><code>HTTP GET to http://host/v2/resources/resourceHistoryEvents/&lt;resourceIRI&gt;\n</code></pre> <p>The resource IRI must be URL-encoded. The response is a list of events describing changes made to the resource and its values,  in chronological order. Each entry has the properties:   <code>knora-api:eventType</code> (the type of the operation performed on a specific date. The operation can be either  <code>createdResource</code>, <code>updatedResourceMetadata</code>, <code>deletedResource</code>, <code>createdValue</code>, <code>updatedValueContent</code>,   <code>updatedValuePermissions</code>, or <code>deletedValue</code>.),  <code>knora-api:versionDate</code> (the date when the change was made), <code>knora-api:author</code> (the IRI of the user who made the change), <code>knora-api:eventBody</code> (the information necessary to make the same request). </p> <p>For example, the following response contains the list of events describing the version history of the resource  <code>http://rdfh.ch/0001/thing-with-history</code> ordered by date:</p> <pre><code>{\n  \"@graph\" : [ \n        {\n            \"knora-api:eventType\": \"createdResource\",\n            \"knora-api:author\": {\n                \"@id\": \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n            },\n            \"knora-api:eventBody\": {\n                \"rdfs:label\": \"A thing with version history\",\n                \"knora-api:resourceIri\": \"http://rdfh.ch/0001/thing-with-history\",\n                \"knora-api:resourceClassIri\": \"http://www.knora.org/ontology/0001/anything#Thing\",\n                \"knora-api:hasPermissions\": \"CR knora-admin:Creator|M knora-admin:ProjectMember|V knora-admin:UnknownUser\",\n                \"knora-api:creationDate\": {\n                    \"@value\": \"2019-02-08T15:05:10Z\",\n                    \"@type\": \"xsd:dateTimeStamp\"\n                },\n                \"knora-api:attachedToProject\": {\n                    \"@id\": \"http://rdfh.ch/projects/0001\"\n                }\n            },\n            \"knora-api:versionDate\": {\n                \"@value\": \"2019-02-08T15:05:10Z\",\n                \"@type\": \"xsd:dateTimeStamp\"\n            }\n        },\n        {\n            \"knora-api:eventType\": \"createdValue\",\n            \"knora-api:author\": {\n                \"@id\": \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n            },\n            \"knora-api:eventBody\": {\n                \"knora-api:resourceIri\": \"http://rdfh.ch/0001/thing-with-history\",\n            \"knora-api:resourceClassIri\": \"http://www.knora.org/ontology/0001/anything#Thing\",\n                \"knora-api:valueCreationDate\": {\n                    \"@value\": \"2019-02-10T10:30:10Z\",\n                    \"@type\": \"xsd:dateTimeStamp\"\n                },\n                \"knora-api:valueHasUUID\": \"IZGOjVqxTfSNO4ieKyp0SA\",\n                \"knora-api:hasPermissions\": \"V knora-admin:UnknownUser|M knora-admin:ProjectMember\",\n                \"@type\": \"knora-base:LinkValue\",\n                \"http://www.knora.org/ontology/0001/anything#hasOtherThingValue\": {\n                    \"knora-api:linkValueHasTargetIri\": {\n                        \"@id\": \"http://rdfh.ch/0001/2qMtTWvVRXWMBcRNlduvCQ\"\n                    }\n                },\n                \"rdf:Property\": \"http://www.knora.org/ontology/0001/anything#hasOtherThingValue\",\n                \"@id\": \"http://rdfh.ch/0001/thing-with-history/values/3a\"\n            },\n            \"knora-api:versionDate\": {\n                \"@value\": \"2019-02-10T10:30:10Z\",\n                \"@type\": \"xsd:dateTimeStamp\"\n            }\n        },\n        {\n            \"knora-api:eventType\": \"updatedValueContent\",\n            \"knora-api:author\": {\n                \"@id\": \"http://rdfh.ch/users/BhkfBc3hTeS_IDo-JgXRbQ\"\n            },\n            \"knora-api:eventBody\": {\n                \"knora-api:resourceIri\": \"http://rdfh.ch/0001/thing-with-history\",\n                \"knora-api:resourceClassIri\": \"http://www.knora.org/ontology/0001/anything#Thing\"\n                \"http://www.knora.org/ontology/0001/anything#hasText\": {\n                    \"knora-api:valueAsString\": \"two\"\n                },\n                \"knora-api:valueCreationDate\": {\n                    \"@value\": \"2019-02-11T10:05:10Z\",\n                    \"@type\": \"xsd:dateTimeStamp\"\n                },\n                \"knora-base:previousValue\": \"http://rdfh.ch/0001/thing-with-history/values/2a\",\n                \"knora-api:valueHasUUID\": \"W5fm67e0QDWxRZumcXcs6g\",\n                \"@type\": \"knora-base:TextValue\",\n                \"rdf:Property\": \"http://www.knora.org/ontology/0001/anything#hasText\",\n                \"@id\": \"http://rdfh.ch/0001/thing-with-history/values/2b\"\n            },\n            \"knora-api:versionDate\": {\n                \"@value\": \"2019-02-11T10:05:10Z\",\n                \"@type\": \"xsd:dateTimeStamp\"\n            }\n        },\n        {\n            \"knora-api:eventType\": \"deletedValue\",\n            \"knora-api:author\": {\n                \"@id\": \"http://rdfh.ch/users/9XBCrDV3SRa7kS1WwynB4Q\"\n            },\n            \"knora-api:eventBody\": {\n                \"knora-api:resourceIri\": \"http://rdfh.ch/0001/thing-with-history\",\n                \"knora-api:resourceClassIri\": \"http://www.knora.org/ontology/0001/anything#Thing\",\n                \"knora-base:previousValue\": \"http://rdfh.ch/0001/thing-with-history/values/3a\",\n                \"knora-api:deleteDate\": {\n                    \"@type\": \"xsd:dateTimeStamp\",\n                    \"@value\": \"2019-02-13T09:00:10Z\"\n                },\n                \"knora-api:isDeleted\": true,\n                \"@type\": \"knora-base:LinkValue\",\n                \"rdf:Property\": \"http://www.knora.org/ontology/0001/anything#hasOtherThingValue\",\n                \"@id\": \"http://rdfh.ch/0001/thing-with-history/values/3b\"\n            },\n            \"knora-api:versionDate\": {\n                \"@value\": \"2019-02-13T09:00:10Z\",\n                \"@type\": \"xsd:dateTimeStamp\"\n            }\n        }\n    ],\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\n</code></pre> <p>Since the history of changes made to the metadata of a resource is not part of resouce's version history, there are no  events describing the changes on metadata elements like its <code>rdfs:label</code> or <code>rdfs:comment</code>.  The only record depicting a change in a resource's metadata is the <code>knora-api:lastModificationDate</code> of the resource. Thus  the event <code>updatedResourceMetadata</code> indicates a change in a resource's metadata, its <code>knora-api:eventBody</code> contains the  payload needed to update the value of the resource's <code>lastModificationDate</code>, see  modifying metadata of a resource.</p>"},{"location":"03-endpoints/api-v2/reading-and-searching-resources/#get-the-full-history-of-all-resources-of-a-project-as-events","title":"Get the Full History of all Resources of a Project as Events","text":"<p>To get a list of the changes that have been made to the resources and their values of a project as events ordered by  date:</p> <pre><code>HTTP GET to http://host/v2/resources/projectHistoryEvents/&lt;projectIRI&gt;\n</code></pre> <p>The project IRI must be URL-encoded. The response contains the resource history events of all resources that belong to  the specified project.</p>"},{"location":"03-endpoints/api-v2/reading-user-permissions/","title":"Reading the User's Permissions on Resources and Values","text":"<p>In the complex API schema, each resource and value is returned with the predicate <code>knora-api:userHasPermission</code>. The object of this predicate is a string containing a permission code, which indicates the requesting user's maximum permission on the resource or value. These are the possible permission codes, in ascending order:</p> <ul> <li><code>RV</code>: restricted view permission (least privileged)</li> <li><code>V</code>: view permission</li> <li><code>M</code> modify permission</li> <li><code>D</code>: delete permission</li> <li><code>CR</code>: change rights permission (most privileged)</li> </ul> <p>Each permission implies all lesser permissions. For more details, see Permissions.</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/","title":"XML to Standoff Mapping in API v2","text":""},{"location":"03-endpoints/api-v2/text/custom-standoff/#creating-a-custom-mapping","title":"Creating a custom Mapping","text":"<p>The DSP-API's standard standoff mapping only supports a few HTML tags. In order to submit more complex XML markup, a custom mapping has to be created first. A mapping expresses the relations between XML elements and attributes, and their corresponding standoff classes and properties. The relations expressed in a mapping are one-to-one relations, so the XML can be recreated from the data in RDF. However, since HTML offers a very limited set of elements, custom mappings support the combination of element names and classes. In this way, the same element can be used several times in combination with another classname (please note that <code>&lt;a&gt;</code> without a class is a hyperlink whereas <code>&lt;a class=\"salsah-link\"&gt;</code> is an internal link/standoff link).</p> <p>With a mapping, a default XSL transformation may be provided to transform the XML to HTML before sending it back to the client. This is useful when the client is a web-browser expecting HTML (instead of XML).</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#basic-structure-of-a-mapping","title":"Basic Structure of a Mapping","text":"<p>The mapping is written in XML itself (for a formal description, see <code>webapi/src/resources/mappingXMLToStandoff.xsd</code>). It has the following structure (the indentation corresponds to the nesting in XML):</p> <ul> <li><code>&lt;mapping&gt;</code>: the root element<ul> <li><code>&lt;defaultXSLTransformation&gt; (optional)</code>: the IRI of the   default XSL transformation to be applied to the XML when   reading it back from DSP-API. The XSL transformation is   expected to produce HTML. If given, the IRI has to refer to   a resource of type <code>knora-base:XSLTransformation</code>.</li> <li><code>&lt;mappingElement&gt;</code>: an element of the mapping (at least one)<ul> <li><code>&lt;tag&gt;</code>: information about the XML element that is mapped to a standoff class<ul> <li><code>&lt;name&gt;</code>: name of the XML element</li> <li><code>&lt;class&gt;</code>: value of the class attribute of   the XML element, if any. If the element has   no class attribute, the keyword <code>noClass</code>   has to be used.</li> <li><code>&lt;namespace&gt;</code>: the namespace the XML element   belongs to, if any. If the element does not   belong to a namespace, the keyword   <code>noNamespace</code> has to be used.</li> <li><code>&lt;separatesWords&gt;</code>: a Boolean value   indicating whether this tag separates words   in the text. Once an XML document is   converted to RDF-standoff the markup is   stripped from the text, possibly leading to   continuous text that has been separated by   tags before. For structural tags like   paragraphs etc., <code>&lt;separatesWords&gt;</code> can be   set to <code>true</code> in which case a special   separator is inserted in the text in the   RDF representation. In this way, words stay   separated and are represented in the   fulltext index as such.</li> </ul> </li> <li><code>&lt;standoffClass&gt;</code>: information about the standoff class the XML element is mapped to<ul> <li><code>&lt;classIri&gt;</code>: IRI of the standoff class the XML element is mapped to</li> <li><code>&lt;attributes&gt;</code>: XML attributes to be mapped to standoff properties (other than <code>id</code> or <code>class</code>), if any<ul> <li><code>&lt;attribute&gt;</code>: an XML attribute to be mapped to a standoff property, may be repeated<ul> <li><code>&lt;attributeName&gt;</code>: the name of the XML attribute</li> <li><code>&lt;namespace&gt;</code>: the namespace the attribute belongs to, if any.    If the attribute does not belong to a namespace, the keyword <code>noNamespace</code> has to be used.</li> <li><code>&lt;propertyIri&gt;</code>: the IRI of the standoff property the XML attribute is mapped to.</li> </ul> </li> </ul> </li> <li><code>&lt;datatype&gt;</code>: the data type of the standoff class, if any.<ul> <li><code>&lt;type&gt;</code>: the IRI of the data type standoff class</li> <li><code>&lt;attributeName&gt;</code>: the name of the attribute holding the typed value in the expected standard format</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> <p>XML structure of a mapping:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;mapping&gt;\n    &lt;defaultXSLTransformation&gt;Iri of a knora-base:XSLTransformation&lt;/defaultXSLTransformation&gt;\n    &lt;mappingElement&gt;\n        &lt;tag&gt;\n            &lt;name&gt;XML element name&lt;/name&gt;\n            &lt;class&gt;XML class name or \"noClass\"&lt;/class&gt;\n            &lt;namespace&gt;XML namespace or \"noNamespace\"&lt;/namespace&gt;\n            &lt;separatesWords&gt;true or false&lt;/separatesWords&gt;\n        &lt;/tag&gt;\n        &lt;standoffClass&gt;\n            &lt;classIri&gt;standoff class Iri&lt;/classIri&gt;\n            &lt;attributes&gt;\n                &lt;attribute&gt;\n                    &lt;attributeName&gt;XML attribute name&lt;/attributeName&gt;\n                    &lt;namespace&gt;XML namespace or \"noNamespace\"&lt;/namespace&gt;\n                    &lt;propertyIri&gt;standoff property Iri&lt;/propertyIri&gt;\n                &lt;/attribute&gt;\n            &lt;/attributes&gt;\n            &lt;datatype&gt;\n                &lt;type&gt;standoff data type class&lt;/type&gt;\n                &lt;attributeName&gt;XML attribute with the typed value&lt;/attributeName&gt;\n            &lt;/datatype&gt;\n        &lt;/standoffClass&gt;\n    &lt;/mappingElement&gt;\n    &lt;mappingElement&gt;\n       ...\n    &lt;/mappingElement&gt;\n&lt;/mapping&gt;\n</code></pre> <p>Please note that the absence of an XML namespace and/or a class have to be explicitly stated using the keywords <code>noNamespace</code> and <code>noClass</code>. This is because we use XML Schema validation to ensure the one-to-one relations between XML elements and standoff classes. XML Schema validation's unique checks do not support optional values.</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#id-and-class-attributes","title":"<code>id</code> and <code>class</code> Attributes","text":"<p>The <code>id</code> and <code>class</code> attributes are supported by default and do not have to be included in the mapping like other attributes. The <code>id</code> attribute identifies an element and must be unique in the document. <code>id</code> is an optional attribute. The <code>class</code> attribute allows for the reuse of an element in the mapping, i.e. the same element can be combined with different class names and mapped to different standoff classes (mapping element <code>&lt;class&gt;</code> in <code>&lt;tag&gt;</code>).</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#respecting-cardinalities","title":"Respecting Cardinalities","text":"<p>A mapping from XML elements and attributes to standoff classes and standoff properties must respect the cardinalities defined in the ontology for those very standoff classes. If an XML element is mapped to a certain standoff class and this class requires a standoff property, an attribute must be defined for the XML element mapping to that very standoff property. Equally, all mappings for attributes of an XML element must have corresponding cardinalities for standoff properties defined for the standoff class the XML element maps to.</p> <p>However, since an XML attribute may occur once at maximum, it makes sense to make the corresponding standoff property required (<code>owl:cardinality</code> of one) in the ontology or optional (<code>owl:maxCardinality</code> of one), but not allowing it more than once.</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#standoff-data-types","title":"Standoff Data Types","text":"<p>DSP-API allows the use of all its value types as standoff data types (defined in <code>knora-base.ttl</code>):</p> <ul> <li><code>knora-base:StandoffLinkTag</code>: Represents a reference to a    resource (the IRI of the target resource must be submitted in the   data type attribute).</li> <li><code>knora-base:StandoffInternalReferenceTag</code>: Represents an internal   reference inside a document (the id of the target element inside the   same document must be indicated in the data type attribute); see   Internal References in an XML Document.</li> <li><code>knora-base:StandoffUriTag</code>: Represents a reference to a URI (the   URI of the target resource must be submitted in the data type   attribute).</li> <li><code>knora-base:StandoffDateTag</code>: Represents a date (a date   string must be submitted in the data type attribute, e.g.   <code>GREGORIAN:2017-01-27</code>).</li> <li><code>knora-base:StandoffColorTag</code>: Represents a color (a hexadecimal   RGB color string must be submitted in the data type attribute, e.g.   <code>#0000FF</code>).</li> <li><code>knora-base:StandoffIntegerTag</code>: Represents an integer (the integer   must be submitted in the data type attribute).</li> <li><code>knora-base:StandoffDecimalTag</code>: Represents a number with fractions   (the decimal number must be submitted in the data type attribute,   e.g. <code>1.1</code>).</li> <li><code>knora-base:StandoffIntervalTag</code>: Represents an interval (two   decimal numbers separated with a comma must be submitted in the data   type attribute, e.g. <code>1.1,2.2</code>).</li> <li><code>knora-base:StandoffBooleanTag</code>: Represents a Boolean value (<code>true</code>   or <code>false</code> must be submitted in the data type attribute).</li> <li><code>knora-base:StandoffTimeTag</code>: Represents a timestamp value (an <code>xsd:dateTimeStamp</code>   must be submitted in the data type attribute).</li> </ul> <p>The basic idea is that parts of a text can be marked up in a way that allows using DSP-API's built-in data types. In order to do so, the typed values have to be provided in a standardized way in an attribute that has to be defined in the mapping.</p> <p>Data type standoff classes are standoff classes with predefined properties (e.g., a <code>knora-base:StandoffLinkTag</code> has a <code>knora-base:standoffTagHasLink</code> and a <code>knora-base:StandoffIntegerTag</code> has a <code>knora-base:valueHasInteger</code>). Please note the data type standoff classes can not be combined, i.e. a standoff class can only be the subclass of one data type standoff class. However, standoff data type classes can be subclassed and extended further by assigning properties to them (see below).</p> <p>The following simple mapping illustrates this principle:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;mapping&gt;\n     &lt;mappingElement&gt;\n        &lt;tag&gt;\n            &lt;name&gt;text&lt;/name&gt;\n            &lt;class&gt;noClass&lt;/class&gt;\n            &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n            &lt;separatesWords&gt;false&lt;/separatesWords&gt;\n        &lt;/tag&gt;\n        &lt;standoffClass&gt;\n            &lt;classIri&gt;http://www.knora.org/ontology/standoff#StandoffRootTag&lt;/classIri&gt;\n        &lt;/standoffClass&gt;\n    &lt;/mappingElement&gt;\n\n    &lt;mappingElement&gt;\n        &lt;tag&gt;\n            &lt;name&gt;mydate&lt;/name&gt;\n            &lt;class&gt;noClass&lt;/class&gt;\n            &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n            &lt;separatesWords&gt;false&lt;/separatesWords&gt;\n        &lt;/tag&gt;\n        &lt;standoffClass&gt;\n            &lt;classIri&gt;http://www.knora.org/ontology/0001/anything#StandoffEventTag&lt;/classIri&gt;\n            &lt;attributes&gt;\n                &lt;attribute&gt;\n                    &lt;attributeName&gt;description&lt;/attributeName&gt;\n                    &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n                    &lt;propertyIri&gt;http://www.knora.org/ontology/0001/anything#standoffEventTagHasDescription&lt;/propertyIri&gt;\n                &lt;/attribute&gt;\n            &lt;/attributes&gt;\n            &lt;datatype&gt;\n                &lt;type&gt;http://www.knora.org/ontology/knora-base#StandoffDateTag&lt;/type&gt;\n                &lt;attributeName&gt;knoraDate&lt;/attributeName&gt;\n            &lt;/datatype&gt;\n        &lt;/standoffClass&gt;\n    &lt;/mappingElement&gt;\n&lt;/mapping&gt;\n</code></pre> <p><code>&lt;datatype&gt;</code> must hold the IRI of a standoff data type class (see list above). The <code>&lt;classIri&gt;</code> must be a subclass of this type or this type itself (the latter is probably not recommendable since semantics are missing: what is the meaning of the date?). In the example above, the standoff class is <code>anything:StandoffEventTag</code> which has the following definition in the ontology <code>anything-onto.ttl</code>:</p> <pre><code>anything:StandoffEventTag rdf:type owl:Class ;\n\n    rdfs:subClassOf knora-base:StandoffDateTag,\n                   [\n                      rdf:type owl:Restriction ;\n                      owl:onProperty :standoffEventTagHasDescription ;\n                      owl:cardinality \"1\"^^xsd:nonNegativeInteger\n                   ] ;\n\n    rdfs:label \"Represents an event in a TextValue\"@en ;\n\n    rdfs:comment \"\"\"Represents an event in a TextValue\"\"\"@en .\n</code></pre> <p><code>anything:StandoffEventTag</code> is a subclass of <code>knora-base:StandoffDateTag</code> and therefore has the data type date. It also requires the standoff property <code>anything:standoffEventTagHasDescription</code> which is defined as an attribute in the mapping.</p> <p>Once the mapping has been created, an XML like the following could be sent to DSP-API and converted to standoff:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;text&gt;\n    We had a party on &lt;mydate description=\"new year\" knoraDate=\"GREGORIAN:2016-12-31\"&gt;New Year's Eve&lt;/mydate&gt;. \n    It was a lot of fun.\n&lt;/text&gt;\n</code></pre> <p>The attribute holds the date in the format of a DSP-API date string (the format is also documented in the typescript type alias <code>dateString</code> in module <code>basicMessageComponents</code>. There you will also find documentation about the other types like color etc.). DSP-API date strings have this format: <code>GREGORIAN|JULIAN):YYYY[-MM[-DD]][:YYYY[-MM[-DD]]]</code>. This allows for different formats as well as for imprecision and periods. Intervals are submitted as one attribute in the following format: <code>interval-attribute=\"1.0,2.0\"</code> (two decimal numbers separated with a comma).</p> <p>You will find a sample mapping with all the data types and a sample XML file in the the test data: <code>test_data/test_route/texts/mappingForHTML.xml</code> and <code>test_data/test_route/texts/HTML.xml</code>.</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#internal-references-in-an-xml-document","title":"Internal References in an XML Document","text":"<p>Internal references inside an XML document can be represented using the data type standoff class <code>knora-base:StandoffInternalReferenceTag</code> or a subclass of it. This class has a standoff property that points to a standoff node representing the target XML element when converted to RDF.</p> <p>The following example shows the definition of a mapping element for an internal reference (for reasons of simplicity, only the mapping element for the element is question is depicted):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;mappingElement&gt;\n    &lt;tag&gt;\n        &lt;name&gt;ref&lt;/name&gt;\n        &lt;class&gt;noClass&lt;/class&gt;\n        &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n        &lt;separatesWords&gt;false&lt;/separatesWords&gt;\n    &lt;/tag&gt;\n    &lt;standoffClass&gt;\n        &lt;classIri&gt;http://www.knora.org/ontology/knora-base#StandoffInternalReferenceTag&lt;/classIri&gt;\n        &lt;datatype&gt;\n            &lt;type&gt;http://www.knora.org/ontology/knora-base#StandoffInternalReferenceTag&lt;/type&gt;\n            &lt;attributeName&gt;internalRef&lt;/attributeName&gt;\n        &lt;/datatype&gt;\n    &lt;/standoffClass&gt;\n&lt;/mappingElement&gt;\n</code></pre> <p>Now, an internal reference to an element in the same document can be made that will be converted to a pointer in RDF:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;text&gt;\n    This is an &lt;sample id=\"1\"&gt;element&lt;/sample&gt; and here is a reference to &lt;ref internalRef=\"#1\"&gt;it&lt;/ref&gt;.\n&lt;/text&gt;\n</code></pre> <p>An internal reference in XML has to start with a <code>#</code> followed by the value of the <code>id</code> attribute of the element referred to.</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#predefined-standoff-classes-and-properties","title":"Predefined Standoff Classes and Properties","text":"<p>The standoff ontology <code>standoff-onto.ttl</code> offers a set of predefined standoff classes that can be used in a custom mapping like the following:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;mapping&gt;\n    &lt;mappingElement&gt;\n        &lt;tag&gt;\n            &lt;name&gt;myDoc&lt;/name&gt;\n            &lt;class&gt;noClass&lt;/class&gt;\n            &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n            &lt;separatesWords&gt;false&lt;/separatesWords&gt;\n        &lt;/tag&gt;\n        &lt;standoffClass&gt;\n            &lt;classIri&gt;http://www.knora.org/ontology/standoff#StandoffRootTag&lt;/classIri&gt;\n            &lt;attributes&gt;\n                &lt;attribute&gt;\n                    &lt;attributeName&gt;documentType&lt;/attributeName&gt;\n                    &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n                    &lt;propertyIri&gt;http://www.knora.org/ontology/standoff#standoffRootTagHasDocumentType&lt;/propertyIri&gt;\n                &lt;/attribute&gt;\n            &lt;/attributes&gt;\n        &lt;/standoffClass&gt;\n    &lt;/mappingElement&gt;\n\n    &lt;mappingElement&gt;\n        &lt;tag&gt;\n            &lt;name&gt;p&lt;/name&gt;\n            &lt;class&gt;noClass&lt;/class&gt;\n            &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n            &lt;separatesWords&gt;true&lt;/separatesWords&gt;\n        &lt;/tag&gt;\n        &lt;standoffClass&gt;\n            &lt;classIri&gt;http://www.knora.org/ontology/standoff#StandoffParagraphTag&lt;/classIri&gt;\n        &lt;/standoffClass&gt;\n    &lt;/mappingElement&gt;\n\n    &lt;mappingElement&gt;\n        &lt;tag&gt;\n            &lt;name&gt;i&lt;/name&gt;\n            &lt;class&gt;noClass&lt;/class&gt;\n            &lt;namespace&gt;noNamespace&lt;/namespace&gt;\n            &lt;separatesWords&gt;false&lt;/separatesWords&gt;\n        &lt;/tag&gt;\n        &lt;standoffClass&gt;\n            &lt;classIri&gt;http://www.knora.org/ontology/standoff#StandoffItalicTag&lt;/classIri&gt;\n        &lt;/standoffClass&gt;\n    &lt;/mappingElement&gt;\n&lt;/mapping&gt;\n</code></pre> <p>Predefined standoff classes may be used by various projects, each providing a custom mapping to be able to recreate the original XML from RDF. Predefined standoff classes may also be inherited and extended in project specific ontologies.</p> <p>The mapping above allows for an XML like this:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;myDoc documentType=\"letter\"&gt;\n    &lt;p&gt;\n        This my text that is &lt;i&gt;very&lt;/i&gt; interesting.\n    &lt;/p&gt;\n    &lt;p&gt;\n        And here it goes on.\n    &lt;/p&gt;\n&lt;/myDoc&gt;\n</code></pre>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#respecting-property-types","title":"Respecting Property Types","text":"<p>When mapping XML attributes to standoff properties, attention has to be paid to the properties' object constraints.</p> <p>In the ontology, standoff property literals may have one of the following <code>knora-base:objectDatatypeConstraint</code>:</p> <ul> <li><code>xsd:string</code></li> <li><code>xsd:integer</code></li> <li><code>xsd:boolean</code></li> <li><code>xsd:decimal</code></li> <li><code>xsd:anyURI</code></li> </ul> <p>In XML, all attribute values are submitted as strings. However, these string representations need to be convertible to the types defined in the ontology. If they are not, the request will be rejected. It is recommended to enforce types on attributes by applying XML Schema validations (restrictions).</p> <p>Links (object property) to a <code>knora-base:Resource</code> can be represented using the data type standoff class <code>knora-base:StandoffLinkTag</code>, internal links using the data type standoff class <code>knora-base:StandoffInternalReferenceTag</code>.</p>"},{"location":"03-endpoints/api-v2/text/custom-standoff/#validating-a-mapping-and-sending-it-to-dsp-api","title":"Validating a Mapping and sending it to DSP-API","text":"<p>A mapping can be validated before sending it to DSP-API with the following XML Schema file: <code>webapi/src/resources/mappingXMLToStandoff.xsd</code>. Any mapping that does not conform to this XML Schema file will be rejected by DSP-API.</p> <p>The mapping has to be sent as a multipart request to the standoff route using the path segment <code>mapping</code>:</p> <pre><code>HTTP POST http://host/v2/mapping\n</code></pre> <p>The multipart request consists of two named parts:</p> <pre><code>\"json\":\n\n  {\n      \"knora-api:mappingHasName\": \"My Mapping\",\n      \"knora-api:attachedToProject\": \"projectIRI\",\n      \"rdfs:label\": \"MappingNameSegment\",\n      \"@context\": {\n          \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n          \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n      }\n  }\n\n\"xml\":\n\n  &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n  &lt;mapping&gt;\n      ...\n  &lt;/mapping&gt;\n</code></pre> <p>A successful response returns the IRI of the mapping. However, the IRI of a mapping is predictable: it consists of the project Iri followed by <code>/mappings/</code> and the <code>knora-api:mappingHasName</code> submitted in the JSON-LD (if the name already exists, the request will be rejected). Once created, a mapping can be used to create TextValues in Knora. The formats are documented in the v2 typescript interfaces <code>AddMappingRequest</code> and <code>AddMappingResponse</code> in module <code>MappingFormats</code></p>"},{"location":"03-endpoints/api-v2/text/overview/","title":"Overview","text":"<p>DSP-API supports various ways of handling textual data:</p>"},{"location":"03-endpoints/api-v2/text/overview/#text-in-rdf","title":"Text in RDF","text":"<p>Textual data can be included directly in the data stored in DSP-API.  This is the default way of handling text in the DSP.  There are three ways of representing textual data in DSP-API, two of which are fully supported by DSP-APP and DSP-TOOLS.</p> <p>Texts stored in RDF can be searched using both full-text search and structured queries.</p>"},{"location":"03-endpoints/api-v2/text/overview/#simple-text","title":"Simple Text","text":"<p>If a text requires no formatting, it can simply be stored as a string in a <code>knora-base:TextValue</code>.  This is sufficient in many cases, especially for shorter texts like names, titles, identifiers, etc.</p>"},{"location":"03-endpoints/api-v2/text/overview/#text-with-formatting","title":"Text with Formatting","text":"<p>For text requiring regular markup, <code>knora-base:TextValue</code> can be used  in combination with the DSP's standard standoff markup.</p> <p>This allows for the following markup:</p> <ul> <li>structural markup<ul> <li>paragraphs</li> <li>headings levels 1-6</li> <li>ordered lists</li> <li>unordered lists</li> <li>tables</li> <li>line breaks</li> <li>horizontal rules</li> <li>code blocks</li> <li>block quotes</li> <li>footnotes</li> </ul> </li> <li>typographical markup<ul> <li>italics</li> <li>bold</li> <li>underline</li> <li>strikethrough</li> <li>subscript</li> <li>superscript</li> </ul> </li> <li>semantic markup<ul> <li>links</li> <li>DSP internal links</li> </ul> </li> </ul> <p>DSP-APP provides a text editor for conveniently editing text with standard standoff markup.</p> <p>More details can be found the standard standoff documentation.</p>"},{"location":"03-endpoints/api-v2/text/overview/#text-with-custom-markup","title":"Text with Custom Markup","text":"<p>It is possible to create custom XML-to-Schema mappings, which allows for creating project specific custom markup for text values.  Details can be found in the custom standoff documentation.</p> <p>Info</p> <p>Custom markup is not supported by DSP-TOOLS and is view-only in DSP-APP. Creating custom markup is relatively involved,  so that it should only be used by projects working with complex textual data.</p>"},{"location":"03-endpoints/api-v2/text/overview/#file-based","title":"File Based","text":"<p>Text files of various formats (Word, PDF, XML, etc.) can be uploaded to the media file server.  For more details, see the file formats documentation</p> <p>This allows for easy upload and retrieval of the file.  However, it does not allow for searching within the file content.</p>"},{"location":"03-endpoints/api-v2/text/overview/#tei-xml","title":"TEI XML","text":"<p>All text values in DSP-API using standoff markup can be converted to TEI XML as described in the tei xml documentation.</p> <p>Info</p> <p>Improved support for TEI XML is in planning.</p>"},{"location":"03-endpoints/api-v2/text/standard-standoff/","title":"Standard Standoff Markup Mapping","text":"<p>A mapping allows for the conversion of XML to standoff representation in RDF and back.  In order to create a <code>TextValue</code> with markup,  the text has to be provided in XML format,  along with the IRI of the mapping that will be used to convert the markup to standoff.</p> <p>DSP-API offers a standard mapping with the IRI <code>http://rdfh.ch/standoff/mappings/StandardMapping</code>.  The standard mapping covers the HTML elements and attributes  supported by the GUI's text editor, CKEditor.  (Please note that the HTML has to be encoded in strict XML syntax.  CKeditor offers the possibility to define filter rules. They should reflect the elements supported by the mapping.) The standard mapping contains the following elements and attributes  that are mapped to standoff classes and properties defined in the ontology:</p> <ul> <li><code>&lt;text&gt;</code> \u2192 <code>standoff:StandoffRootTag</code></li> <li><code>&lt;p&gt;</code> \u2192 <code>standoff:StandoffParagraphTag</code></li> <li><code>&lt;em&gt;</code> \u2192 <code>standoff:StandoffItalicTag</code></li> <li><code>&lt;strong&gt;</code> \u2192 <code>standoff:StandoffBoldTag</code></li> <li><code>&lt;u&gt;</code> \u2192 <code>standoff:StandoffUnderlineTag</code></li> <li><code>&lt;sub&gt;</code> \u2192 <code>standoff:StandoffSubscriptTag</code></li> <li><code>&lt;sup&gt;</code> \u2192 <code>standoff:StandoffSuperscriptTag</code></li> <li><code>&lt;strike&gt;</code> \u2192 <code>standoff:StandoffStrikeTag</code></li> <li><code>&lt;a href=\"URL\"&gt;</code> \u2192 <code>knora-base:StandoffUriTag</code></li> <li><code>&lt;a class=\"salsah-link\" href=\"Knora IRI\"&gt;</code> \u2192 <code>knora-base:StandoffLinkTag</code></li> <li><code>&lt;a class=\"internal-link\" href=\"#fragment\"&gt;</code> \u2192 <code>knora-base:StandoffInternalReferenceTag</code></li> <li><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code> \u2192 <code>standoff:StandoffHeader1Tag</code> to <code>standoff:StandoffHeader6Tag</code></li> <li><code>&lt;ol&gt;</code> \u2192 <code>standoff:StandoffOrderedListTag</code></li> <li><code>&lt;ul&gt;</code> \u2192 <code>standoff:StandoffUnrderedListTag</code></li> <li><code>&lt;li&gt;</code> \u2192 <code>standoff:StandoffListElementTag</code></li> <li><code>&lt;tbody&gt;</code> \u2192 <code>standoff:StandoffTableBodyTag</code></li> <li><code>&lt;thead&gt;</code> \u2192 <code>standoff:StandoffTableHeaderTag</code></li> <li><code>&lt;table&gt;</code> \u2192 <code>standoff:StandoffTableTag</code></li> <li><code>&lt;tr&gt;</code> \u2192 <code>standoff:StandoffTableRowTag</code></li> <li><code>&lt;th&gt;</code> \u2192 <code>standoff:StandoffTableHeaderCellTag</code></li> <li><code>&lt;td&gt;</code> \u2192 <code>standoff:StandoffTableCellTag</code></li> <li><code>&lt;br&gt;</code> \u2192 <code>standoff:StandoffBrTag</code></li> <li><code>&lt;hr&gt;</code> \u2192 <code>standoff:StandoffLineTag</code></li> <li><code>&lt;pre&gt;</code> \u2192 <code>standoff:StandoffPreTag</code></li> <li><code>&lt;cite&gt;</code> \u2192 <code>standoff:StandoffCiteTag</code></li> <li><code>&lt;blockquote&gt;</code> \u2192 <code>standoff:StandoffBlockquoteTag</code></li> <li><code>&lt;code&gt;</code> \u2192 <code>standoff:StandoffCodeTag</code></li> <li><code>&lt;footnote content=\"footnote text\"&gt;</code> \u2192 <code>standoff:StandoffFootnoteTag</code></li> </ul> <p>The HTML produced by CKEditor is wrapped in an XML doctype and a pair of root tags <code>&lt;text&gt;...&lt;/text&gt;</code>  and then sent to the DSP-API. The XML sent to the GUI by the DSP-API is unwrapped accordingly. Although the GUI supports HTML5, it is treated as if it was XHTML in strict XML notation.</p> <p>Text with standard standoff markup can be transformed to TEI XML as described in the tei xml documentation.</p>"},{"location":"03-endpoints/api-v2/text/standard-standoff/#footnotes","title":"Footnotes","text":"<p>The <code>&lt;footnote&gt;</code> tag is an anchor tag indicating where in the text a footnote should be placed. It must not contain any text or other tags.</p> <p>The contents of the footnote are stored in the <code>content</code> attribute of the <code>&lt;footnote&gt;</code> tag. These may contain further markup, so the content of the footnote must be valid XML.</p> <p>In order to result in valid xml, the content of the footnote must be properly escaped so that it does not contain any characters that are not allowed in XML. Special characters like <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>\"</code>, and <code>'</code> must be replaced by their respective XML entities, i.e. <code>&amp;lt;</code>, <code>&amp;gt;</code>, <code>&amp;amp;</code>, <code>&amp;quot;</code>, and <code>&amp;apos;</code>.</p> <p>The following example shows how a footnote is used in the XML:</p> <pre><code>&lt;text&gt;\n  &lt;p&gt;\n    Some text with a \n    footnote&lt;footnote content=\"Text with &amp;lt;a href=&amp;quot;...&amp;quot;&amp;gt;markup&amp;lt;/a&amp;gt;.\" /&gt; \n    in it.\n  &lt;/p&gt;\n&lt;/text&gt;\n</code></pre> <p>Note: Footnote support is still in an early stage, and may change in the future. There are some known limitations:</p> <ul> <li>CKE does not support footnotes out of the box. DSP-APP uses a custom build of CKE that supports footnotes.</li> <li>The content of footnotes is not covered by the full text search.</li> <li>The content of footnotes may contain further markup, but this will not be converted to standoff by the API.   For that reason, markup in footnotes can not be searched for through gravsearch   and hence outgoing and incoming links will not be displayed in DSP-APP.</li> </ul>"},{"location":"03-endpoints/api-v2/text/tei-xml/","title":"TEI/XML: Converting Standoff to TEI/XML","text":""},{"location":"03-endpoints/api-v2/text/tei-xml/#general","title":"General","text":"<p>DSP-API offers a way to convert standoff markup to TEI/XML. The conversion is based on the assumption that a whole resource is to be turned into a TEI document. There is a basic distinction between the body and the header of a TEI document. The resource's property that contains the text with standoff markup is mapped to the TEI document's body. Other of the resource's property may be mapped to the TEI header.</p>"},{"location":"03-endpoints/api-v2/text/tei-xml/#standard-standoff-to-tei-conversion","title":"Standard Standoff to TEI Conversion","text":"<p>DSP-API offers a built-in conversion form standard standoff entities (defined in the <code>standoff</code> ontology) tags to TEI.</p> <p>Note</p> <p>As TEI provides a wide range of Elements and Attributes  which can have different meaning depending on the markup practices of a project, whereas DSP standard standoff has a very limited tagset, this conversion is oppinionated by necessity and may not be appropriate for all projects.</p> <p>In order to obtain a resource as a TEI document, the following request has to be performed.  Please note that the URL parameters have to be URL-encoded.</p> <pre><code>HTTP GET to http://host/v2/tei/resourceIri?textProperty=textPropertyIri\n</code></pre> <p>In addition to the resource's Iri, the Iri of the property containing the text with standoff has to be submitted.  This will be converted to the TEI body.  Please note that the resource can only have one instance of this property and the text must have standoff markup.</p> <p>The test data contain the resource <code>http://rdfh.ch/0001/thing_with_richtext_with_markup</code>  with the text property <code>http://0.0.0.0:3333/ontology/0001/anything/v2#hasRichtext</code>  that can be converted to TEI as follows:</p> <pre><code>HTTP GET to http://host/v2/tei/http%3A%2F%2Frdfh.ch%2F0001%2Fthing_with_richtext_with_markup?textProperty=http%3A%2F%2F0.0.0.0%3A3333%2Fontology%2F0001%2Fanything%2Fv2%23hasRichtext\n</code></pre> <p>The response to this request is a TEI XML document:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;TEI xmlns=\"http://www.tei-c.org/ns/1.0\" version=\"3.3.0\"&gt;\n  &lt;teiHeader&gt;\n    &lt;fileDesc&gt;\n      &lt;titleStmt&gt;\n        &lt;title&gt;test thing with markup&lt;/title&gt;\n      &lt;/titleStmt&gt;\n      &lt;publicationStmt&gt;\n        &lt;p&gt;\n             This is the TEI/XML representation of a resource identified by the Iri http://rdfh.ch/0001/thing_with_richtext_with_markup.\n         &lt;/p&gt;\n      &lt;/publicationStmt&gt;\n      &lt;sourceDesc&gt;\n        &lt;p&gt;Representation of the resource's text as TEI/XML&lt;/p&gt;\n      &lt;/sourceDesc&gt;\n    &lt;/fileDesc&gt;\n  &lt;/teiHeader&gt;\n  &lt;text&gt;\n    &lt;body&gt;\n      &lt;p&gt;\n        This is a test that contains marked up elements. \n        This is &lt;hi rend=\"italic\"&gt;interesting text&lt;/hi&gt; in italics.\n        This is &lt;hi rend=\"italic\"&gt;boring text&lt;/hi&gt; in italics.\n      &lt;/p&gt;\n    &lt;/body&gt;\n  &lt;/text&gt;\n&lt;/TEI&gt;        \n</code></pre> <p>The body of the TEI document contains the standoff markup as XML.  The header contains contains some basic metadata about the resource such as the <code>rdfs:label</code> an its IRI.  However, this might not be sufficient for more advanced use cases like digital edition projects.  In that case, a custom conversion has to be performed (see below).</p>"},{"location":"03-endpoints/api-v2/text/tei-xml/#custom-conversion","title":"Custom Conversion","text":"<p>If a project defines its own standoff entities, a custom conversion can be provided (body of the TEI document).  Also for the TEI header, a custom conversion can be provided.</p> <p>For the custom conversion, additional configuration is required.</p> <p>TEI body:</p> <ul> <li>additional mapping from standoff to XML (URL parameter <code>mappingIri</code>)</li> <li>XSL transformation to turn the XML into a valid TEI body (referred to by the mapping).</li> </ul> <p>The mapping has to refer to a <code>defaultXSLTransformation</code> that transforms the XML that was created from standoff markup  (see XML To Standoff Mapping).  This step is necessary because the mapping assumes a one to one relation  between standoff classes and properties and XML elements and attributes. For example, we may want to convert a <code>standoff:StandoffItalicTag</code> into TEI/XML.  TEI expresses this as <code>&lt;hi rend=\"italic\"&gt;...&lt;/hi&gt;</code>.  In the mapping, the <code>standoff:StandoffItalicTag</code> may be mapped to a temporary XML element  that is going to be converted to <code>&lt;hi rend=\"italic\"&gt;...&lt;/hi&gt;</code> in a further step by the XSLT. </p> <p>For sample data, see <code>webapi/_test_data/test_route/texts/beol/BEOLTEIMapping.xml</code> (mapping)  and <code>webapi/_test_data/test_route/texts/beol/standoffToTEI.xsl</code>.  The standoff entities are defined in <code>beol-onto.ttl</code>.</p> <p>TEI header:</p> <ul> <li>Gravsearch template to query the resources metadata, results are serialized to RDF/XML (URL parameter <code>gravsearchTemplateIri</code>)</li> <li>XSL transformation to turn that RDF/XML into a valid TEI header (URL parameter <code>teiHeaderXSLTIri</code>)</li> </ul> <p>The Gravsearch template is expected to be of type <code>knora-base:TextRepresentation</code>  and to contain a placeholder <code>$resourceIri</code> that is to be replaced by the actual resource Iri. The Gravsearch template is expected to contain a query involving the text property (URL parameter <code>textProperty</code>)  and more properties that are going to be mapped to the TEI header.  The Gravsearch template is a simple text file with the files extension <code>.txt</code>.</p> <p>A Gravsearch template may look like this (see <code>test_data/test_route/texts/beol/gravsearch.txt</code>):</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\nPREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;\n\n    CONSTRUCT {\n        ?letter knora-api:isMainResource true .\n\n        ?letter beol:creationDate ?date .\n\n        ?letter beol:hasText ?text .\n\n        ?letter beol:hasAuthor ?person1 .\n\n        ?person1 beol:hasFamilyName ?name1 .\n\n        ?person1 beol:hasGivenName ?givenName1 .\n\n        ?person1 beol:hasIAFIdentifier ?iaf1 .\n\n        ?letter beol:hasRecipient ?person2 .\n\n        ?person2 beol:hasFamilyName ?name2 .\n\n        ?person2 beol:hasGivenName ?givenName2 .\n\n        ?person2 beol:hasIAFIdentifier ?iaf2 .\n\n\n    } WHERE {\n        BIND(&lt;$resourceIri&gt; as ?letter)\n        ?letter a knora-api:Resource .\n        ?letter a beol:letter .\n\n        ?letter beol:creationDate ?date .\n\n        beol:creationDate knora-api:objectType knora-api:Date .\n        ?date a knora-api:Date .\n\n        ?letter beol:hasText ?text .\n\n        beol:hasText knora-api:objectType xsd:string .\n\n        ?text a xsd:string .\n\n        ?letter beol:hasAuthor ?person1 .\n\n        ?person1 beol:hasFamilyName ?name1 .\n\n        ?person1 beol:hasGivenName ?givenName1 .\n\n        ?person1 beol:hasIAFIdentifier ?iaf1 .\n\n        ?name1 a xsd:string .\n\n        ?givenName1 a xsd:string .\n\n        ?iaf1 a xsd:string .\n\n        ?person2 beol:hasFamilyName ?name2 .\n\n        ?person2 beol:hasGivenName ?givenName2 .\n\n        ?person2 beol:hasIAFIdentifier ?iaf2 .\n\n        ?name2 a xsd:string .\n\n        ?givenName2 a xsd:string .\n\n        ?iaf2 a xsd:string .\n\n        beol:hasGivenName knora-api:objectType xsd:string .\n        beol:hasFamilyName knora-api:objectType xsd:string .\n        beol:hasIAFIdentifier knora-api:objectType xsd:string .\n\n        beol:hasAuthor knora-api:objectType knora-api:Resource .\n\n        ?letter beol:hasRecipient ?person2 .\n\n        beol:hasRecipient knora-api:objectType knora-api:Resource .\n\n        ?person1 a knora-api:Resource .\n        ?person2 a knora-api:Resource .\n\n    }\n</code></pre> <p>Note the placeholder <code>BIND(&lt;$resourceIri&gt; as ?letter)</code> that is going to be replaced  by the Iri of the resource the request is performed for. The query asks for information about the letter's text <code>beol:hasText</code> and information about its author and recipient.  This information is converted to the TEI header in the format required by correspSearch.</p> <p>To write the XSLT, do the Gravsearch query and request the data as RDF/XML using content negotiation  (see Introduction).</p> <p>The Gravsearch query's result may look like this (<code>RDF/XML</code>):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;rdf:RDF\n    xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n    xmlns:rdfs=\"http://www.w3.org/2000/01/rdf-schema#\"\n    xmlns:knora-api=\"http://api.knora.org/ontology/knora-api/v2#\"\n    xmlns:beol=\"http://0.0.0.0:3333/ontology/0801/beol/v2#\"&gt;\n&lt;beol:letter rdf:about=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA\"&gt;\n    &lt;beol:creationDate rdf:resource=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA/values/Ob_1YRO_QmaDxTRI64vGOQ\"/&gt;\n    &lt;beol:hasAuthorValue rdf:resource=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA/values/zt4a3XoESTq9To4mSN8Dug\"/&gt;\n    &lt;beol:hasRecipientValue rdf:resource=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA/values/pVerHO_FRXePZQT9kgEp_Q\"/&gt;\n    &lt;rdfs:label rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Testletter&lt;/rdfs:label&gt;\n&lt;/beol:letter&gt;\n&lt;knora-api:DateValue rdf:about=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA/values/Ob_1YRO_QmaDxTRI64vGOQ\"&gt;\n    &lt;knora-api:dateValueHasCalendar rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;GREGORIAN&lt;/knora-api:dateValueHasCalendar&gt;\n    &lt;knora-api:dateValueHasEndDay rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\"&gt;10&lt;/knora-api:dateValueHasEndDay&gt;\n    &lt;knora-api:dateValueHasEndEra rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;CE&lt;/knora-api:dateValueHasEndEra&gt;\n    &lt;knora-api:dateValueHasEndMonth rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\"&gt;6&lt;/knora-api:dateValueHasEndMonth&gt;\n    &lt;knora-api:dateValueHasEndYear rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\"&gt;1703&lt;/knora-api:dateValueHasEndYear&gt;\n    &lt;knora-api:dateValueHasStartDay rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\"&gt;10&lt;/knora-api:dateValueHasStartDay&gt;\n    &lt;knora-api:dateValueHasStartEra rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;CE&lt;/knora-api:dateValueHasStartEra&gt;\n    &lt;knora-api:dateValueHasStartMonth rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\"&gt;6&lt;/knora-api:dateValueHasStartMonth&gt;\n    &lt;knora-api:dateValueHasStartYear rdf:datatype=\"http://www.w3.org/2001/XMLSchema#integer\"&gt;1703&lt;/knora-api:dateValueHasStartYear&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;GREGORIAN:1703-06-10 CE&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:DateValue&gt;\n&lt;knora-api:LinkValue rdf:about=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA/values/zt4a3XoESTq9To4mSN8Dug\"&gt;\n    &lt;knora-api:linkValueHasTarget&gt;\n        &lt;beol:person rdf:about=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ\"&gt;\n            &lt;beol:hasFamilyName rdf:resource=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ/values/NG42jDqSTz2U35N6sJ8cqg\"/&gt;\n            &lt;beol:hasGivenName rdf:resource=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ/values/W2lVG1mvQU2MauAvCGB13w\"/&gt;\n            &lt;beol:hasIAFIdentifier rdf:resource=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ/values/N2TVtntdToqJQpdZhYPc5g\"/&gt;\n            &lt;rdfs:label rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Johann Jacob Scheuchzer&lt;/rdfs:label&gt;\n        &lt;/beol:person&gt;\n    &lt;/knora-api:linkValueHasTarget&gt;\n&lt;/knora-api:LinkValue&gt;\n&lt;knora-api:TextValue rdf:about=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ/values/NG42jDqSTz2U35N6sJ8cqg\"&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Scheuchzer&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:TextValue&gt;\n&lt;knora-api:TextValue rdf:about=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ/values/W2lVG1mvQU2MauAvCGB13w\"&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Johann Jacob&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:TextValue&gt;\n&lt;knora-api:TextValue rdf:about=\"http://rdfh.ch/0801/_9LEnLM7TFuPRjTshOTJpQ/values/N2TVtntdToqJQpdZhYPc5g\"&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;(DE-588)118607308&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:TextValue&gt;\n&lt;knora-api:LinkValue rdf:about=\"http://rdfh.ch/0801/MbZdHVcsR_Ky5pZoytaiBA/values/pVerHO_FRXePZQT9kgEp_Q\"&gt;\n    &lt;knora-api:linkValueHasTarget&gt;\n        &lt;beol:person rdf:about=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw\"&gt;\n            &lt;beol:hasFamilyName rdf:resource=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw/values/k1Exqf93SsWi7LWK9ozXkw\"/&gt;\n            &lt;beol:hasGivenName rdf:resource=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw/values/gkqK5Ij_R7mtO59xfSDGJA\"/&gt;\n            &lt;beol:hasIAFIdentifier rdf:resource=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw/values/C-Dl15S-SV63L1KCCPFfew\"/&gt;\n            &lt;rdfs:label rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Jacob Hermann&lt;/rdfs:label&gt;\n        &lt;/beol:person&gt;\n    &lt;/knora-api:linkValueHasTarget&gt;\n&lt;/knora-api:LinkValue&gt;\n&lt;knora-api:TextValue rdf:about=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw/values/k1Exqf93SsWi7LWK9ozXkw\"&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Hermann&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:TextValue&gt;\n&lt;knora-api:TextValue rdf:about=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw/values/gkqK5Ij_R7mtO59xfSDGJA\"&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;Jacob&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:TextValue&gt;\n&lt;knora-api:TextValue rdf:about=\"http://rdfh.ch/0801/JaQwPsYEQJ6GQrAgKC0Gkw/values/C-Dl15S-SV63L1KCCPFfew\"&gt;\n    &lt;knora-api:valueAsString rdf:datatype=\"http://www.w3.org/2001/XMLSchema#string\"&gt;(DE-588)119112450&lt;/knora-api:valueAsString&gt;\n&lt;/knora-api:TextValue&gt;\n\n&lt;/rdf:RDF&gt;\n</code></pre> <p>In order to convert the metadata (not the actual standoff markup),  a <code>knora-base:knora-base:XSLTransformation</code> has to be provided.  For our example, it looks like this (see <code>test_data/test_route/texts/beol/header.xsl</code>):</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xsl:transform xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n               xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n               xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n               xmlns:rdfs1=\"http://www.w3.org/2000/01/rdf-schema#\"\n               xmlns:beol=\"http://0.0.0.0:3333/ontology/0801/beol/v2#\"\n               xmlns:knora-api=\"http://api.knora.org/ontology/knora-api/v2#\"\n               exclude-result-prefixes=\"rdf beol knora-api xs rdfs1\" version=\"2.0\"&gt;\n\n    &lt;xsl:output method=\"xml\" omit-xml-declaration=\"yes\" encoding=\"utf-8\" indent=\"yes\"/&gt;\n\n    &lt;!-- make IAF id a URL --&gt;\n    &lt;xsl:function name=\"knora-api:iaf\" as=\"xs:anyURI\"&gt;\n        &lt;xsl:param name=\"input\" as=\"xs:string\"/&gt;\n        &lt;xsl:value-of select=\"replace($input, '\\(DE-588\\)', 'http://d-nb.info/gnd/')\"/&gt;\n    &lt;/xsl:function&gt;\n\n    &lt;!-- make a standard date (Gregorian calendar assumed) --&gt;\n    &lt;xsl:function name=\"knora-api:dateformat\" as=\"element()*\"&gt;\n        &lt;xsl:param name=\"input\" as=\"element()*\"/&gt;\n\n        &lt;xsl:choose&gt;\n            &lt;xsl:when test=\"$input/knora-api:dateValueHasStartYear/text() = $input/knora-api:dateValueHasEndYear/text() and $input/knora-api:dateValueHasStartMonth/text() = $input/knora-api:dateValueHasEndMonth/text() and $input/knora-api:dateValueHasStartDay/text() = $input/knora-api:dateValueHasEndDay/text()\"&gt;\n                &lt;!-- no period, day precision --&gt;\n                &lt;date&gt;\n                    &lt;xsl:attribute name=\"when\"&gt;\n                        &lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasStartYear/text(), '0000')\"/&gt;-&lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasStartMonth/text(), '00')\"/&gt;-&lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasStartMonth/text(), '00')\"/&gt;\n                    &lt;/xsl:attribute&gt;\n                &lt;/date&gt;\n\n            &lt;/xsl:when&gt;\n            &lt;xsl:otherwise&gt;\n                &lt;!-- period --&gt;\n                &lt;date&gt;\n                    &lt;xsl:attribute name=\"notBefore\"&gt;\n                        &lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasStartYear/text(), '0000')\"/&gt;-&lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasStartMonth/text(), '00')\"/&gt;-&lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasStartDay/text(), '00')\"/&gt;\n                    &lt;/xsl:attribute&gt;\n\n                    &lt;xsl:attribute name=\"notAfter\"&gt;\n                        &lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasEndYear/text(), '0000')\"/&gt;-&lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasEndMonth/text(), '00')\"/&gt;-&lt;xsl:value-of select=\"format-number($input/knora-api:dateValueHasEndDay/text(), '00')\"/&gt;\n                    &lt;/xsl:attribute&gt;\n                &lt;/date&gt;\n\n            &lt;/xsl:otherwise&gt;\n        &lt;/xsl:choose&gt;\n\n\n    &lt;/xsl:function&gt;\n\n    &lt;xsl:template match=\"rdf:RDF\"&gt;\n        &lt;xsl:variable name=\"resourceIri\" select=\"beol:letter/@rdf:about\"/&gt;\n        &lt;xsl:variable name=\"label\" select=\"beol:letter/rdfs1:label/text()\"/&gt;\n\n\n        &lt;teiHeader&gt;\n            &lt;fileDesc&gt;\n                &lt;titleStmt&gt;\n                    &lt;title&gt;\n                        &lt;xsl:value-of select=\"$label\"/&gt;\n                    &lt;/title&gt;\n                &lt;/titleStmt&gt;\n                &lt;publicationStmt&gt;\n                    &lt;p&gt; This is the TEI/XML representation of the resource identified by the Iri\n                        &lt;xsl:value-of select=\"$resourceIri\"/&gt;. &lt;/p&gt;\n                &lt;/publicationStmt&gt;\n                &lt;sourceDesc&gt;\n                    &lt;p&gt;Representation of the resource's text as TEI/XML&lt;/p&gt;\n                &lt;/sourceDesc&gt;\n            &lt;/fileDesc&gt;\n            &lt;profileDesc&gt;\n\n                &lt;correspDesc&gt;\n                    &lt;xsl:attribute name=\"ref\"&gt;\n                        &lt;xsl:value-of select=\"$resourceIri\"/&gt;\n                    &lt;/xsl:attribute&gt;\n                    &lt;xsl:apply-templates/&gt;\n                &lt;/correspDesc&gt;\n            &lt;/profileDesc&gt;\n        &lt;/teiHeader&gt;\n    &lt;/xsl:template&gt;\n\n    &lt;xsl:template match=\"beol:letter/beol:hasAuthorValue\"&gt;\n        &lt;xsl:variable name=\"authorValue\" select=\"@rdf:resource\"/&gt;\n\n        &lt;xsl:variable name=\"authorIAFValue\"\n                      select=\"//knora-api:LinkValue[@rdf:about=$authorValue]//beol:hasIAFIdentifier/@rdf:resource\"/&gt;\n        &lt;xsl:variable name=\"authorFamilyNameValue\"\n                      select=\"//knora-api:LinkValue[@rdf:about=$authorValue]//beol:hasFamilyName/@rdf:resource\"/&gt;\n        &lt;xsl:variable name=\"authorGivenNameValue\"\n                      select=\"//knora-api:LinkValue[@rdf:about=$authorValue]//beol:hasGivenName/@rdf:resource\"/&gt;\n\n        &lt;correspAction type=\"sent\"&gt;\n\n            &lt;xsl:variable name=\"authorIAFText\"\n                          select=\"//knora-api:TextValue[@rdf:about=$authorIAFValue]/knora-api:valueAsString/text()\"/&gt;\n            &lt;xsl:variable name=\"authorFamilyNameText\"\n                          select=\"//knora-api:TextValue[@rdf:about=$authorFamilyNameValue]/knora-api:valueAsString/text()\"/&gt;\n            &lt;xsl:variable name=\"authorGivenNameText\"\n                          select=\"//knora-api:TextValue[@rdf:about=$authorGivenNameValue]/knora-api:valueAsString/text()\"/&gt;\n\n            &lt;persName&gt;\n                &lt;xsl:attribute name=\"ref\"&gt;&lt;xsl:value-of select=\"knora-api:iaf($authorIAFText)\"\n                /&gt;&lt;/xsl:attribute&gt;\n                &lt;xsl:value-of select=\"$authorFamilyNameText\"/&gt;, &lt;xsl:value-of\n                    select=\"$authorGivenNameText\"/&gt;\n            &lt;/persName&gt;\n\n            &lt;xsl:variable name=\"dateValue\" select=\"//beol:creationDate/@rdf:resource\"/&gt;\n\n            &lt;xsl:variable name=\"dateObj\"\n                          select=\"//knora-api:DateValue[@rdf:about=$dateValue]\"/&gt;\n\n            &lt;xsl:copy-of select=\"knora-api:dateformat($dateObj)\"/&gt;\n\n        &lt;/correspAction&gt;\n    &lt;/xsl:template&gt;\n\n    &lt;xsl:template match=\"beol:letter/beol:hasRecipientValue\"&gt;\n        &lt;xsl:variable name=\"recipientValue\" select=\"@rdf:resource\"/&gt;\n\n        &lt;xsl:variable name=\"recipientIAFValue\"\n                      select=\"//knora-api:LinkValue[@rdf:about=$recipientValue]//beol:hasIAFIdentifier/@rdf:resource\"/&gt;\n        &lt;xsl:variable name=\"recipientFamilyNameValue\"\n                      select=\"//knora-api:LinkValue[@rdf:about=$recipientValue]//beol:hasFamilyName/@rdf:resource\"/&gt;\n        &lt;xsl:variable name=\"recipientGivenNameValue\"\n                      select=\"//knora-api:LinkValue[@rdf:about=$recipientValue]//beol:hasGivenName/@rdf:resource\"/&gt;\n\n        &lt;correspAction type=\"received\"&gt;\n\n            &lt;xsl:variable name=\"recipientIAFText\"\n                          select=\"//knora-api:TextValue[@rdf:about=$recipientIAFValue]/knora-api:valueAsString/text()\"/&gt;\n            &lt;xsl:variable name=\"recipientFamilyNameText\"\n                          select=\"//knora-api:TextValue[@rdf:about=$recipientFamilyNameValue]/knora-api:valueAsString/text()\"/&gt;\n            &lt;xsl:variable name=\"recipientGivenNameText\"\n                          select=\"//knora-api:TextValue[@rdf:about=$recipientGivenNameValue]/knora-api:valueAsString/text()\"/&gt;\n\n            &lt;persName&gt;\n                &lt;xsl:attribute name=\"ref\"&gt;&lt;xsl:value-of select=\"knora-api:iaf($recipientIAFText)\"\n                /&gt;&lt;/xsl:attribute&gt;\n                &lt;xsl:value-of select=\"$recipientFamilyNameText\"/&gt;, &lt;xsl:value-of\n                    select=\"$recipientGivenNameText\"/&gt;\n            &lt;/persName&gt;\n\n        &lt;/correspAction&gt;\n    &lt;/xsl:template&gt;\n\n    &lt;!-- ignore text if there is no template for the element containing it --&gt;\n    &lt;xsl:template match=\"text()\"&gt; &lt;/xsl:template&gt;\n\n\n&lt;/xsl:transform&gt;\n</code></pre> <p>You can use the functions <code>knora-api:iaf</code> and <code>knora-api:dateformat</code> in your own XSLT in case you want to support <code>correspSearch</code>.</p> <p>The complete request looks like this:</p> <pre><code>HTTP GET request to http://host/v2/tei/resourceIri&amp;textProperty=textPropertyIri&amp;mappingIri=mappingIri&amp;gravsearchTemplateIri=gravsearchTemplateIri&amp;teiHeaderXSLTIri=teiHeaderXSLTIri\n</code></pre>"},{"location":"03-endpoints/instrumentation/health/","title":"Health","text":"<p>The health endpoint provides information about the health state of the dsp-stack.</p>"},{"location":"03-endpoints/instrumentation/health/#example-request","title":"Example request","text":"<p><code>GET /health</code></p>"},{"location":"03-endpoints/instrumentation/health/#example-response","title":"Example response","text":"<pre><code>{\n    \"name\":\"AppState\",\n    \"message\" : \"Application is healthy\",\n    \"severity\":\"non fatal\",\n    \"status\":\"healthy\"\n}\n</code></pre>"},{"location":"03-endpoints/instrumentation/introduction/","title":"Instrumentation","text":"<p>The instrumentation endpoints are running on a separate port (default <code>3339</code>) defined in <code>application.conf</code> under the key: <code>app.instrumentaion-server-config.port</code> and can also be set through the environment variable: <code>KNORA_INSTRUMENTATION_SERVER_PORT</code>.</p> <p>The exposed endpoints are:</p> <ul> <li><code>/metrics</code> - a metrics endpoint, backed by the ZIO metrics backend exposing metrics in the prometheus format</li> <li><code>/health</code> - provides information about the health state, see Health Endpoint</li> </ul>"},{"location":"03-endpoints/instrumentation/metrics/","title":"Metrics Endpoint","text":"<p>The metrics endpoint exposes metrics gathered through the ZIO metrics frontend in the Prometheus format. Additionally, ZIO runtime, JVM and ZIO-HTTP metrics are also exposed.</p>"},{"location":"03-endpoints/instrumentation/metrics/#configuration","title":"Configuration","text":"<p>The refresh interval is configured in <code>application.conf</code> under the key: <code>app.instrumentaion-server-config.interval</code> which es per default set to <code>5 seconds</code>.</p>"},{"location":"03-endpoints/instrumentation/metrics/#example-request","title":"Example request","text":"<p><code>GET /metrics</code></p>"},{"location":"03-endpoints/instrumentation/metrics/#example-response","title":"Example response","text":"<pre><code># TYPE jvm_memory_pool_allocated_bytes_total counter\n# HELP jvm_memory_pool_allocated_bytes_total Some help\njvm_memory_pool_allocated_bytes_total{pool=\"G1 Survivor Space\"}  4828024.0 1671021037947\n# TYPE jvm_memory_pool_allocated_bytes_total counter\n# HELP jvm_memory_pool_allocated_bytes_total Some help\njvm_memory_pool_allocated_bytes_total{pool=\"G1 Eden Space\"}  3.3554432E7 1671021037947\n# TYPE zio_fiber_successes counter\n# HELP zio_fiber_successes Some help\nzio_fiber_successes 17.0 1671021037947\n# TYPE zio_fiber_lifetimes histogram\n# HELP zio_fiber_lifetimes Some help\nzio_fiber_lifetimes_bucket{le=\"1.0\"}  17.0 1671021037947\nzio_fiber_lifetimes_bucket{le=\"2.0\"}  17.0 1671021037947\n...\n</code></pre>"},{"location":"03-endpoints/instrumentation/metrics/#zio-http-metrics","title":"ZIO-HTTP metrics","text":"<p>Metrics of all routes served by ZIO-HTTP (default: port <code>5555</code>) are exposed through a default metrics middleware.  However, instead of <code>http_concurrent_requests_total</code> etc. they are labeled <code>zio_http_concurrent_requests_total</code> etc. with <code>zio</code> prepended, so that they are clearly distinguishable while we still run ZIO-HTTP and Pekko-HTTP in parallel. </p> <p>To prevent excessive amounts of labels, it is considered good practice,  to replace dynamic path segments with slugs (e.g. <code>/projects/shortcode/0000</code> with <code>/projects/shortcode/:shortcode</code>).  Like this, requesting different projects by identifier will add multiple values to the histogram of a single route, instead of creating a histogram for each project:</p> <pre><code>zio_http_request_duration_seconds_bucket{method=\"GET\",path=\"/admin/projects/shortcode/:shortcode\",status=\"200\",le=\"0.005\"} 0.0 1676481606015\n...\n</code></pre> <p>Instead of:</p> <pre><code>zio_http_request_duration_seconds_bucket{method=\"GET\",path=\"/admin/projects/shortcode/0000\",status=\"200\",le=\"0.005\"} 0.0 1676481606015\nzio_http_request_duration_seconds_bucket{method=\"GET\",path=\"/admin/projects/shortcode/0001\",status=\"200\",le=\"0.005\"} 0.0 1676481606015\n...\n</code></pre> <p>This is achieved by providing the middleware a <code>pathLabelMapper</code>; when adding new routes, it is advisable to assert that this replacement works correctly for the newly added route.</p>"},{"location":"04-publishing-deployment/configuration/","title":"Configuration","text":"<p>All configuration for Knora is done in <code>application.conf</code>. </p> <p>For optimal performance it is important to tune the configuration to the hardware used, mainly to the number of CPUs and cores per CPU.</p> <p>The relevant sections for tuning are:</p> <ul> <li><code>knora-actor-dispatcher</code></li> <li><code>knora-blocking-dispatcher</code></li> </ul>"},{"location":"04-publishing-deployment/configuration/#system-environment-variables","title":"System Environment Variables","text":"<p>A number of core settings is additionally configurable through system environment variables. These are:</p> key in application.conf environment variable default value app.bcrypt-password-strength KNORA_WEBAPI_BCRYPT_PASSWORD_STRENGTH 12 app.jwt.secret KNORA_WEBAPI_JWT_SECRET_KEY super-secret-key app.jwt.expiration KNORA_WEBAPI_JWT_LONGEVITY 30 days app.jwt.issuer KNORA_WEBAPI_JWT_ISSUER 0.0.0.0:3333 app.dsp-ingest.audience KNORA_WEBAPI_DSP_INGEST_AUDIENCE http://localhost:3340 app.dsp-ingest.base-url KNORA_WEBAPI_DSP_INGEST_BASE_URL http://localhost:3340 app.allow-reload-over-http KNORA_WEBAPI_ALLOW_RELOAD_OVER_HTTP false app.ark.resolver KNORA_WEBAPI_ARK_RESOLVER_URL http://0.0.0.0:3336 app.ark.assigned-number KNORA_WEBAPI_ARK_NAAN 72163 app.knora-api.internal-host KNORA_WEBAPI_KNORA_API_INTERNAL_HOST 0.0.0.0 app.knora-api.internal-port KNORA_WEBAPI_KNORA_API_INTERNAL_PORT 3333 app.knora-api.external-protocol KNORA_WEBAPI_KNORA_API_EXTERNAL_PROTOCOL http app.knora-api.external-host KNORA_WEBAPI_KNORA_API_EXTERNAL_HOST 0.0.0.0 app.knora-api.external-port KNORA_WEBAPI_KNORA_API_EXTERNAL_PORT 3333 app.sipi.internal-protocol KNORA_WEBAPI_SIPI_INTERNAL_PROTOCOL http app.sipi.internal-host KNORA_WEBAPI_SIPI_INTERNAL_HOST localhost app.sipi.internal-port KNORA_WEBAPI_SIPI_INTERNAL_PORT 1024 app.sipi.external-protocol KNORA_WEBAPI_SIPI_EXTERNAL_PROTOCOL http app.sipi.external-host KNORA_WEBAPI_SIPI_EXTERNAL_HOST localhost app.sipi.external-port KNORA_WEBAPI_SIPI_EXTERNAL_PORT 443 app.ark.resolver KNORA_WEBAPI_ARK_RESOLVER_URL http://0.0.0.0:3336 app.ark.assigned-number KNORA_WEBAPI_ARK_NAAN 72163 app.triplestore.dbtype KNORA_WEBAPI_TRIPLESTORE_DBTYPE fuseki app.triplestore.use-https KNORA_WEBAPI_TRIPLESTORE_USE_HTTPS false app.triplestore.host KNORA_WEBAPI_TRIPLESTORE_HOST localhost app.triplestore.fuseki.port KNORA_WEBAPI_TRIPLESTORE_FUSEKI_PORT 3030 app.triplestore.fuseki.repository-name KNORA_WEBAPI_TRIPLESTORE_FUSEKI_REPOSITORY_NAME dsp-repo app.triplestore.fuseki.username KNORA_WEBAPI_TRIPLESTORE_FUSEKI_USERNAME admin app.triplestore.fuseki.password KNORA_WEBAPI_TRIPLESTORE_FUSEKI_PASSWORD test"},{"location":"04-publishing-deployment/configuration/#startup-flags","title":"Startup Flags","text":"<p>There is a number of flags that can be set on startup, they will override any value set in the application configuration file:</p> <ul> <li><code>loadDemoData</code>, <code>--loadDemoData</code>, <code>-d</code>: Loads the demo data.</li> <li><code>allowReloadOverHTTP</code>, <code>--allow-reload-over-http</code>, <code>-r</code>: Allows   reloading of data over HTTP.</li> <li><code>-c</code>: Print the configuration at startup.</li> <li><code>--help</code>: Shows the help message with all startup flags.</li> </ul>"},{"location":"04-publishing-deployment/publishing/","title":"Publishing","text":"<p>DSP is published as a set of Docker images under the DaSCH Dockerhub Organization.</p> <p>The following Docker images are published:</p> <ul> <li>DSP-API</li> <li>Sipi (includes DSP's specific Sipi scripts)</li> <li>DSP-APP</li> </ul> <p>DSP's Docker images are published automatically through Github CI each time a pull-request is merged into the <code>main</code> branch.</p> <p>Each image is tagged with a version number, which is derived by using the result of <code>git describe</code>. The describe version is built from the <code>last tag + number of commits since tag + short hash</code>, e.g., <code>8.0.0-7-ga7827e9</code>.</p> <p>The images can be published locally by running:</p> <pre><code>make docker-build\n</code></pre> <p>or to Dockerhub:</p> <pre><code>make docker-publish\n</code></pre>"},{"location":"05-internals/design/adr/ADR-0001-record-architecture-decisions/","title":"ADR-0001 Record architectural decisions as ADR","text":"<p>Date: 2022-03-14</p>"},{"location":"05-internals/design/adr/ADR-0001-record-architecture-decisions/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0001-record-architecture-decisions/#context","title":"Context","text":"<p>We need to record the architectural decisions made on this project.</p>"},{"location":"05-internals/design/adr/ADR-0001-record-architecture-decisions/#decision","title":"Decision","text":"<p>We will use Architectural Decision Records, as described by Michael Nygard.</p>"},{"location":"05-internals/design/adr/ADR-0001-record-architecture-decisions/#consequences","title":"Consequences","text":"<p>See Michael Nygard's article, linked above. For a lightweight ADR toolset, see Nat Pryce's adr-tools.</p>"},{"location":"05-internals/design/adr/ADR-0002-change-cache-service-manager-from-akka-actor-to-zlayer/","title":"ADR-0002 Change Cache Service Manager from Akka-Actor to ZLayer","text":"<p>Date: 2022-04-06</p>"},{"location":"05-internals/design/adr/ADR-0002-change-cache-service-manager-from-akka-actor-to-zlayer/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0002-change-cache-service-manager-from-akka-actor-to-zlayer/#context","title":"Context","text":"<p>The <code>org.knora.webapi.store.cacheservice.CacheServiceManager</code> was implemented as an <code>Akka-Actor</code>.</p>"},{"location":"05-internals/design/adr/ADR-0002-change-cache-service-manager-from-akka-actor-to-zlayer/#decision","title":"Decision","text":"<p>As part of the move from <code>Akka</code> to <code>ZIO</code>,  it was decided that the <code>CacheServiceManager</code>  and the whole implementation of the in-memory and Redis backed cache  is refactored using ZIO.</p>"},{"location":"05-internals/design/adr/ADR-0002-change-cache-service-manager-from-akka-actor-to-zlayer/#consequences","title":"Consequences","text":"<p>The usage from other actors stays the same. The actor messages and responses don't change.</p>"},{"location":"05-internals/design/adr/ADR-0003-change-iiif-service-manager-and-sipi-implementation-to-zlayer/","title":"ADR-0003 Change IIIF Service Manager and Sipi implementation to zlayer","text":"<p>Date: 2022-04-29</p>"},{"location":"05-internals/design/adr/ADR-0003-change-iiif-service-manager-and-sipi-implementation-to-zlayer/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0003-change-iiif-service-manager-and-sipi-implementation-to-zlayer/#context","title":"Context","text":"<p>Both <code>org.knora.webapi.store.iiif.IIIFServiceManager</code> and <code>org.knora.webapi.store.iiif.impl.IIIFServiceSipiImpl</code> where implemented as Akka-Actors </p>"},{"location":"05-internals/design/adr/ADR-0003-change-iiif-service-manager-and-sipi-implementation-to-zlayer/#decision","title":"Decision","text":"<p>As part of the move from <code>Akka</code> to <code>ZIO</code>,  it was decided that the <code>IIIFServiceManager</code> and the <code>IIIFServiceSipiImpl</code> is refactored using ZIO.</p>"},{"location":"05-internals/design/adr/ADR-0003-change-iiif-service-manager-and-sipi-implementation-to-zlayer/#consequences","title":"Consequences","text":"<p>The usage from other actors stays the same. The actor messages and responses don't change.</p>"},{"location":"05-internals/design/adr/ADR-0004-change-triplestore-service-manager-and-fuseki-implementation-to-zlayer/","title":"ADR-0004 Change Triplestore Service Manager and Fuseki implementation to ZLayer","text":"<p>Date: 2022-05-23</p>"},{"location":"05-internals/design/adr/ADR-0004-change-triplestore-service-manager-and-fuseki-implementation-to-zlayer/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0004-change-triplestore-service-manager-and-fuseki-implementation-to-zlayer/#context","title":"Context","text":"<p>Both <code>org.knora.webapi.store.triplestore.TriplestoreServiceManager</code>  and <code>org.knora.webapi.store.triplestore.impl.TriplestoreServiceHttpConnectorImpl</code> where implemented as Akka-Actors.</p>"},{"location":"05-internals/design/adr/ADR-0004-change-triplestore-service-manager-and-fuseki-implementation-to-zlayer/#decision","title":"Decision","text":"<p>As part of the move from <code>Akka</code> to <code>ZIO</code>,  it was decided that the <code>TriplestoreServiceManager</code>  and the <code>TriplestoreServiceHttpConnectorImpl</code>  is refactored using ZIO.</p>"},{"location":"05-internals/design/adr/ADR-0004-change-triplestore-service-manager-and-fuseki-implementation-to-zlayer/#consequences","title":"Consequences","text":"<p>The usage from other actors stays the same. The actor messages and responses don't change.</p>"},{"location":"05-internals/design/adr/ADR-0005-change-respondermanager-to-a-simple-case-class/","title":"ADR-0005 Change ResponderManager to a simple case class","text":"<p>Date: 2022-06-06</p>"},{"location":"05-internals/design/adr/ADR-0005-change-respondermanager-to-a-simple-case-class/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0005-change-respondermanager-to-a-simple-case-class/#context","title":"Context","text":"<p>The <code>org.knora.webapi.responders.ResponderManager</code> was implemented as an Akka-Actor.</p>"},{"location":"05-internals/design/adr/ADR-0005-change-respondermanager-to-a-simple-case-class/#decision","title":"Decision","text":"<p>In preparation of the move from <code>Akka</code> to <code>ZIO</code>, it was decided that the <code>ResponderManager</code> is refactored using plain <code>case</code> classes.</p>"},{"location":"05-internals/design/adr/ADR-0005-change-respondermanager-to-a-simple-case-class/#consequences","title":"Consequences","text":"<p>The actor messages and responses don't change.  All calls made previously to the <code>ResponderManager</code> and the <code>StorageManager</code>  are now changed to the <code>ApplicationActor</code>  which will route the calls to either the <code>ResponderManager</code>  or the <code>StorageManager</code>, based on the message type.  The <code>ApplicationActor</code> is the only actor that is allowed to make calls  to either the <code>ResponderManager</code> or the <code>StorageManager</code>.  All requests from routes are now routed to the <code>ApplicationActor</code>.</p>"},{"location":"05-internals/design/adr/ADR-0006-use-zio-http/","title":"ADR-0006 Use ZIO HTTP","text":"<p>Date: 2022-12-01</p>"},{"location":"05-internals/design/adr/ADR-0006-use-zio-http/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0006-use-zio-http/#context","title":"Context","text":"<p>The current routes use the <code>Akka Http</code> library.  Because of changes to the licensing of the <code>Akka</code> framework,  we want to move away from using <code>Akka Http</code>.  This also fits the general strategic decision to use ZIO for the backend.</p>"},{"location":"05-internals/design/adr/ADR-0006-use-zio-http/#decision","title":"Decision","text":"<p>In preparation of the move from <code>Akka</code> to <code>ZIO</code>,  it was decided that the routes should be ported to use the <code>ZIO HTTP</code> server / library instead of <code>Akka Http</code>.</p>"},{"location":"05-internals/design/adr/ADR-0006-use-zio-http/#consequences","title":"Consequences","text":"<p>In a first step only the routes are going to be ported, one by one,  to use <code>ZIO HTTP</code> instead of being routed through <code>Akka Http</code>.  The <code>Akka Actor System</code> still remains and will be dealt with later.</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/","title":"ADR-0007 ZIO-fication of Responders","text":"<p>Date: 2023-02-20</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#context","title":"Context","text":"<p>In order to remove all Akka dependencies, we have to migrate the existing <code>Responder</code>s to a <code>ZIO</code> based implementation. This migration should be possible to do on a per <code>Responder</code> basis so that we do not do a single \"big-bang\" release with too much code changed at once.</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#status-quo","title":"Status Quo","text":"<p>The central and only <code>Actor</code> is the <code>RoutingActor</code> which contains instances of each <code>Responder</code> as a field. Each of the <code>Responder</code>s needs an <code>ActorRef</code> to the <code>RoutingActor</code> and used the Akka \"ask pattern\" for communication with the other <code>Responders</code>. This means a <code>Responder</code> can only be created inside the <code>RoutingActor</code> because the <code>RoutingActor</code> must know every <code>Responder</code> in order to route the message but the <code>Responder</code> needs the <code>ActorRef</code> in order to communicate with the other <code>Responders</code>. This leads to a circular dependency between the <code>RoutingActor</code> and all Akka based <code>Responders</code>.</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#goal","title":"Goal","text":"<p>In the long term all <code>Responders</code> do not contain any Akka dependency anymore and all implementations currently returning a <code>Future</code> will return a <code>zio.Task</code>.</p> <p>The <code>zio.Task</code> is a very suitable replacement for the <code>Future</code> because:</p> <ul> <li>a <code>Future[A]</code> will complete with either a value <code>A</code> or with a failure <code>Throwable</code>.</li> <li>a <code>zio.Task[A]</code> will succeed with either a value <code>A</code> or fail with an error of type <code>Throwable</code>.</li> </ul> <p>Ideally all <code>Responders</code> will directly call the necessary components directly through invoking methods. However, this will not be possible in the beginning as there are <code>Responders</code> who call on each other creating yet another circular dependency which we cannot simply recreate with <code>ZLayer</code> dependency injection. Hence, a message like communication pattern through a central component the <code>MessageRelay</code> will be introduced which can replace the existing Akka \"ask pattern\" one to one in the ziofied component.</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#solution","title":"Solution","text":"<p>The <code>MessageRelay</code> is capable of relaying message to subscribed <code>MessageHandler</code>s and replaces the existing Akka \"ask pattern\" with the <code>RoutingActor</code>. Messages which will have a <code>MessageHandler</code> implementation must <code>extend</code> the <code>RelayedMessage</code> trait so that these are routed to the <code>MessageRelay</code> from the <code>RoutingActor</code>. All other messages will be handled as before.</p> <p>In ziofied <code>Responders</code> we can use the <code>MessageRelay</code> for communication with all other <code>Responders</code> in a similar fashion as the Akka \"ask pattern\" by invoking the method <code>MessageRelay#ask(ResponderRequest): Task[Any]</code>. A special <code>MessageHandler</code> will route all messages which do not implement the <code>RelayedMessage</code> trait back to the <code>RoutingActor</code>, this is the <code>AppRouterRelayingMessageHandler</code>.</p> <p>In the long run we will prefer to invoke methods on the respective ziofied services directly. This is now already possible for example with the <code>TriplestoreServive</code>, i.e. instead of calling <code>MessageRelay#ask[SparqlSelectResul](SparqlSelectRequest)</code> it is much easier and more importantly typesafe to call <code>TriplestoreService#sparqlHttpSelect(String): UIO[SparqlSelectResult]</code>.</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#communication-between-akka-based-responder-and-another-akka-based-responder","title":"Communication between Akka based Responder and another Akka based Responder","text":"<p>Nothing changes with regard to existing communication patterns:</p> <pre><code>sequenceDiagram\n    autonumber\n    AkkaResponder -&gt;&gt; RoutingActor: \"ask(Request)\"\n    activate RoutingActor\n    RoutingActor -&gt;&gt; OtherAkkaResponder: \"sends message to\"\n    activate OtherAkkaResponder\n    OtherAkkaResponder -&gt;&gt; RoutingActor: \"returns response\"\n    deactivate OtherAkkaResponder\n    RoutingActor -&gt;&gt; AkkaResponder: \"returns response\"\n    deactivate RoutingActor</code></pre>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#communication-between-akka-based-responder-and-ziofied-responder","title":"Communication between Akka based Responder and ziofied Responder","text":"<p>The <code>AkkaResponder</code> code remains unchanged and will still <code>ask</code> the <code>ActorRef</code> to the <code>RoutingActor</code>. The <code>RoutingActor</code> will forward the message to the <code>MessageRelay</code> and return its response to the <code>AkkaResponder</code>.</p> <pre><code>sequenceDiagram\n    autonumber\n    AkkaResponder -&gt;&gt; RoutingActor: \"ask(RelayedMessage)\"\n    activate RoutingActor\n    RoutingActor -&gt;&gt; MessageRelay: \"messageRelay.ask(RelayedMessage)\"\n    activate MessageRelay\n    MessageRelay -&gt;&gt; MessageRelay: \"finds MessageHandler\"\n    MessageRelay -&gt;&gt; ZioResponder: \"calls .handle(Request)\"\n    activate ZioResponder\n    ZioResponder -&gt;&gt; MessageRelay: \"returns response\"\n    deactivate ZioResponder\n    MessageRelay -&gt;&gt; RoutingActor: \"returns response\"\n    deactivate MessageRelay\n    RoutingActor -&gt;&gt; AkkaResponder: \"returns response\"\n    deactivate RoutingActor</code></pre>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#communication-between-ziofied-responder-and-akka-based-responder","title":"Communication between ziofied Responder and Akka based Responder","text":"<p>The <code>AppRouterRelayingMessageHandler</code> route all messages which do not implement the <code>RelayedMessage</code> trait to the <code>RoutingActor</code>.</p> <pre><code>sequenceDiagram\n    autonumber\n    ZioResponder -&gt;&gt; MessageRelay: \"ask(Request)\"\n    activate MessageRelay\n    MessageRelay -&gt;&gt; MessageRelay: \"finds MessageHandler\"\n    MessageRelay -&gt;&gt; AppRouterRelayingMessageHandler: \"calls .handle(Request)\"\n    activate AppRouterRelayingMessageHandler\n    AppRouterRelayingMessageHandler -&gt;&gt; RoutingActor: \"sends message to\"\n    deactivate AppRouterRelayingMessageHandler\n    activate RoutingActor\n    RoutingActor -&gt;&gt; AkkaResponder: \"calls AkkaResponder\"\n    activate AkkaResponder\n    AkkaResponder -&gt;&gt; RoutingActor: \"returns response\"\n    deactivate AkkaResponder\n    RoutingActor -&gt;&gt; MessageRelay: \"returns response\"\n    deactivate RoutingActor\n    MessageRelay -&gt;&gt; ZioResponder: \"returns response\"\n    deactivate MessageRelay</code></pre>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#communication-between-two-ziofied-responders","title":"Communication between two ziofied Responders","text":""},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#variant-using-the-messagerelay","title":"Variant using the MessageRelay","text":"<pre><code>sequenceDiagram\n    autonumber\n    ZioResponder -&gt;&gt; MessageRelay: \"ask(Request)\"\n    activate MessageRelay\n    MessageRelay -&gt;&gt; MessageRelay: \"finds MessageHandler\"\n    MessageRelay -&gt;&gt; OtherZioResponder: \"calls .handle(Request)\"\n    activate OtherZioResponder\n    OtherZioResponder -&gt;&gt; MessageRelay: \"returns response\"\n    deactivate OtherZioResponder\n    MessageRelay -&gt;&gt; ZioResponder: \"returns response\"\n    deactivate MessageRelay</code></pre>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#variant-if-other-responder-is-a-direct-dependency","title":"Variant if other Responder is a direct dependency","text":"<pre><code>sequenceDiagram\n    autonumber\n    ZioResponder -&gt;&gt; TriplestoreService: \"calls method\"\n    activate TriplestoreService\n    TriplestoreService -&gt;&gt; ZioResponder: \"returns response\"\n    deactivate TriplestoreService</code></pre>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#decision","title":"Decision","text":"<p>In preparation of the move from <code>Akka</code> to <code>ZIO</code>,  it was decided that the <code>Responders</code> should be ported to use return <code>ZIO</code>s and the <code>MessageRelay</code>  instead of <code>Future</code>s and the <code>ActorRef</code> to the <code>RoutingActor</code>.</p>"},{"location":"05-internals/design/adr/ADR-0007-zio-fication-of-responders/#consequences","title":"Consequences","text":"<p>In a first step only the <code>Responders</code> are going to be ported, one by one, to use the above pattern.  The <code>Akka Actor System</code> still remains, will be used in the test and will be removed in a later step. Due to the added indirections and the blocking nature of <code>Unsafe.unsafe(implicit u =&gt; r.unsafe.run(effect))</code>  it is necessary to spin up more <code>RoutingActor</code> instances as otherwise deadlocks will occur. This should not be a problem as any shared state, e.g. caches,  is not held within the <code>RoutingActor</code> or one of its contained <code>Responder</code> instances.</p>"},{"location":"05-internals/design/adr/ADR-0008-replace-akka-with-pekko/","title":"ADR-0006 Replace Akka with Pekko","text":""},{"location":"05-internals/design/adr/ADR-0008-replace-akka-with-pekko/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0008-replace-akka-with-pekko/#context","title":"Context","text":"<p>On 7. September 2022 Lightbend announced a  license change for the Akka project,  the TL;DR being that you will need a commercial license to use future versions of Akka (2.7+) in production  if you exceed a certain revenue threshold.</p> <p>For now, we have staid on Akka 2.6, the current latest version that is still available under the original license.  Historically Akka has been incredibly stable, and combined with our limited use of features,  we did not expect this to be a problem.</p> <p>However, the last update of Akka 2.6 is announced to be in September 2023.</p> <p>Will critical vulnerabilities and bugs be patched in 2.6.x? Yes, critical security updates and critical bugs will be patched in Akka v2.6.x    under the current Apache 2 license until September of 2023.</p> <p>As a result, we will not receive further updates and we will never get support for Scala 3 for Akka.</p>"},{"location":"05-internals/design/adr/ADR-0008-replace-akka-with-pekko/#proposal","title":"Proposal","text":"<p>Apache Pekko is based on the latest version of Akka in the v2.6.x series.  It is currently an incubator project in the ASF.  All Akka modules currently in use in the dsp-api are already released and ported to  pekko:  https://mvnrepository.com/artifact/org.apache.pekko</p> <p>The latest stable version 1.0.1  is compatible with Akka v2.6.x series and meant to be a plug in replacement.</p> <p>Scala 3.3.0 is the minimum Scala 3 version supported. Scala 2.12 and 2.13 are still supported.</p> <p>The migration guide</p> <p>Our current migration to another http server implementation is currently on hold,  but we might want to switch to Pekko so that we could receive security updates and bugfixes.</p> <p>The proof of concept implementation has been shared in the pull request  here,  allowing for further testing and validation of the proposed switch to Pekko.</p>"},{"location":"05-internals/design/adr/ADR-0008-replace-akka-with-pekko/#decision","title":"Decision","text":"<p>We replace Akka and Akka/Http with Apache Pekko.</p>"},{"location":"05-internals/design/adr/ADR-0009-api-v3/","title":"ADR-009: API <code>v3</code> for client-optimized endpoints","text":"<p>Date: 2025-09-22 RFC: RFC-018</p>"},{"location":"05-internals/design/adr/ADR-0009-api-v3/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"05-internals/design/adr/ADR-0009-api-v3/#context","title":"Context","text":"<p>DSP-APP currently requires excessive API calls to load a single project page.  The existing v2 and admin APIs present several challenges:</p> <ul> <li>API Design Mismatch: APIs reflect backend/triplestore structure rather than frontend domain concepts</li> <li>Technical Limitations: RDF-based v2 API doesn't integrate well with OpenAPI, requires JS-Lib intermediary layer</li> <li>Performance Issues: Single-entity focus leads to excessive round trips and complex state management</li> <li>Stability Constraints: v2's public status prevents breaking changes needed for frontend optimization</li> </ul> <p>The team needs an API specifically designed for frontend consumption without the constraints of backward compatibility.</p>"},{"location":"05-internals/design/adr/ADR-0009-api-v3/#decision","title":"Decision","text":"<p>We will implement a new v3 API with the following characteristics:</p> <ul> <li>Internal, non-public API explicitly flagged as volatile and subject to change without notice</li> <li>Frontend-optimized design focusing on complete domain entities and data aggregation</li> <li>Plain JSON requests/responses with comprehensive OpenAPI specifications</li> <li>Incremental development starting with high-impact endpoints identified by frontend developers</li> <li>Coexistence with existing APIs rather than replacement - v2 remains for semantic web use cases</li> </ul> <p>The v3 API will share services and repositories with existing APIs in the long term,  diverging only at endpoint and REST service layers.</p> <p>While the focus is on DSP-APP, the v3 API will be designed supporting all internal clients, including DSP-TOOLS.</p> <p>Initial up-front design of the v3 API will be done in a separate project  in collaboration between frontend and backend developers. This document will be updated when the design is finalized.</p>"},{"location":"05-internals/design/adr/ADR-0009-api-v3/#consequences","title":"Consequences","text":"<p>To be seen.</p>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/","title":"ADR-0010: API <code>v3</code> basics","text":"<p>Date: 2025-11- 05 </p> <p>RFC: RFC-020</p>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#context","title":"Context","text":"<p>We want to build a V3 API (ADR-0009).  In this ADR the foundational basics on which we can agree on before modelling specific endpoints in detail are laid out. This will describe content types, error types and authentication as well as a general approach on how to model the API in the long run.</p> <p>ADR-009 has decided the V3 API should be based on plain JSON requests/responses with a comprehensive OpenAPI specification.</p> <p>Identified Problems with existing API v2:</p> <ul> <li>JSON-LD is hard to handle</li> <li>Requesting multiple entities is cumbersome</li> <li>API design confusing sometimes<ul> <li>Supporting too many different identifiers for an entity</li> <li>Overloading responsibilities in the permissions api for example</li> <li>Unclear how certain parameters are passed (header, body, implicit by passing a certain IRI schema\u2026)</li> <li>Projects are not well separated in resource/values api</li> </ul> </li> </ul>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#authentication","title":"Authentication","text":"<p>V3 will accept JWT Bearer tokens in the header only.</p>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#identifiers-for-entities","title":"Identifiers for Entities","text":"<p>As an identifier for any entity we will use existing IRIs in the current complex schema.</p> <p>Alternative (kind of but not really)</p> <p>Create new external identifiers for existing entities.</p> <p>Advantage:</p> <ul> <li>New ids could be shorter, more human readable, no need for URL encoding</li> </ul> <p>Drawback:</p> <ul> <li>Huge effort in data migration.</li> <li>Not easy to use with existing code already integrated with  v2 (which supports these iris  supported for all entities).</li> <li>It is confusing to have too many different identifiers for an entity.</li> </ul>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#api-design-guidelines","title":"API Design Guidelines","text":"<p>Generally we would like to follow a RESTful approach to API design with the focus on entities being part of the REST resource.</p>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#naming-conventions","title":"Naming Conventions","text":"<p>Entities are always named in plural in the path, e.g. <code>/v3/projects/</code>.</p> <p>Compound words are in camel case, e.g. <code>resourceIri</code> <code>resourceClassIri</code> in the path, query params as well as in payloads.</p>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#design-examples","title":"Design Examples","text":"<p>As an example for retrieving information using GET requests for projects, resources and values:</p> <p><code>/v3/projects/:projectIri/resources/:resourceIri/values/:valueIri</code> - returns a single Value</p> <p><code>/v3/projects/:projectIri/resources/:resourceIri</code>  - returns a single Resource</p> <p><code>/v3/projects/:projectIri</code> - returns a single Project</p> <p>Currently the a Value IRI by design contains the information to which resource/project it belongs to.  The proposed API design reflects that: a value can only exist by belonging to a resource that itself must belong to a single project.</p> <p>Retrieving multiple entities within its context is done using a GET request on the respective path using query parameters, for example: <code>/v3/projects/:projectIri/resources/?resourceClassIri=???</code></p> <p>Other aspects as for example project boundary crossing searches or exports can be modelled using new paths on the v3 base level:</p> <ul> <li><code>/v3/search/</code></li> <li><code>/v3/export/resources</code></li> </ul>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#pagination","title":"Pagination","text":"<p>Retrieving multiple entities MUST be done using pagination as is currently the case with the project legal info endpoints.</p> <p>The default page SHOULD be 1 (i.e. the first page, one indexed), and the default page-size SHOULD be 25.</p> <p>A paged response look like this:</p> <pre><code>{\n  \"data\": [\n    /** some entity JSON objects **/\n  ],\n  \"pagination\": {\n    \"pageSize\": 25,\n    \"totalItems\": 75,\n    \"totalPages\": 3,\n    \"currentPage\": 2\n  }\n}\n</code></pre> <p>These endpoints MUST share the common vocabulary for page and size query params <code>page</code> and <code>page-size</code> .</p> <p>Designing filtering and ordering commonalities should be considered a separate ADR, if that is even possible.</p>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#error-responses","title":"Error Responses","text":"<p>A new error response model has already been discussed in more detail.</p> <p>In general error responses:</p> <ul> <li>MUST allow to provide multiple problems at once.</li> <li>MUST contain a code identifying the error which will be translated by the app</li> <li>SHOULD contain error details which may be interpolated while translating the app</li> <li>SHOULD be human readable for developers</li> </ul> <p>Example:</p> <pre><code>{\n  \"message\" : \"Unable to authenticate\",\n  \"errors\" : [\n     {\n       \"code\" : \"user_not_found\",\n       \"message\" : \"User https://example.org/userIri not found\",\n       \"details\" : {\n         \"userIri\" : \"https://example.org/userIri\"\n       }\n  ]\n}\n</code></pre>"},{"location":"05-internals/design/adr/ADR-0010-api-v3-basics/#language-support","title":"Language support","text":"<p>Where the api currently supports different languages we will keep on supporting them and will have to make it explicit in the responses, for the time being we should return all available languages immediately.  For multilanguage properties the responses should look something like the following example, if a language is not present in the data it may be omitted in the response, as to indicate the lack of a value.</p> <pre><code>{\n   \"someValueWithLanguageSupport\" : {\n     \"en\" : \"English\",\n     \"de\" : \"Deutsch\"\n   },\n   \"someValueWithoutLanguage\" : \"the string is the value, no knowlegde of what language\"\n }\n</code></pre>"},{"location":"05-internals/design/api-admin/administration/","title":"Administration","text":""},{"location":"05-internals/design/api-admin/administration/#permissions","title":"Permissions","text":"<p>The permissions API endpoint is described in the permission documentation.</p> <p>The default permissions when a project is created are described admin api documenation.</p> <p>DSP's concept of access control is that permissions  can only be granted to groups and not to individual users. There are two distinct ways of granting permission.</p> <ol> <li>An object (a resource or value) can grant permissions to groups of users.</li> <li>Permissions can be granted directly to a group of users (not bound to a specific object).</li> </ol> <p>There are six built-in groups:  UnknownUser, KnownUser, Creator, ProjectMember, ProjectAdmin, and SystemAdmin.  These groups can be used in the same way as normal user created groups for permission management, i.e. can be used to give certain groups of users, certain permissions, without the need to explicitly create them.</p> <p>A user becomes implicitly a member of such a group by satisfying certain conditions:</p> <ul> <li> <p>knora-admin:UnknownUser:   Any user who has not logged into the DSP is automatically assigned to this group.   Group IRI: <code>http://www.knora.org/ontology/knora-admin#UnknownUser</code></p> </li> <li> <p>knora-admin:KnownUser:   Any user who has logged into the DSP is automatically assigned to this group.   Group IRI: <code>http://www.knora.org/ontology/knora-admin#KnownUser</code></p> </li> <li> <p>knora-admin:Creator:   When checking a user\u2019s permissions on an object, the user is automatically assigned to this group    if they are the creator of the object.   Group IRI: <code>http://www.knora.org/ontology/knora-admin#Creator</code></p> </li> <li> <p>knora-admin:ProjectMember:   When checking a user\u2019s permissions, the user is automatically assigned to this group    by being a member of a project designated by the <code>knora-admin:isInProject</code> property.   Group IRI: <code>http://www.knora.org/ontology/knora-admin#ProjectMember</code></p> </li> <li> <p>knora-admin:ProjectAdmin:   When checking a user's permission, the user is automatically assigned to this group    through the <code>knora-admin:isInProjectAdminGroup</code> property, which points to the  project in question.   Group IRI: <code>http://www.knora.org/ontology/knora-admin#ProjectAdmin</code></p> </li> <li> <p>knora-admin:SystemAdmin:   Membership is received by setting the property <code>knora-admin:isInSystemAdminGroup</code> to <code>true</code> on a <code>knora-admin:User</code>.   Group IRI: <code>http://www.knora.org/ontology/knora-admin#SystemAdmin</code></p> </li> </ul> <p>There are three kinds of permissions:</p> <ol> <li>object access permissions, which contain permissions     that point from explicit objects (resources/values) to groups.</li> <li>administrative permissions, which contain permissions     that are put on instances of <code>knora-admin:Permission</code> objects directly affecting groups. </li> <li>default object access permissions which are also put on instances of <code>knora-admin:Permission</code>,    and which also directly affect groups.</li> </ol>"},{"location":"05-internals/design/api-admin/administration/#object-access-permissions","title":"Object Access Permissions","text":"<p>An object (resource / value) can grant the following permissions, which are stored in a compact format in a single string, which is the object of the predicate <code>knora-base:hasPermissions</code>:</p> <ol> <li>Restricted view permission (RV): Allows a restricted view of    the object, e.g. a view of an image with a watermark.</li> <li>View permission (V): Allows an unrestricted view of the    object. Having view permission on a resource only affects the    user's ability to view information about the resource other than    its values. To view a value, she must have view permission on the    value itself.</li> <li>Modify permission (M): For values, this permission allows a    new version of a value to be created. For resources, this allows    the user to create a new value (as opposed to a new version of an    existing value), or to change information about the resource other    than its values. When he wants to make a new version of a value,    his permissions on the containing resource are not relevant.    However, when he wants to change the target of a link, the old    link must be deleted and a new one created, so he needs modify    permission on the resource.</li> <li>Delete permission (D): Allows the item to be marked as deleted.</li> <li>Change rights permission (CR): Allows the permissions granted by the object to be changed.</li> </ol> <p>Each permission in the above list implies all lower-numbered permissions.</p> <p>A user's permission level on a particular object is calculated in the following way:</p> <ol> <li>Make a list of the groups that the user belongs to, including    Creator and/or ProjectMember and/or ProjectAdmin if applicable.</li> <li>Make a list of the permissions that she can obtain on the    object, by iterating over the permissions that the object    grants. For each permission, if she is in the specified group,    add the specified permission to the list of permissions she can    obtain.</li> <li>From the resulting list, select the highest-level permission.</li> <li>If the result is that she would have no permissions, give her    whatever permission UnknownUser would have.</li> </ol> <p>The format of the object of <code>knora-base:hasPermissions</code> is as follows:</p> <ul> <li>Each permission is represented by the one-letter or two-letter   abbreviation given above.</li> <li>Each permission abbreviation is followed by a space, then a   comma-separated list of groups that the permission is granted   to.</li> <li>The IRIs of built-in groups are shortened using the knora-admin   prefix.</li> <li>Multiple permissions are separated by a vertical bar (|).</li> </ul> <p>For example, if an object grants view permission to unknown and known users, and modify permission to project members, the resulting permission literal would be: <code>V knora-admin:UnknownUser,knora-admin:KnownUser|M knora-admin:ProjectMember</code>.</p>"},{"location":"05-internals/design/api-admin/administration/#administrative-permissions","title":"Administrative Permissions","text":"<p>The following permissions can be set via instances of <code>knora-admin:AdministrativePermission</code> on any group belonging to a project. For users that are members of a number of groups with administrative permissions attached, the final set of permissions is additive and most permissive. The administrative permissions are stored in a compact format in a single string, which is the object of the predicate <code>knora-base:hasPermissions</code> attached to an instance of the <code>knora-admin:AdministrativePermission</code> class. The following permission values can be used:</p> <ol> <li>Resource / Value Creation Permissions:     1) ProjectResourceCreateAllPermission:         - description: gives the permission to create resources inside the project.         - usage: used as a value for knora-base:hasPermissions.     2) ProjectResourceCreateRestrictedPermission:         - description: gives restricted resource creation permission inside the project.         - usage: used as a value for knora-base:hasPermissions.         - value: <code>RestrictedProjectResourceCreatePermission</code>           followed by a comma-separated list of ResourceClasses           the user should only be able to create instances of.</li> <li>Project Administration Permissions:     1) ProjectAdminAllPermission:         - description: gives the user the permission to do anything           on project level, i.e. create new groups, modify all           existing groups (group info, group membership,           resource creation permissions, project administration           permissions, and default permissions).         - usage: used as a value for knora-base:hasPermissions.     2) ProjectAdminGroupAllPermission:         - description: gives the user the permission to modify           group info and group membership on all groups           belonging to the project.         - usage: used as a value for the knora-base:hasPermissions property.     3) ProjectAdminGroupRestrictedPermission:         - description: gives the user the permission to modify           group info and group membership on certain groups           belonging to the project.         - usage: used as a value for knora-base:hasPermissions         - value: <code>ProjectGroupAdminRestrictedPermission</code> followed by           a comma-separated list of <code>knora-admin:UserGroup</code>.     4) ProjectAdminRightsAllPermission:         - description: gives the user the permission to change the           permissions on all objects belonging to the project           (e.g., default permissions attached to groups and           permissions on objects).         - usage: used as a value for the knora-base:hasPermissions property.</li> </ol> <p>The administrative permissions are stored in a compact format in a single string, which is the object of the predicate <code>knora-base:hasPermissions</code> attached to an instance of the <code>knora-admin:AdministrativePermission</code> class.</p> <ul> <li>The format of the object of <code>knora-base:hasPermissions</code> is as follows:<ul> <li>Each permission is represented by the name given above.</li> <li>Each permission is followed by a space, then if applicable, by comma separated list of IRIs, as defined above.</li> <li>The IRIs of built-in values (e.g., built-in groups, resource   classes, etc.) are shortened using the knora-admin prefix <code>knora-admin:</code>.</li> <li>Multiple permissions are separated by a vertical bar (|).</li> </ul> </li> </ul> <p>For example, if an administrative permission grants the <code>knora-admin:ProjectMember</code> group the permission to create all resources (ProjectResourceCreateAllPermission), the resulting administrative permission object with the compact form literal would be: :</p> <pre><code>&lt;http://rdfh.ch/permissions/001\n        rdf:type knora-admin:AdministrativePermission ;\n        knora-admin:forProject &lt;http://rdfh.ch/projects/00FF&gt;;\n        knora-admin:forGroup knora-admin:ProjectMember ;\n        knora-base:hasPermissions \"ProjectResourceCreateAllPermission\"^^xsd:string .\n</code></pre>"},{"location":"05-internals/design/api-admin/administration/#default-object-access-permissions","title":"Default Object Access Permissions","text":"<p>Default Object Access Permissions are used when new objects (resources and/or values) are created. They represent object access permissions with which the new object will be initially outfitted. As with administrative permissions, these default object access permissions can be defined for any number of groups. Additionally, they can be also defined for resource classes and properties.</p> <p>The following default object access permissions can be attached to groups, resource classes and/or properties via instances of knora-admin:DefaultObjectAccessPermission (described further bellow). The default object access permissions correspond to the earlier described object access permission:</p> <ol> <li>Default Restricted View Permission (RV):<ul> <li>description: any object, created by a user inside a group   holding this permission, is restricted to carry this permission</li> <li>value: <code>RV</code> followed by a comma-separated list of <code>knora-admin:UserGroup</code></li> </ul> </li> <li>Default View Permission (V):<ul> <li>description: any object, created by a user inside a group   holding this permission, is restricted to carry this permission</li> <li>value: <code>V</code> followed by a comma-separated list of <code>knora-admin:UserGroup</code></li> </ul> </li> <li>Default Modify Permission (M) accompanied by a list of groups.<ul> <li>description: any object, created by a user inside a group   holding this permission, is restricted to carry this permission</li> <li>value: <code>M</code> followed by a comma-separated list of <code>knora-admin:UserGroup</code></li> </ul> </li> <li>Default Delete Permission (D) accompanied by a list of groups.<ul> <li>description: any object, created by a user inside a group   holding this permission, is restricted to carry this permission</li> <li>value: <code>D</code> followed by a comma-separated list of <code>knora-admin:UserGroup</code></li> </ul> </li> <li>Default Change Rights Permission (CR) accompanied by a list of groups.<ul> <li>description: any object, created by a user inside a group   holding this permission, is restricted to carry this permission</li> <li>value: <code>CR</code> followed by a comma-separated list of <code>knora-admin:UserGroup</code></li> </ul> </li> </ol> <p>A single instance of <code>knora-admin:DefaultObjectAccessPermission</code> must always reference a project, but can only reference either a group (<code>knora-admin:forGroup</code> property), a resource class (<code>knora-admin:forResourceClass</code>), a property (<code>knora-admin:forProperty</code>), or a combination of resource class and property.</p> <p>Example default object access permission instance:</p> <pre><code>&lt;http://rdfh.ch/permissions/002\n        rdf:type knora-admin:DefaultObjectAccessPermission ;\n        knora-admin:forProject &lt;http://rdfh.ch/projects/00FF&gt;;\n        knora-admin:forGroup knora-admin:ProjectMember ;\n        knora-base:hasPermissions \"CR knora-admin:Creator|M knora-admin:ProjectMember|V knora-admin:KnownUser\"^^xsd:string .\n</code></pre> <p>This instance is setting default object access permissions to the project member group of a project, giving change right permission to the creator, modify permission to all project members, and view permission to known users. Further, this implicitly applies to all resource classes and all their properties inside the project.</p>"},{"location":"05-internals/design/api-admin/administration/#permission-precedence-rules","title":"Permission Precedence Rules","text":"<p>For both administrative permissions and default object access permissions, the resulting permissions are derived by applying precedence rules, for the case that the user is member of more than one group.</p> <p>The following list is sorted by the permission precedence level in descending order:</p> <ul> <li>permissions on <code>knora-admin:ProjectAdmin</code> (highest level)</li> <li>permissions on resource classes and property combination (own project)</li> <li>permissions on properties (own project, when creating a Value)</li> <li>permissions on resource classes (own project, when creating a Resource)</li> <li>permissions on custom groups</li> <li>permissions on <code>knora-admin:ProjectMember</code></li> </ul> <p>The permissions on resource classes / properties are only relevant for default object access permissions.</p> <p>Administrative Permissions: When a user performs an operation requiring administrative permissions, then only the permissions from the highest level are taken into account. If a user is a member of more than one group on the same level (only possible for custom groups) then the defined permissions are summed up and all are taken into account.</p> <p>Default Object Access Permissions: When a user creates a resource or value, then only the default object permissions from the highest level are applied. If a user is a member of more than one group on the same level (only possible for custom groups) then the defined permissions are summed up and the most permissive are applied.</p> <p>In the case of the user belonging to the SystemAdmin group, but which is not member of a project and thus not member of any group belonging to the project, the default object access permissions from the ProjectAdmin, or ProjectMember group will be applied in the order of precedence. If no permissions are defined on either of these groups, then the resulting permission will be <code>CR knora-admin:Creator</code>.</p>"},{"location":"05-internals/design/api-admin/administration/#implicit-permissions","title":"Implicit Permissions","text":"<p>The <code>knora-admin:SystemAdmin</code> group receives implicitly the following permissions:</p> <ul> <li>receives implicitly ProjectAdminAllPermission for all projects.</li> <li>receives implicitly ProjectResourceCreateAllPermission for all projects.</li> <li>receives implicitly CR on all objects from all projects.</li> </ul> <p>These permissions are baked into the system, and cannot be changed.</p>"},{"location":"05-internals/design/api-admin/administration/#default-permissions-matrix-for-new-projects","title":"Default Permissions Matrix for new Projects","text":"<p>The access control matrix defines what are the default operations a subject (i.e. User), being a member of a built-in group (represented by row headers), is permitted to perform on an object (represented by column headers). The different operation abbreviations used are defined as follows:</p> <ul> <li> <p>C: Create - the subject inside the group is allowed to create the object.</p> </li> <li> <p>U: Update - the subject inside the group is allowed to update the object.</p> </li> <li> <p>R: Read - the subject inside the group is allowed to read all information about the object.</p> </li> <li> <p>D: Delete - the subject inside the group is allowed to delete the object.</p> </li> <li> <p>P: Permission - the subject inside the group is allowed to change the permissions on the object.</p> </li> <li> <p>-: none - none or not applicable</p> </li> </ul> Built-In Group Project Group User Resource Value SystemAdmin <code>CRUD</code> <code>CRUDP</code> <code>CRUDP</code> all <code>CRUDP</code> all <code>CRUDP</code> all ProjectAdmin <code>-RUD</code> <code>CRUDP</code> <code>CRUDP</code> +/- project <code>CRUDP</code> (in project) <code>CRUDP</code> (in project) ProjectMember <code>----</code> <code>-----</code> <code>-----</code> <code>CRU--</code> (in project) <code>-----</code> (in project) Creator <code>----</code> <code>-----</code> <code>-----</code> <code>-----</code> (his resource) <code>-----</code> (his value) KnownUser <code>C---</code> <code>C----</code> <code>CRUD-</code> himself <code>-----</code> (in project) <code>-----</code> (in project) <p>Default Permissions Matrix for new Projects</p> <p>The explicitly defined default permissions for a new project are as follows:</p> <ul> <li> <p><code>knora-admin:ProjectAdmin</code> group:</p> <ul> <li>Administrative Permissions:<ul> <li>ProjectResourceCreateAllPermission.</li> <li>ProjectAdminAllPermission.</li> </ul> </li> <li>Default Object Access Permissions:<ul> <li>CR for the knora-admin:ProjectAdmin group</li> <li>D for the knora-admin:ProjectAdmin group</li> <li>M for the knora-admin:ProjectAdmin group</li> <li>V for the knora-admin:ProjectAdmin group</li> <li>RV for the knora-admin:ProjectAdmin group</li> </ul> </li> </ul> </li> <li> <p>The <code>knora-admin:ProjectMember</code> group:</p> <ul> <li>Administrative Permissions:<ul> <li>ProjectResourceCreateAllPermission.</li> </ul> </li> <li>Default Object Access Permissions:<ul> <li>M for the knora-admin:ProjectMember group</li> <li>V for the knora-admin:ProjectMember group</li> <li>RV for the knora-admin:ProjectMember group</li> </ul> </li> </ul> </li> </ul>"},{"location":"05-internals/design/api-admin/administration/#basic-workflows-involving-permissions","title":"Basic Workflows involving Permissions","text":""},{"location":"05-internals/design/api-admin/administration/#creating-a-new-resource","title":"Creating a new Resource","text":""},{"location":"05-internals/design/api-admin/administration/#accessing-a-resourcevalue","title":"Accessing a Resource/Value","text":""},{"location":"05-internals/design/api-admin/administration/#project-group-administration","title":"Project / Group Administration","text":""},{"location":"05-internals/design/api-admin/administration/#implementation","title":"Implementation","text":"<p>The requirements for defining default permissions imposed by all the different use cases are very broad. Potentially, we need to be able to define default permissions per project, per group, per resource class, per resource property, and all their possible combinations.</p> <p>For this reason, we introduce the knora-admin:Permission class with two sub-classes, namely knora-admin:AdministrativePermission and knora-admin:DefaultObjectAccessPermission, which instances will carry all the necessary information.</p>"},{"location":"05-internals/design/api-admin/administration/#permission-class-hierarchy-and-structure","title":"Permission Class Hierarchy and Structure","text":"<p>The following graphs show the class hierarchy and the structure of each permission class.</p> <p>Permission Class Hierarchy:</p> <p></p> <p>Administrative Permission Structure:</p> <p></p> <p>and the same as RDF:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:AdministrativePermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forGroup &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt; ;\n     knora-base:hasPermissions \"ProjectResourceCreateAllPermission|\n                                ProjectResourceCreateRestrictedPermission \"&lt;Resource Class IRI&gt;\"|\n                                ProjectAdminAllPermission|\n                                ProjectAdminGroupAllPermission|\n                                ProjectAdminGroupRestrictedPermission \"&lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;, &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;\"|\n                                ProjectAdminRightsAllPermission\"^^xsd:string .\n</code></pre> <p>Default Object Access Permission Structure:</p> <p></p> <p>and the same as RDF:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:DefaultObjectAccessPermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forGroup &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt; ;\n     knora-admin:forResourceClass \"Resource Class Name\" ;\n     knora-admin:forProperty \"Resource Property Name\" ;\n     knora-base:hasPermissions \"RV &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;|\n                                 V &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;|\n                                 M &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;|\n                                 D &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;|\n                                CR &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;\"^^xsd:string .\n</code></pre>"},{"location":"05-internals/design/api-admin/administration/#querying-permission-instances","title":"Querying Permission Instances","text":"<p>The properties forProject and either of forGroup, forResourceClass, and forProperty form together a compound key, allowing finding existing permission instances, that address the same set of Project / Group / ResourceClass / Property combination, thus making it possible to extend or change the attached permissions.</p> <p>Administrative Permission Instances: For each group inside the project, there can be zero or one instance holding administrative permission information. Querying is straitforward by using the knora-admin:forProject and knora-admin:forGroup properties as the compound key.</p> <p>Default Object Access Permission Instances: For each group, resource class, or property inside the project, there can be zero or one instances holding default object access permission informations. Querying is straitforward by using the knora-admin:forProject and either knora-admin:forGroup, knora-admin:forResourceClass, or knora-admin:forProperty properties as part of the compound key.</p>"},{"location":"05-internals/design/api-admin/administration/#example-data-stored-in-the-permissions-graph","title":"Example Data stored in the permissions graph","text":"<p>Administrative permissions on a 'ProjectAdmin' group:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:AdministrativePermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/00FF&gt; ;\n     knora-admin:forGroup knora-admin:ProjectAdmin ;\n     knora-base:hasPermissions \"ProjectResourceCreateAllPermission|\n                                ProjectAdminAllPermission\"^^xsd:string .\n</code></pre> <p>Administrative permissions on a 'ProjectMember' group:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:AdministrativePermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/00FF&gt; ;\n     knora-admin:forGroup knora-admin:ProjectMember ;\n     knora-base:hasPermissions \"ProjectResourceCreateAllPermission\"^^xsd:string .\n</code></pre> <p>Administrative permission restricting project admin permission on a group:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:Permission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forGroup &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt; ;\n     knora-base:hasPermissions \"ProjectGroupAdminRestrictedPermission &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;\"^^xsd:string .\n</code></pre> <p>Administrative permission restricting resource creation for a group:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:AdministrativePermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forGroup &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt; ;\n     knora-base:hasPermissions \"ProjectResourceCreateRestrictedPermission &lt;http://www.knora.org/ontology/00FF/images#Person&gt;\"^^xsd:string .\n</code></pre> <p>Default object access permission on a 'ProjectMember' group:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:DefaultObjectAccessPermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/00FF&gt; ;\n     knora-admin:forGroup knora-admin:ProjectMember ;\n     knora-base:hasPermissions \"CR knora-admin:Creator|\n                                 M &lt;http://rdfh.ch/groups/[shortcode]/[UUID]&gt;|\n                                 V knora-admin:KnownUser\"^^xsd:string .\n</code></pre> <p>Default object access permission on a resource class:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:DefaultObjectAccessPermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forResourceClass &lt;http://www.knora.org/ontology/00FF/images#person&gt; ;\n     knora-base:hasPermissions \"CR knora-admin:Creator,knora-admin:ProjectMember|\n                                 V knora-admin:KnownUser,knora-admin:UnknownUser\"^^xsd:string .\n</code></pre> <p>Default object access permission on a resource property:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:DefaultObjectAccessPermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forProperty &lt;http://www.knora.org/ontology/00FF/images#lastname&gt; ;\n     knora-base:hasPermissions \"D knora-admin:ProjectMember,knora-admin:Creator|\n                                V knora-admin:KnownUser,knora-admin:UnknownUser\"^^ .\n</code></pre> <p>Default object access permission on a resource class and property:</p> <pre><code>&lt;http://rdfh.ch/permissions/[UUID]&gt; rdf:type knora-admin:DefaultObjectAccessPermission ;\n     knora-admin:forProject &lt;http://rdfh.ch/projects/[shortcode]&gt; ;\n     knora-admin:forResourceClass &lt;http://www.knora.org/ontology/00FF/images#person&gt; ;\n     knora-admin:forProperty &lt;http://www.knora.org/ontology/00FF/images#lastname&gt; ;\n     knora-base:hasPermissions \"CR knora-admin:Creator,knora-admin:ProjectMember|\n                                 V knora-admin:KnownUser,knora-admin:UnknownUser\"^^xsd:string .\n</code></pre> <p>When the user's <code>UserProfile</code> is queried, all permissions for all projects and groups the user is a member of are also queried. This information is then stored as an easy accessible object inside the <code>UserProfile</code>, being readily available wherever needed. As this is a somewhat expensive operation, built-in caching mechanism at different levels (e.g., UsersResponder, PermissionsResponder), will be applied.</p>"},{"location":"05-internals/design/api-v2/ark/","title":"Archival Resource Key (ARK) Identifiers","text":""},{"location":"05-internals/design/api-v2/ark/#requirements","title":"Requirements","text":"<p>Knora must produce an ARK URL for each resource and each value. The ARK identifiers used by Knora must respect the draft ARK specification. The format of Knora\u2019s ARK URLs must be able to change over time, while ensuring that previously generated ARK URLs still work.</p>"},{"location":"05-internals/design/api-v2/ark/#design","title":"Design","text":""},{"location":"05-internals/design/api-v2/ark/#ark-url-format","title":"ARK URL Format","text":"<p>The format of a Knora ARK URL is as follows:</p> <pre><code>http://HOST/ark:/NAAN/VERSION/PROJECT/RESOURCE_UUID[/VALUE_UUID][.TIMESTAMP]\n</code></pre> <ul> <li> <p><code>HOST</code>: the hostname of the ARK resolver.</p> </li> <li> <p><code>NAAN</code>: the Name Assigning Authority Number (NAAN) that the ARK resolver uses.</p> </li> <li> <p><code>VERSION</code>: the version of the Knora ARK URL format being used (always 1 for now).</p> </li> <li> <p><code>PROJECT</code>: the short code of the   project that the resource belongs to.</p> </li> <li> <p><code>RESOURCE_UUID</code>: the resource's unique ID, which is normally a   base64url-encoded UUID, as described in   IRIs for Data.</p> </li> <li> <p><code>VALUE_UUID</code>: optionally, the <code>knora-base:valueHasUUID</code> of one of the   resource's values, normally a   base64url-encoded UUID, as described in   IRIs for Data.</p> </li> <li> <p><code>TIMESTAMP</code>: an optional timestamp indicating that the ARK URL represents   the state of the resource at a specific time in the past. The format   of the timestamp is an ISO 8601   date in Coordinated universal time (UTC), including date, time, and an optional   nano-of-second field (of at most 9 digits), without the characters <code>-</code>, <code>:</code>, and <code>.</code> (because   <code>-</code> and <code>.</code> are reserved characters in ARK, and <code>:</code> would have to be URL-encoded).   Example: <code>20180528T155203897Z</code>.</p> </li> </ul> <p>Following the ARK ID spec, <code>/</code> represents object hierarchy and <code>.</code> represents an object variant. A value is thus contained in a resource, which is contained in its project, which is contained in a repository (represented by the URL version number). A timestamp is a type of variant.</p> <p>Since sub-objects are optional, there is also implicitly an ARK URL for each project, as well as for the repository as a whole.</p> <p>The <code>RESOURCE_UUID</code> and <code>VALUE_UUID</code> are processed as follows:</p> <ol> <li> <p>A check digit is calculated, using the algorithm in    the Scala class <code>org.knora.webapi.util.Base64UrlCheckDigit</code>, and appended    to the UUID.</p> </li> <li> <p>Any <code>-</code> characters in the resulting string are replaced with <code>=</code>, because    <code>base64url</code> encoding uses <code>-</code>, which is a reserved character in ARK URLs.</p> </li> </ol> <p>For example, given a project with ID <code>0001</code>, and using the DaSCH's ARK resolver hostname and NAAN, the ARK URL for the project itself is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001\n</code></pre> <p>Given the Knora resource IRI <code>http://rdfh.ch/0001/0C-0L1kORryKzJAJxxRyRQ</code>, the corresponding ARK URL without a timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY\n</code></pre> <p>The same ARK URL with an optional timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY.20180528T155203897Z\n</code></pre> <p>Given a value with <code>knora-api:valueHasUUID \"4OOf3qJUTnCDXlPNnygSzQ\"</code> in the resource <code>http://rdfh.ch/0001/0C-0L1kORryKzJAJxxRyRQ</code>, and using the DaSCH's ARK resolver hostname and NAAN, the corresponding ARK URL without a timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY/4OOf3qJUTnCDXlPNnygSzQX\n</code></pre> <p>The same ARK URL with an optional timestamp is:</p> <pre><code>http://ark.dasch.swiss/ark:/72163/1/0001/0C=0L1kORryKzJAJxxRyRQY/4OOf3qJUTnCDXlPNnygSzQX.20180604T085622513Z\n</code></pre>"},{"location":"05-internals/design/api-v2/ark/#serving-ark-urls","title":"Serving ARK URLs","text":"<p><code>SmartIri</code> converts Knora resource IRIs to ARK URLs. This conversion is invoked in <code>ReadResourceV2.toJsonLD</code>, when returning a resource's metadata in JSON-LD format.</p>"},{"location":"05-internals/design/api-v2/ark/#resolving-knora-ark-urls","title":"Resolving Knora ARK URLs","text":"<p>A Knora ARK URL is intended to be resolved by the Knora ARK resolver.</p>"},{"location":"05-internals/design/api-v2/content-wrappers/","title":"Content Wrappers","text":"<p>Whenever possible, the same data structures are used to represent the same types of data, regardless of the API operation (reading, creating, or modifying). However, often more data is available in output than in input. For example, when a value is read from the triplestore, its IRI is available, but when it is being created, it does not yet have an IRI.</p> <p>The implementation of API v2 therefore uses content wrappers. For each type, there is a case class that represents the lowest common denominator of the type, the data that will be present regardless of the API operation. For example, the trait <code>ValueContentV2</code> represents a Knora value, regardless of whether it is received as input or returned as output. Case classes such as <code>DateValueContentV2</code> and <code>TextValueContentV2</code> implement this trait.</p> <p>An instance of this lowest-common-denominator class, or \"content class\", can then be wrapped in an instance of an operation-specific class that carries additional data. For example, when a Knora value is returned from the triplestore, a <code>ValueContentV2</code> is wrapped in a <code>ReadValueV2</code>, which additionally contains the value's IRI. When a value is created, it is wrapped in a <code>CreateValueV2</code>, which has the resource IRI and the property IRI, but not the value IRI.</p> <p>A read wrapper can be wrapped in another read wrapper; for example, a <code>ReadResourceV2</code> contains <code>ReadValueV2</code> objects.</p> <p>In general, DSP-API v2 responders deal only with the internal schema. (The exception is <code>OntologyResponderV2</code>, which can return ontology information that exists only in an external schema.) Therefore, a content class needs to be able to convert itself from the internal schema to an external schema (when it is being used for output) and vice versa (when it is being used for input). Each content class class should therefore extend <code>KnoraContentV2</code>, and thus have a <code>toOntologySchema</code> method or converting itself between internal and external schemas, in either direction:</p> <pre><code>/**\n  * A trait for content classes that can convert themselves between internal and internal schemas.\n  *\n  * @tparam C the type of the content class that extends this trait.\n  */\ntrait KnoraContentV2[C &lt;: KnoraContentV2[C]] {\n    this: C =&gt;\n    def toOntologySchema(targetSchema: OntologySchema): C\n}\n</code></pre> <p>Since read wrappers are used only for output, they need to be able convert themselves only from the internal schema to an external schema. Each read wrapper class should extend <code>KnoraReadV2</code>, and thus have a method for doing this:</p> <pre><code>/**\n  * A trait for read wrappers that can convert themselves to external schemas.\n  *\n  * @tparam C the type of the read wrapper that extends this trait.\n  */\ntrait KnoraReadV2[C &lt;: KnoraReadV2[C]] {\n    this: C =&gt;\n    def toOntologySchema(targetSchema: ApiV2Schema): C\n}\n</code></pre>"},{"location":"05-internals/design/api-v2/gravsearch/","title":"Gravsearch Design","text":"<p>For a detailed overview of Gravsearch, see Gravsearch: Transforming SPARQL to query humanities data.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#type-inspection","title":"Type Inspection","text":"<p>The code that converts Gravsearch queries into SPARQL queries, and processes the query results, needs to know the types of the entities that are used in the input query. As explained in Type Inference, these types can be inferred, or they can be specified in the query using type annotations.</p> <p>Type inspection is implemented in the package <code>org.knora.webapi.messages.util.search.gravsearch.types</code>. The entry point to this package is <code>GravsearchTypeInspectionRunner</code>, which is instantiated by <code>SearchResponderV2</code>. The result of type inspection is a <code>GravsearchTypeInspectionResult</code>, in which each typeable entity in the input query is associated with a <code>GravsearchEntityTypeInfo</code>, which can be either:</p> <ul> <li>A <code>PropertyTypeInfo</code>, which specifies the type of object that a property is expected to have.</li> <li>A <code>NonPropertyTypeInfo</code>, which specifies the type of a variable, or the type of an IRI representing a resource or value.</li> </ul>"},{"location":"05-internals/design/api-v2/gravsearch/#identifying-typeable-entities","title":"Identifying Typeable Entities","text":"<p>After parsing a Gravsearch query, <code>SearchResponderV2</code> calls <code>GravsearchTypeInspectionRunner.inspectTypes</code>, passing the WHERE clause of the input query. This method first identifies the entities whose types need to be determined. Each of these entities is represented as a <code>TypeableEntity</code>. To do this, <code>GravsearchTypeInspectionRunner</code> uses <code>QueryTraverser</code> to traverse the WHERE clause, collecting typeable entities in a visitor called <code>TypeableEntityCollectingWhereVisitor</code>. The entities that are considered to need type information are:</p> <ul> <li>All variables.</li> <li>All IRIs except for those that represent type annotations or types.</li> </ul>"},{"location":"05-internals/design/api-v2/gravsearch/#the-type-inspection-pipeline","title":"The Type Inspection Pipeline","text":"<p><code>GravsearchTypeInspectionRunner</code> contains a pipeline of type inspectors, each of which extends <code>GravsearchTypeInspector</code>. There are two type inspectors in the pipeline:</p> <ul> <li><code>AnnotationReadingGravsearchTypeInspector</code>: reads    type annotations included in a Gravsearch query.</li> <li><code>InferringGravsearchTypeInspector</code>: infers the types of entities from the context in which they are used, as well   as from ontology information that it requests from <code>OntologyResponderV2</code>.</li> </ul> <p>Each type inspector takes as input, and returns as output, an <code>IntermediateTypeInspectionResult</code>, which associates each <code>TypeableEntity</code> with zero or more types. Initially, each <code>TypeableEntity</code> has no types.  Each type inspector adds whatever types it finds for each entity. </p> <p>At the end of the pipeline, each entity should have exactly one type. Therefore, to only keep the most specific type for an entity,  the method <code>refineDeterminedTypes</code> refines the determined types by removing those that are base classes of others. However, it can be that inconsistent types are determined for entities. For example, in cases where multiple resource class types  are determined, but one is not a base class of the others. From the following statement </p> <pre><code>{ ?document a beol:manuscript . } UNION { ?document a beol:letter .}\n</code></pre> <p>two inconsistent types can be inferred for <code>?document</code>: <code>beol:letter</code> and <code>beol:manuscript</code>. In these cases, a sanitizer <code>sanitizeInconsistentResourceTypes</code> replaces the inconsistent resource types by  their common base resource class (in the above example, it would be <code>beol:writtenSource</code>). </p> <p>Lastly, an error is returned if</p> <ul> <li>An entity's type could not be determined. The client must add a type annotation to make the query work.</li> <li>Inconsistent types could not be sanitized (an entity appears to have more than one type). The client must correct the query.</li> </ul> <p>If there are no errors, <code>GravsearchTypeInspectionRunner</code> converts the pipeline's output to a <code>GravsearchTypeInspectionResult</code>, in which each entity is associated with exactly one type.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#annotationreadinggravsearchtypeinspector","title":"AnnotationReadingGravsearchTypeInspector","text":"<p>This inspector uses <code>QueryTraverser</code> to traverse the WHERE clause, collecting type annotations in a visitor called <code>AnnotationCollectingWhereVisitor</code>. It then converts each annotation to a <code>GravsearchEntityTypeInfo</code>.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#inferringgravsearchtypeinspector","title":"InferringGravsearchTypeInspector","text":"<p>This inspector first uses <code>QueryTraverser</code> to traverse the WHERE clause, assembling an index of usage information about typeable entities in a visitor called <code>UsageIndexCollectingWhereVisitor</code>. The <code>UsageIndex</code> contains, for example, an index of all the entities that are used as subjects, predicates, or objects, along with the statements in which they are used. It also contains sets of all the Knora class and property IRIs that are used in the WHERE clause. <code>InferringGravsearchTypeInspector</code> then asks <code>OntologyResponderV2</code> for information about those classes and properties, as well as about the classes that are subject types or object types of those properties.</p> <p>Next, the inspector runs inference rules (which extend <code>InferenceRule</code>) on each <code>TypeableEntity</code>. Each rule takes as input a <code>TypeableEntity</code>, the usage index, the ontology information, and the <code>IntermediateTypeInspectionResult</code>, and returns a new <code>IntermediateTypeInspectionResult</code>. For example, <code>TypeOfObjectFromPropertyRule</code> infers an entity's type if the entity is used as the object of a statement and the predicate's <code>knora-api:objectType</code> is known. For each <code>TypeableEntity</code>,  if a type is inferred from a property, the entity and the inferred type are added to  <code>IntermediateTypeInspectionResult.entitiesInferredFromProperty</code>.</p> <p>The inference rules are run repeatedly, because the output of one rule may allow another rule to infer additional information. There are two pipelines of rules: a pipeline for the first iteration of type inference, and a pipeline for subsequent iterations. This is because some rules can return additional information if they are run more than once on the same entity, while others cannot.</p> <p>The number of iterations is limited to <code>InferringGravsearchTypeInspector.MAX_ITERATIONS</code>, but in practice two iterations are sufficient for most realistic queries, and it is difficult to design a query that requires more than six iterations.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#transformation-of-a-gravsearch-query","title":"Transformation of a Gravsearch Query","text":"<p>A Gravsearch query submitted by the client is parsed by <code>GravsearchParser</code> and preprocessed by <code>GravsearchTypeInspector</code> to get type information about the elements used in the query (resources, values, properties etc.) and do some basic sanity checks.</p> <p>In <code>SearchResponderV2</code>, two queries are generated from a given Gravsearch query: a prequery and a main query.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#query-transformers","title":"Query Transformers","text":"<p>The Gravsearch query is passed to <code>QueryTraverser</code> along with a query transformer. Query transformers are classes that implement traits supported by <code>QueryTraverser</code>:</p> <ul> <li><code>WhereTransformer</code>: instructions how to convert statements in the WHERE clause of a SPARQL query    (to generate the prequery's Where clause).</li> </ul> <p>To improve query performance, this trait defines the method <code>optimiseQueryPatterns</code> whose implementation can call  private methods to optimise the generated SPARQL. For example, before transformation of statements in WHERE clause, query  pattern orders must be optimised by moving <code>LuceneQueryPatterns</code> to the beginning and <code>isDeleted</code> statement patterns to the end of the WHERE clause. </p> <ul> <li><code>AbstractPrequeryGenerator</code> (extends <code>WhereTransformer</code>): converts a Gravsearch query into a prequery;    this one has two implementations for regular search queries and for count queries.</li> <li><code>SelectTransformer</code> (extends <code>WhereTransformer</code>): transforms a Select query into a Select query with simulated RDF inference.</li> <li><code>ConstructTransformer</code>: transforms a Construct query into a Construct query with simulated RDF inference.</li> </ul>"},{"location":"05-internals/design/api-v2/gravsearch/#prequery","title":"Prequery","text":"<p>The purpose of the prequery is to get an ordered collection of results representing only the IRIs of one page of matching resources and values. Sort criteria can be submitted by the user, but the result is always deterministic also without sort criteria. This is necessary to support paging. A prequery is a SPARQL SELECT query.</p> <p>The classes involved in generating prequeries can be found in <code>org.knora.webapi.messages.util.search.gravsearch.prequery</code>.</p> <p>If the client submits a count query, the prequery returns the overall number of hits, but not the results themselves.</p> <p>In a first step, before transforming the WHERE clause, query patterns must be further optimised by removing the <code>rdfs:type</code> statement for entities whose type could be inferred from their use with a property IRI, since there would be no need  for explicit <code>rdfs:type</code> statements for them (unless the property IRI from which the type of an entity must be inferred from  is wrapped in an <code>OPTIONAL</code> block). This optimisation takes the Gravsearch query as input (rather than the generated SPARQL), because it uses type information that refers to entities in the Gravsearch query, and the generated SPARQL might have different entities.</p> <p>Next, the Gravsearch query's WHERE clause is transformed and the prequery (SELECT and WHERE clause) is generated from this result. The transformation of the Gravsearch query's WHERE clause relies on the implementation of the abstract class <code>AbstractPrequeryGenerator</code>.</p> <p><code>AbstractPrequeryGenerator</code> contains members whose state is changed during the iteration over the statements of the input query. They can then be used to create the converted query.</p> <ul> <li><code>mainResourceVariable: Option[QueryVariable]</code>:    SPARQL variable representing the main resource of the input query.    Present in the prequery's SELECT clause.</li> <li><code>dependentResourceVariables: mutable.Set[QueryVariable]</code>:    a set of SPARQL variables representing dependent resources in the input query.    Used in an aggregation function in the prequery's SELECT clause (see below).</li> <li><code>dependentResourceVariablesGroupConcat: Set[QueryVariable]</code>:    a set of SPARQL variables representing an aggregation of dependent resources.    Present in the prequery's SELECT clause.</li> <li><code>valueObjectVariables: mutable.Set[QueryVariable]</code>:    a set of SPARQL variables representing value objects.    Used in an aggregation function in the prequery's SELECT clause (see below).</li> <li><code>valueObjectVarsGroupConcat: Set[QueryVariable]</code>:    a set of SPARQL variables representing an aggregation of value objects.    Present in the prequery's SELECT clause.</li> </ul> <p>The variables mentioned above are present in the prequery's result rows because they are part of the prequery's SELECT clause.</p> <p>The following example illustrates the handling of variables. The following Gravsearch query looks for pages with a sequence number of 10 that are part of a book:</p> <pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\n    CONSTRUCT {\n        ?page knora-api:isMainResource true .\n\n        ?page knora-api:isPartOf ?book .\n\n        ?page incunabula:seqnum ?seqnum .\n    } WHERE {\n\n        ?page a incunabula:page .\n\n        ?page knora-api:isPartOf ?book .\n\n        ?book a incunabula:book .\n\n        ?page incunabula:seqnum ?seqnum .\n\n        FILTER(?seqnum = 10)\n\n    }\n</code></pre> <p>The prequery's SELECT clause is built by <code>NonTriplestoreSpecificGravsearchToPrequeryTransformer.getSelectColumns</code>, based on the variables used in the input query's <code>CONSTRUCT</code> clause. The resulting SELECT clause looks as follows:</p> <pre><code>SELECT DISTINCT\n    ?page\n    (GROUP_CONCAT(DISTINCT(IF(BOUND(?book), STR(?book), \"\")); SEPARATOR='') AS ?book__Concat)\n    (GROUP_CONCAT(DISTINCT(IF(BOUND(?seqnum), STR(?seqnum), \"\")); SEPARATOR='') AS ?seqnum__Concat)\n    (GROUP_CONCAT(DISTINCT(IF(BOUND(?book__LinkValue), STR(?book__LinkValue), \"\")); SEPARATOR='') AS ?book__LinkValue__Concat)\n    WHERE {...}\n    GROUP BY ?page\n    ORDER BY ASC(?page)\n    LIMIT 25\n</code></pre> <p><code>?page</code> represents the main resource. When accessing the prequery's result rows, <code>?page</code> contains the IRI of the main resource. The prequery's results are grouped by the main resource so that there is exactly one result row per matching main resource. <code>?page</code> is also used as a sort criterion although none has been defined in the input query. This is necessary to make paging work: results always have to be returned in the same order (the prequery is always deterministic). Like this, results can be fetched page by page using LIMIT and OFFSET.</p> <p>Grouping by main resource requires other results to be aggregated using the function <code>GROUP_CONCAT</code>. <code>?book</code> is used as an argument of the aggregation function. The aggregation's result is accessible in the prequery's result rows as <code>?book__Concat</code>. The variable <code>?book</code> is bound to an IRI. Since more than one IRI could be bound to a variable representing a dependent resource, the results have to be aggregated. <code>GROUP_CONCAT</code> takes two arguments: a collection of strings (IRIs in our use case) and a separator (we use the non-printing Unicode character <code>INFORMATION SEPARATOR ONE</code>). When accessing <code>?book__Concat</code> in the prequery's results containing the IRIs of dependent resources,  the string has to be split with the separator used in the aggregation function. The result is a collection of IRIs representing dependent resources. The same logic applies to value objects.</p> <p>Each <code>GROUP_CONCAT</code> checks whether the concatenated variable is bound in each result in the group; if a variable is unbound, we concatenate an empty string. This is necessary because, in Apache Jena (and perhaps other triplestores), \"If <code>GROUP_CONCAT</code> has an unbound value in the list of values to concat, the overall result is 'error'\" (see this Jena issue).</p> <p>If the input query contains a <code>UNION</code>, and a variable is bound in one branch of the <code>UNION</code> and not in another branch, it is possible that the prequery will return more than one row per main resource. To deal with this situation, <code>SearchResponderV2</code> merges rows that contain the same main resource IRI.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#main-query","title":"Main Query","text":"<p>The purpose of the main query is to get all requested information  about the main resource, dependent resources, and value objects. The IRIs of those resources and value objects were returned by the prequery. Since the prequery only returns resources and value objects matching the input query's criteria, the main query can specifically ask for more detailed information on these resources and values  without having to reconsider these criteria.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#generating-the-main-query","title":"Generating the Main Query","text":"<p>The main query is a SPARQL CONSTRUCT query. Its generation is handled by the method <code>GravsearchMainQueryGenerator.createMainQuery</code>. It takes three arguments: <code>mainResourceIris: Set[IriRef], dependentResourceIris: Set[IriRef], valueObjectIris: Set[IRI]</code>.</p> <p>These sets are constructed based on information about variables representing dependent resources and value objects in the prequery, which is provided by <code>NonTriplestoreSpecificGravsearchToPrequeryTransformer</code>:</p> <ul> <li><code>dependentResourceVariablesGroupConcat</code>: <code>Set(QueryVariable(book__Concat))</code></li> <li><code>valueObjectVariablesGroupConcat</code>: <code>Set(QueryVariable(seqnum__Concat), QueryVariable(book__LinkValue__Concat))</code></li> </ul> <p>From the given Iris, statements are generated that ask for complete information on exactly these resources and values. For any given resource Iri, only the values present in <code>valueObjectIris</code> are to be queried. This is achieved by using SPARQL's <code>VALUES</code> expression for the main resource and dependent resources as well as for values.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#processing-the-main-querys-results","title":"Processing the Main Query's results","text":"<p>To do the permission checking, the results of the main query are passed to <code>ConstructResponseUtilV2.splitMainResourcesAndValueRdfData</code>, which transforms a <code>SparqlConstructResponse</code> (a set of RDF triples) into a structure organized by main resource Iris. In this structure, dependent resources and values are nested and can be accessed via their main resource, and resources and values that the user does not have permission to see are filtered out. As a result, a page of results may contain fewer than the maximum allowed number of results per page, even if more pages of results are available.</p> <p><code>MainQueryResultProcessor.getRequestedValuesFromResultsWithFullGraphPattern</code> then filters out values that the user did not explicitly ask for in the input query.</p> <p>Finally, <code>ConstructResponseUtilV2.createApiResponse</code> transforms the query results into an API response (a <code>ReadResourcesSequenceV2</code>). If the number of main resources found (even if filtered out because of permissions) is equal to the maximum allowed page size, the predicate <code>knora-api:mayHaveMoreResults: true</code> is included in the response.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#inference","title":"Inference","text":"<p>Gravsearch queries support a subset of RDFS reasoning  (see Inference in the API documentation on Gravsearch).  This is implemented as follows:</p> <p>To simulate RDF inference, the API expands all <code>rdfs:subClassOf</code> and <code>rdfs:subPropertyOf</code> statements  using <code>UNION</code> statements for all subclasses and subproperties from the ontologies  (equivalent to <code>rdfs:subClassOf*</code> and <code>rdfs:subPropertyOf*</code>).  Similarly, the API replaces <code>knora-api:standoffTagHasStartAncestor</code> with <code>knora-base:standoffTagHasStartParent*</code>.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#optimisation-of-generated-sparql","title":"Optimisation of generated SPARQL","text":"<p>The triplestore-specific transformers in <code>SparqlTransformer.scala</code> can run optimisations on the generated SPARQL, in the method <code>optimiseQueryPatterns</code> inherited from <code>WhereTransformer</code>. For example, <code>moveLuceneToBeginning</code> moves Lucene queries to the beginning of the block in which they occur.</p>"},{"location":"05-internals/design/api-v2/gravsearch/#query-optimization-by-topological-sorting-of-statements","title":"Query Optimization by Topological Sorting of Statements","text":"<p>In Jena Fuseki, the performance of a query highly depends on the order of the query statements.  For example, a query such as the one below:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n\nCONSTRUCT {\n  ?letter knora-api:isMainResource true .\n  ?letter ?linkingProp1  ?person1 .\n  ?letter ?linkingProp2  ?person2 .\n  ?letter beol:creationDate ?date .\n} WHERE {\n  ?letter beol:creationDate ?date .\n\n  ?letter ?linkingProp1 ?person1 .\n  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient )\n\n  ?letter ?linkingProp2 ?person2 .\n  FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient )\n\n  ?person1 beol:hasIAFIdentifier ?gnd1 .\n  ?gnd1 knora-api:valueAsString \"(DE-588)118531379\" .\n\n  ?person2 beol:hasIAFIdentifier ?gnd2 .\n  ?gnd2 knora-api:valueAsString \"(DE-588)118696149\" .\n} ORDER BY ?date\n</code></pre> <p>takes a very long time with Fuseki. The performance of this query can be improved by moving up the statements with literal objects that are not dependent on any other statement:</p> <pre><code>  ?gnd1 knora-api:valueAsString \"(DE-588)118531379\" .\n  ?gnd2 knora-api:valueAsString \"(DE-588)118696149\" .\n</code></pre> <p>The rest of the query then reads:</p> <pre><code>  ?person1 beol:hasIAFIdentifier ?gnd1 .\n  ?person2 beol:hasIAFIdentifier ?gnd2 .\n  ?letter ?linkingProp1 ?person1 .\n  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient )\n\n  ?letter ?linkingProp2 ?person2 .\n  FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient )\n ?letter beol:creationDate ?date .\n</code></pre> <p>Since users cannot be expected to know about performance of triplestores in order to write efficient queries,  an optimization method to automatically rearrange the statements of the given queries has been implemented.  Upon receiving the Gravsearch query, the algorithm converts the query to a graph. For each statement pattern, the subject of the statement is the origin node, the predicate is a directed edge, and the object  is the target node. For the query above, this conversion would result in the following graph:</p> <p></p> <p>The Graph for Scala library is used to construct the graph and sort it using Kahn's  topological sorting algorithm.</p> <p>The algorithm returns the nodes of the graph ordered in several layers, where the  root element <code>?letter</code> is in layer 0, <code>[?date, ?person1, ?person2]</code> are in layer 1, <code>[?gnd1, ?gnd2]</code> in layer 2, and the  leaf nodes <code>[(DE-588)118531379, (DE-588)118696149]</code> are given in the last layer (i.e. layer 3).  According to Kahn's algorithm, there are multiple valid permutations of the topological order. The graph in the example above has 24 valid permutations of topological order. Here are two of them (nodes are ordered from left to right with the  highest order to the lowest):</p> <ul> <li><code>(?letter, ?date, ?person2, ?person1, ?gnd2, ?gnd1, (DE-588)118696149, (DE-588)118531379)</code> </li> <li><code>(?letter, ?date, ?person1, ?person2, ?gnd1, ?gnd2, (DE-588)118531379, (DE-588)118696149)</code>.   </li> </ul> <p>From all valid topological orders, one is chosen based on certain criteria; for example, the leaf node should not  belong to a statement that has predicate <code>rdf:type</code>, since that could match all resources of the specified type. Once the best order is chosen, it is used to re-arrange the query statements. Starting from the last leaf node, i.e.  <code>(DE-588)118696149</code>, the method finds the statement pattern which has this node as its object, and brings this statement  to the top of the query. This rearrangement continues so that the statements with the fewest dependencies on other  statements are all brought to the top of the query. The resulting query is as follows:</p> <pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;\n\nCONSTRUCT {\n  ?letter knora-api:isMainResource true .\n  ?letter ?linkingProp1  ?person1 .\n  ?letter ?linkingProp2  ?person2 .\n  ?letter beol:creationDate ?date .\n} WHERE {\n  ?gnd2 knora-api:valueAsString \"(DE-588)118696149\" .\n  ?gnd1 knora-api:valueAsString \"(DE-588)118531379\" .\n  ?person2 beol:hasIAFIdentifier ?gnd2 .\n  ?person1 beol:hasIAFIdentifier ?gnd1 .\n  ?letter ?linkingProp2 ?person2 .\n  ?letter ?linkingProp1 ?person1 .\n  ?letter beol:creationDate ?date .\n  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient )\n  FILTER(?linkingProp2 = beol:hasAuthor || ?linkingProp2 = beol:hasRecipient )\n} ORDER BY ?date\n</code></pre> <p>Note that position of the FILTER statements does not play a significant role in the optimization. </p> <p>If a Gravsearch query contains statements in <code>UNION</code>, <code>OPTIONAL</code>, <code>MINUS</code>, or <code>FILTER NOT EXISTS</code>, they are reordered  by defining a graph per block. For example, consider the following query with <code>UNION</code>:</p> <pre><code>{\n    ?thing anything:hasRichtext ?richtext .\n    FILTER knora-api:matchText(?richtext, \"test\")\n    ?thing anything:hasInteger ?int .\n    ?int knora-api:intValueAsInt 1 .\n}\nUNION\n{\n    ?thing anything:hasText ?text .\n    FILTER knora-api:matchText(?text, \"test\")\n    ?thing anything:hasInteger ?int .\n    ?int knora-api:intValueAsInt 3 .\n}\n</code></pre> <p>This would result in one graph per block of the <code>UNION</code>. Each graph is then sorted, and the statements of its  block are rearranged according to the topological order of graph. This is the result:</p> <pre><code>{\n   ?int knora-api:intValueAsInt 1 .\n    ?thing anything:hasRichtext ?richtext .\n    ?thing anything:hasInteger ?int .\n    FILTER(knora-api:matchText(?richtext, \"test\"))\n} UNION {\n    ?int knora-api:intValueAsInt 3 .\n    ?thing anything:hasText ?text .\n    ?thing anything:hasInteger ?int .\n    FILTER(knora-api:matchText(?text, \"test\"))\n}\n</code></pre>"},{"location":"05-internals/design/api-v2/gravsearch/#cyclic-graphs","title":"Cyclic Graphs","text":"<p>The topological sorting algorithm can only be used for DAGs (directed acyclic graphs). However, a Gravsearch query can contains statements that result in a cyclic graph, e.g.:</p> <pre><code>PREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/simple/v2#&gt;\nPREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;\n\nCONSTRUCT {\n    ?thing knora-api:isMainResource true .\n} WHERE {\n  ?thing anything:hasOtherThing ?thing1 .\n  ?thing1 anything:hasOtherThing ?thing2 .\n  ?thing2 anything:hasOtherThing ?thing . \n}\n</code></pre> <p>In this case, the algorithm tries to break the cycles in order to sort the graph. If this is not possible, the query statements are not reordered.</p>"},{"location":"05-internals/design/api-v2/json-ld/","title":"JSON-LD","text":""},{"location":"05-internals/design/api-v2/json-ld/#returning-a-json-ld-response","title":"Returning a JSON-LD Response","text":"<p>Each API response is represented by a message class that extends <code>KnoraJsonLDResponseV2</code>, which has a method <code>toJsonLDDocument</code> that specifies the target ontology schema. The implementation of this method constructs a <code>JsonLDDocument</code>, in which all object keys are full IRIs (no prefixes are used), but in which the JSON-LD context also specifies the prefixes that will be used when the document is returned to the client. The function <code>JsonLDUtil.makeContext</code> is a convenient way to construct the JSON-LD context.</p> <p>Since <code>toJsonLDDocument</code> has to return an object that uses the specified ontology schema, the recommended design is to separate schema conversion as much as possible from JSON-LD generation. As a first step, schema conversion (or at the very least, the conversion of Knora type IRIs to the target schema) can be done via an implementation of <code>KnoraReadV2</code>:</p> <pre><code>/**\n  * A trait for read wrappers that can convert themselves to external schemas.\n  *\n  * @tparam C the type of the read wrapper that extends this trait.\n  */\ntrait KnoraReadV2[C &lt;: KnoraReadV2[C]] {\n    this: C =&gt;\n    def toOntologySchema(targetSchema: ApiV2Schema): C\n}\n</code></pre> <p>This means that the response message class has the method <code>toOntologySchema</code>, which returns a copy of the same message, with Knora type IRIs (and perhaps other content) adjusted for the target schema. (See Smart IRIs on how to convert Knora type IRIs to the target schema.)</p> <p>The response message class could then have a private method called <code>generateJsonLD</code>, which generates a <code>JsonLDDocument</code> that has the correct structure for the target schema, like this:</p> <pre><code>private def generateJsonLD(targetSchema: ApiV2Schema, settings: KnoraSettingsImpl, schemaOptions: Set[SchemaOption]): JsonLDDocument\n</code></pre> <p>This way, the implementation of <code>toJsonLDDocument</code> can call <code>toOntologySchema</code>, then construct a <code>JsonLDDocument</code> from the resulting object. For example:</p> <pre><code>    override def toJsonLDDocument(targetSchema: ApiV2Schema, settings: KnoraSettingsImpl, schemaOptions: Set[SchemaOption] = Set.empty): JsonLDDocument = {\n        toOntologySchema(targetSchema).generateJsonLD(\n            targetSchema = targetSchema,\n            settings = settings,\n            schemaOptions = schemaOptions\n        )\n    }\n</code></pre>"},{"location":"05-internals/design/api-v2/json-ld/#selecting-the-response-schema","title":"Selecting the Response Schema","text":"<p>Most routes complete by calling <code>RouteUtilV2.runRdfRouteWithFuture</code>, which calls the response message's <code>toJsonLDDocument</code> method. The <code>runRdfRouteWithFuture</code> function has a parameter that enables the route to select the schema that should be used in the response. It is up to each route to determine what the appropriate response schema should be. Some routes support only one response schema. Others allow the client to choose. To use the schema requested by the client, the route can call <code>RouteUtilV2.getOntologySchema</code>:</p> <pre><code>RouteUtilV2.runRdfRouteWithFuture(\n    requestMessageF = requestMessageFuture,\n    requestContext = requestContext,\n    settings = settings,\n    responderManager = responderManager,\n    log = log,\n    targetSchema = targetSchema,\n    schemaOptions = schemaOptions\n)\n</code></pre> <p>If the route only supports one schema, it can specify the schema directly instead:</p> <pre><code>RouteUtilV2.runRdfRouteWithFuture(\n    requestMessageF = requestMessageFuture,\n    requestContext = requestContext,\n    settings = settings,\n    responderManager = responderManager,\n    log = log,\n    targetSchema = ApiV2Complex,\n    schemaOptions = RouteUtilV2.getSchemaOptions(requestContext)\n)\n</code></pre>"},{"location":"05-internals/design/api-v2/json-ld/#generating-other-rdf-formats","title":"Generating Other RDF Formats","text":"<p><code>RouteUtilV2.runRdfRouteWithFuture</code> implements HTTP content negotiation. After determining the client's preferred format, it asks the <code>KnoraResponseV2</code> to convert itself into that format. <code>KnoraResponseV2</code> has an abstract <code>format</code> method, whose implementations select the most efficient conversion between the response message's internal representation (which could be JSON-LD or Turtle) and the requested format.</p>"},{"location":"05-internals/design/api-v2/ontology-management/","title":"Ontology Management","text":"<p>The core of Knora's ontology management logic is <code>OntologyResponderV2</code>. It is responsible for:</p> <ul> <li>Loading ontologies from the triplestore when Knora starts.</li> <li>Maintaining an ontology cache to improve performance.</li> <li>Returning requested ontology entities from the cache. Requests for ontology   information never access the triplestore.</li> <li>Creating and updating ontologies in response to API requests.</li> <li>Ensuring that all user-created ontologies are consistent and conform to knora-base.</li> </ul> <p>When Knora starts it will load all ontologies from the triplestore into the ontology cache:</p> <ol> <li>Loads all ontologies found in the triplestore into suitable Scala data structures,    which include indexes of relations between entities (e.g. <code>rdfs:subClassOf</code> relations),    to facilitate validity checks.</li> <li>Checks user-created ontologies for consistency and conformance to <code>knora-base</code>,    according to the rules described in    Summary of Restrictions on User-Created Ontologies.</li> <li>Caches all the loaded ontologies using <code>CacheUtil</code>.</li> </ol> <p>The ontology responder assumes that nothing except itself modifies ontologies in the triplestore while Knora is running. Therefore, the ontology cache is updated only when the ontology responder processes a request to update an ontology.</p> <p>By design, the ontology responder can update only one ontology entity per request, to simplify the necessary validity checks. This requires the client to construct an ontology by submitting a sequence of requests in a certain order, as explained in Ontology Updates.</p> <p>The ontology responder mainly works with ontologies in the internal schema. However, it knows that some entities in built-in ontologies have hard-coded definitions in external schemas, and it checks the relevant transformation rules and returns those entities directly when they are requested (see Generation of Ontologies in External Schemas).</p>"},{"location":"05-internals/design/api-v2/ontology-schemas/","title":"Ontology Schemas","text":""},{"location":"05-internals/design/api-v2/ontology-schemas/#ontologyschema-type","title":"OntologySchema Type","text":"<p>As explained in API Schema, Knora can represent the same RDF data in different forms: an \"internal schema\" for use in the triplestore, and different \"external schemas\" for use in Knora API v2. Different schemas use different IRIs, as explained in Knora IRIs. Internally, Knora uses a SmartIri class to convert IRIs between schemas.</p> <p>The data type representing a schema itself is <code>OntologySchema</code>, which uses the sealed trait pattern:</p> <pre><code>package org.knora.webapi\n\n/**\n  * Indicates the schema that a Knora ontology or ontology entity conforms to.\n  */\nsealed trait OntologySchema\n\n/**\n  * The schema of DSP ontologies and entities that are used in the triplestore.\n  */\ncase object InternalSchema extends OntologySchema\n\n/**\n  * The schema of DSP ontologies and entities that are used in API v2.\n  */\nsealed trait ApiV2Schema extends OntologySchema\n\n/**\n  * The simple schema for representing DSP ontologies and entities. This schema represents values as literals\n  * when possible.\n  */\ncase object ApiV2Simple extends ApiV2Schema\n\n/**\n  * The default (or complex) schema for representing DSP ontologies and entities. This\n  * schema always represents values as objects.\n  */\ncase object ApiV2Complex extends ApiV2Schema\n\n/**\n  * A trait representing options that can be submitted to configure an ontology schema.\n  */\nsealed trait SchemaOption\n\n/**\n  * A trait representing options that affect the rendering of markup when text values are returned.\n  */\nsealed trait MarkupRendering extends SchemaOption\n\n/**\n  * Indicates that markup should be rendered as XML when text values are returned.\n  */\ncase object MarkupAsXml extends MarkupRendering\n\n/**\n  * Indicates that markup should not be returned with text values, because it will be requested\n  * separately as standoff.\n  */\ncase object MarkupAsStandoff extends MarkupRendering\n\n/**\n  * Indicates that no markup should be returned with text values. Used only internally.\n  */\ncase object NoMarkup extends MarkupRendering\n\n/**\n  * Utility functions for working with schema options.\n  */\nobject SchemaOptions {\n    /**\n      * A set of schema options for querying all standoff markup along with text values.\n      */\n    val ForStandoffWithTextValues: Set[SchemaOption] = Set(MarkupAsXml)\n\n    /**\n      * A set of schema options for querying standoff markup separately from text values.\n      */\n    val ForStandoffSeparateFromTextValues: Set[SchemaOption] = Set(MarkupAsStandoff)\n\n    /**\n      * Determines whether standoff should be queried when a text value is queried.\n      *\n      * @param targetSchema the target API schema.\n      * @param schemaOptions the schema options submitted with the request.\n      * @return `true` if standoff should be queried.\n      */\n    def queryStandoffWithTextValues(targetSchema: ApiV2Schema, schemaOptions: Set[SchemaOption]): Boolean = {\n        targetSchema == ApiV2Complex &amp;&amp; !schemaOptions.contains(MarkupAsStandoff)\n    }\n\n    /**\n      * Determines whether markup should be rendered as XML.\n      *\n      * @param targetSchema the target API schema.\n      * @param schemaOptions the schema options submitted with the request.\n      * @return `true` if markup should be rendered as XML.\n      */\n    def renderMarkupAsXml(targetSchema: ApiV2Schema, schemaOptions: Set[SchemaOption]): Boolean = {\n        targetSchema == ApiV2Complex &amp;&amp; !schemaOptions.contains(MarkupAsStandoff)\n    }\n\n    /**\n      * Determines whether markup should be rendered as standoff, separately from text values.\n      *\n      * @param targetSchema the target API schema.\n      * @param schemaOptions the schema options submitted with the request.\n      * @return `true` if markup should be rendered as standoff.\n      */\n    def renderMarkupAsStandoff(targetSchema: ApiV2Schema, schemaOptions: Set[SchemaOption]): Boolean = {\n        targetSchema == ApiV2Complex &amp;&amp; schemaOptions.contains(MarkupAsStandoff)\n    }\n}\n</code></pre> <p>This class hierarchy allows method declarations to restrict the schemas they accept. A method that can accept any schema can take a parameter of type <code>OntologySchema</code>, while a method that accepts only external schemas can take a parameter of type <code>ApiV2Schema</code>. For examples, see Content Wrappers.</p>"},{"location":"05-internals/design/api-v2/ontology-schemas/#generation-of-ontologies-in-external-schemas","title":"Generation of Ontologies in External Schemas","text":"<p>Ontologies are stored only in the internal schema, and are converted on the fly to external schemas. For each external schema, there is a Scala object in <code>org.knora.webapi.messages.v2.responder.ontologymessages</code> that provides rules for this conversion:</p> <ul> <li><code>KnoraApiV2SimpleTransformationRules</code> for the API v2 simple schema</li> <li><code>KnoraApiV2WithValueObjectsTransformationRules</code> for the API v2 complex schema</li> </ul> <p>Since these are Scala objects rather than classes, they are initialised before the Akka <code>ActorSystem</code> starts, and therefore need a special instance of Knora's <code>StringFormatter</code> class (see Smart IRIs).</p> <p>Each of these rule objects implements this trait:</p> <pre><code>/**\n  * A trait for objects that provide rules for converting an ontology from the internal schema to an external schema.\n  * * See also [[OntologyConstants.CorrespondingIris]].\n  */\ntrait OntologyTransformationRules {\n    /**\n      * The metadata to be used for the transformed ontology.\n      */\n    val ontologyMetadata: OntologyMetadataV2\n\n    /**\n      * Properties to remove from the ontology before converting it to the target schema.\n      * See also [[OntologyConstants.CorrespondingIris]].\n      */\n    val internalPropertiesToRemove: Set[SmartIri]\n\n    /**\n      * Classes to remove from the ontology before converting it to the target schema.\n      */\n    val internalClassesToRemove: Set[SmartIri]\n\n    /**\n      * After the ontology has been converted to the target schema, these cardinalities must be\n      * added to the specified classes.\n      */\n    val externalCardinalitiesToAdd: Map[SmartIri, Map[SmartIri, KnoraCardinalityInfo]]\n\n    /**\n      * Classes that need to be added to the ontology after converting it to the target schema.\n      */\n    val externalClassesToAdd: Map[SmartIri, ReadClassInfoV2]\n\n    /**\n      * Properties that need to be added to the ontology after converting it to the target schema.\n      * See also [[OntologyConstants.CorrespondingIris]].\n      */\n    val externalPropertiesToAdd: Map[SmartIri, ReadPropertyInfoV2]\n}\n</code></pre> <p>These rules are applied to <code>knora-base</code> as well as to user-created ontologies. For example, <code>knora-base:Resource</code> has different cardinalities depending on its schema (<code>knora-api:Resource</code> has an additional cardinality on <code>knora-api:hasIncomingLink</code>), and this is therefore also true of its user-created subclasses. The transformation is implemented:</p> <ul> <li>In the implementations of the <code>toOntologySchema</code> method in classes defined in   <code>OntologyMessagesV2.scala</code>: <code>ReadOntologyV2</code>, <code>ReadClassInfoV2</code>, <code>ClassInfoContentV2</code>,   <code>PropertyInfoContentV2</code>, and <code>OntologyMetadataV2</code>.</li> <li>In <code>OntologyResponderV2.getEntityInfoResponseV2</code>, which handles requests for   specific ontology entities. If the requested entity is hard-coded in a transformation   rule, this method returns the hard-coded external entity, otherwise it returns the relevant   internal entity.</li> </ul>"},{"location":"05-internals/design/api-v2/overview/","title":"API v2 Design Overview","text":""},{"location":"05-internals/design/api-v2/overview/#general-principles","title":"General Principles","text":"<ul> <li>DSP-API v2 requests and responses are RDF documents. Any API v2   response can be returned as JSON-LD,   Turtle,   or RDF/XML.</li> <li>Each class or property used in a request or response has a definition in an ontology, which Knora can serve.</li> <li>Response formats are reused for different requests whenever   possible, to minimise the number of different response formats a   client has to handle. For example, any request for one or more   resources (such as a search result, or a request for one specific   resource) returns a response in the same format.</li> <li>Response size is limited by design. Large amounts of data must be   retrieved by requesting small pages of data, one after the other.</li> <li>Responses that provide data are distinct from responses that provide   definitions (i.e. ontology entities). Data responses indicate which   types are used, and the client can request information about these   types separately.</li> </ul>"},{"location":"05-internals/design/api-v2/overview/#api-schemas","title":"API Schemas","text":"<p>The types used in the triplestore are not exposed directly in the API. Instead, they are mapped onto API 'schemas'. Two schemas are currently provided.</p> <ul> <li>A complex schema, which is suitable both for reading and for editing   data. The complex schema represents values primarily as complex objects.</li> <li>A simple schema, which is suitable for reading data but not for   editing it. The simple schema facilitates interoperability between   DSP ontologies and non-DSP ontologies, since it represents   values primarily as literals.</li> </ul> <p>Each schema has its own type IRIs, which are derived from the ones used in the triplestore. For details of these different IRI formats, see Knora IRIs.</p>"},{"location":"05-internals/design/api-v2/overview/#implementation","title":"Implementation","text":""},{"location":"05-internals/design/api-v2/overview/#json-ld-parsing-and-formatting","title":"JSON-LD Parsing and Formatting","text":"<p>Each API response is represented by a class that extends <code>KnoraResponseV2</code>, which has a method <code>toJsonLDDocument</code> that specifies the target schema. It is currently up to each route to determine what the appropriate response schema should be. Some routes will support only one response schema. Others will allow the client to choose, and there will be one or more standard ways for the client to specify the desired response schema.</p> <p>A route calls <code>RouteUtilV2.runRdfRoute</code>, passing a request message and a response schema. When <code>RouteUtilV2</code> gets the response message from the responder, it calls <code>toJsonLDDocument</code> on it, specifying that schema. The response message returns a <code>JsonLDDocument</code>, which is a simple data structure that is then converted to Java objects and passed to the JSON-LD Java library for formatting. In general, <code>toJsonLDDocument</code> is implemented in two stages: first the object converts itself to the target schema, and then the resulting object is converted to a <code>JsonLDDocument</code>.</p> <p>A route that receives JSON-LD requests should use <code>JsonLDUtil.parseJsonLD</code> to convert each request to a <code>JsonLDDocument</code>.</p>"},{"location":"05-internals/design/api-v2/overview/#generation-of-other-rdf-formats","title":"Generation of Other RDF Formats","text":"<p><code>RouteUtilV2.runRdfRoute</code> implements HTTP content negotiation, and converts JSON-LD responses into Turtle or RDF/XML as appropriate.</p>"},{"location":"05-internals/design/api-v2/overview/#operation-wrappers","title":"Operation Wrappers","text":"<p>Whenever possible, the same data structures are used for input and output. Often more data is available in output than in input. For example, when a value is read from the triplestore, its IRI is available, but when it is being created, it does not yet have an IRI. In such cases, there is a class like <code>ValueContentV2</code>, which represents the data that is used both for input and for output. When a value is read, a <code>ValueContentV2</code> is wrapped in a <code>ReadValueV2</code>, which additionally contains the value's IRI. When a value is created, it is wrapped in a <code>CreateValueV2</code>, which has the resource IRI and the property IRI, but not the value IRI.</p> <p>A <code>Read*</code> wrapper can be wrapped in another <code>Read*</code> wrapper; for example, a <code>ReadResourceV2</code> contains <code>ReadValueV2</code> objects.</p> <p>Each <code>*Content*</code> class should extend <code>KnoraContentV2</code> and thus have a <code>toOntologySchema</code> method or converting itself between internal and external schemas, in either direction.</p> <p>Each <code>Read*</code> wrapper class should have a method for converting itself to JSON-LD in a particular external schema. If the <code>Read*</code> wrapper is a <code>KnoraResponseV2</code>, this method is <code>toJsonLDDocument</code>.</p>"},{"location":"05-internals/design/api-v2/overview/#smart-iris","title":"Smart IRIs","text":""},{"location":"05-internals/design/api-v2/overview/#usage","title":"Usage","text":"<p>The <code>SmartIri</code> trait can be used to parse and validate IRIs, and in particular for converting Knora type IRIs between internal and external schemas. It validates each IRI it parses. To use it, import the following:</p> <pre><code>import org.knora.webapi.messages.{SmartIri, StringFormatter}\nimport org.knora.webapi.messages.IriConversions.*\n</code></pre> <p>Ensure that an implicit instance of <code>StringFormatter</code> is in scope:</p> <pre><code>implicit val stringFormatter: StringFormatter = StringFormatter.getGeneralInstance\n</code></pre> <p>Then, if <code>iriStr</code> is a string representing an IRI, you can can convert it to a <code>SmartIri</code> like this:</p> <pre><code>val iri: SmartIri = iriStr.toSmartIri\n</code></pre> <p>If the IRI came from a request, use this method to throw a specific exception if the IRI is invalid:</p> <pre><code>val iri: SmartIri = iriStr.toSmartIriWithErr(\n    () =&gt; throw BadRequestException(s\"Invalid IRI: $iriStr\")\n)\n</code></pre> <p>You can then use methods such as <code>SmartIri.isKnoraApiV2EntityIri</code> and <code>SmartIri.getProjectCode</code> to obtain information about the IRI. To convert it to another schema, call <code>SmartIri.toOntologySchema</code>. Converting a non-Knora IRI returns the same IRI.</p> <p>If the IRI represents a Knora internal value class such as <code>knora-base:TextValue</code>, converting it to the <code>ApiV2Simple</code> schema will return the corresponding simplified type, such as <code>xsd:string</code>. But this conversion is not performed in the other direction (external to internal), since this would require knowledge of the context in which the IRI is being used.</p> <p>The performance penalty for using a <code>SmartIri</code> instead of a string is very small. Instances are automatically cached once they are constructed. Parsing and caching a <code>SmartIri</code> instance takes about 10-20 \u00b5s, and retrieving a cached <code>SmartIri</code> takes about 1 \u00b5s.</p> <p>There is no advantage to using <code>SmartIri</code> for data IRIs, since they are not schema-specific (and are not cached). If a data IRI has been received from a client request, it is better just to validate it using <code>StringFormatter.validateAndEscapeIri</code>.</p>"},{"location":"05-internals/design/api-v2/overview/#smart-iri-implementation","title":"Smart IRI Implementation","text":"<p>The smart IRI implementation, <code>SmartIriImpl</code>, is nested in the <code>StringFormatter</code> class, because it uses Knora's hostname, which isn't available until the Akka ActorSystem has started. However, this means that the type of a <code>SmartIriImpl</code> instance is dependent on the instance of <code>StringFormatter</code> that constructed it. Therefore, instances of <code>SmartIriImpl</code> created by different instances of <code>StringFormatter</code> can't be compared directly.</p> <p>There are in fact two instances of <code>StringFormatter</code>:</p> <ul> <li>one returned by <code>StringFormatter.getGeneralInstance</code> which is   available after Akka has started and has the API server's hostname   (and can therefore provide <code>SmartIri</code> instances capable of parsing   IRIs containing that hostname). This instance is used throughout the   DSP-API server.</li> <li>one returned by <code>StringFormatter.getInstanceForConstantOntologies</code>,   which is available before Akka has started, and is used only by the   hard-coded constant <code>knora-api</code> ontologies.</li> </ul> <p>This is the reason for the existence of the <code>SmartIri</code> trait, which is a top-level definition and has its own <code>equals</code> and <code>hashCode</code> methods. Instances of <code>SmartIri</code> can thus be compared (e.g. to use them as unique keys in collections), regardless of which instance of <code>StringFormatter</code> created them.</p>"},{"location":"05-internals/design/api-v2/query-design/","title":"SPARQL Query Design","text":""},{"location":"05-internals/design/api-v2/query-design/#inference","title":"Inference","text":"<p>DSP-API does not require the triplestore to perform inference,  as different triplestores implement inference quite differently,  so that taking advantage of inference would require triplestore specific code, which is not well maintainable.  Instead, the API simulates inference for each Gravsearch query, so that the expected results are returned.</p> <p>Gravsearch queries currently need to do the following:</p> <ul> <li>Given a base property, find triples using a subproperty as predicate, and   return the subproperty used in each case.</li> <li>Given a base class, find triples using an instance of subclass as subject or   object, and return the subclass used in each case.</li> </ul> <p>Without inference, this can be done using property path syntax.</p> <pre><code>CONSTRUCT {\n  ?resource a ?resourceClass .\n  ?resource ?resourceValueProperty ?valueObject.\nWHERE {\n  ?resource a ?resourceClass .\n  ?resourceType rdfs:subClassOf* knora-base:Resource .\n  ?resource ?resourceValueProperty ?valueObject .\n  ?resourceValueProperty rdfs:subPropertyOf* knora-base:hasValue .\n</code></pre> <p>This query:</p> <ul> <li> <p>Checks that the queried resource belongs to a subclass of <code>knora-base:Resource</code>.</p> </li> <li> <p>Returns the class that the resource explicitly belongs to.</p> </li> <li> <p>Finds the Knora values attached to the resource, and returns each value along with   the property that explicitly attaches it to the resource.</p> </li> </ul> <p>However, such a query is very inefficient.  Instead, the API does inference on the query, so that the relevant information can be found in a timely manner.</p> <p>For this, the query is analyzed to check which project ontologies are relevant to the query.  If an ontology is not relevant to a query,  then all class and property definitions of this ontology are disregarded for inference.</p> <p>Then, each statement that requires inference (i.e. that could be phrased with property path syntax, as described above)  is cross-referenced with the relevant ontologies,  to see which property/class definitions would fit the statement according to the rules of RDF inference.  And each of those definitions is added to the query as a separate <code>UNION</code> statement.</p> <p>E.g.: Given the resource class <code>B</code> is a subclass of <code>A</code> and the property <code>hasY</code> is a subproperty of <code>hasX</code>,  then the following query</p> <pre><code>SELECT {\n  ?res ?prop .\n} WHERE {\n  ?res a &lt;A&gt; .\n  ?res &lt;hasX&gt; ?prop .\n}\n</code></pre> <p>can be rewritten as</p> <pre><code>SELECT {\n  ?res ?prop .\n} WHERE {\n  {?res a &lt;A&gt;} UNION {?res a &lt;B&gt;} .\n  {?res &lt;hasX&gt; ?prop} UNION {?res &lt;hasY&gt; ?prop} .\n}\n</code></pre>"},{"location":"05-internals/design/api-v2/query-design/#querying-past-value-versions","title":"Querying Past Value Versions","text":"<p>Value versions are a linked list, starting with the current version. Each value points to the previous version via <code>knora-base:previousValue</code>. The resource points only to the current version.</p> <p>Past value versions are queried in <code>getResourcePropertiesAndValues.scala.txt</code>, which can take a timestamp argument. Given the current value version, we must find the most recent past version that existed at the target date.</p> <p>First, we get the set of previous values that were created on or before the target date:</p> <pre><code>?currentValue knora-base:previousValue* ?valueObject .\n?valueObject knora-base:valueCreationDate ?valueObjectCreationDate .\nFILTER(?valueObjectCreationDate &lt;= \"@versionDate\"^^xsd:dateTime)\n</code></pre> <p>The resulting versions are now possible values of <code>?valueObject</code>. Next, out of this set of versions, we exclude all versions except for the most recent one. We do this by checking, for each <code>?valueObject</code>, whether there is another version, <code>?otherValueObject</code>, that is more recent and was also created before the target date. If such a version exists, we exclude the one we are looking at.</p> <pre><code>FILTER NOT EXISTS {\n    ?currentValue knora-base:previousValue* ?otherValueObject .\n    ?otherValueObject knora-base:valueCreationDate ?otherValueObjectCreationDate .\n\n    FILTER(\n        (?otherValueObjectCreationDate &lt;= \"@versionDate\"^^xsd:dateTime) &amp;&amp;\n        (?otherValueObjectCreationDate &gt; ?valueObjectCreationDate)\n    )\n}\n</code></pre> <p>This excludes all past versions except the one we are interested in.</p>"},{"location":"05-internals/design/api-v2/sipi/","title":"DSP-API and Sipi","text":""},{"location":"05-internals/design/api-v2/sipi/#configuration","title":"Configuration","text":"<p>The DSP-API specific configuration and scripts for Sipi are in the <code>sipi</code> subdirectory of the DSP-API source tree. See the <code>README.md</code> for instructions on how to start Sipi with DSP-API.</p>"},{"location":"05-internals/design/api-v2/sipi/#lua-scripts","title":"Lua Scripts","text":"<p>DSP-API v2 uses custom Lua scripts to control Sipi. These scripts can be found in <code>sipi/scripts</code> in the DSP-API source tree.</p> <p>Each of these scripts expects a JSON Web Token in the URL parameter <code>token</code>. In all cases, the token must be signed by DSP-API, it must have an expiration date and not have expired, its issuer must equal the hostname and port of the API, and its audience must include <code>Sipi</code>. The other contents of the expected tokens are described below.</p>"},{"location":"05-internals/design/api-v2/sipi/#sipiconnector","title":"SipiConnector","text":"<p>In DSP-API, the <code>org.knora.webapi.iiif.SipiConnector</code> handles all communication with Sipi. It blocks while processing each request, to ensure that the number of concurrent requests to Sipi is not greater than <code>akka.actor.deployment./storeManager/iiifManager/sipiConnector.nr-of-instances</code>. If it encounters an error, it returns <code>SipiException</code>.</p>"},{"location":"05-internals/design/api-v2/smart-iris/","title":"Smart IRIs","text":""},{"location":"05-internals/design/api-v2/smart-iris/#usage","title":"Usage","text":"<p>The <code>SmartIri</code> trait can be used to parse and validate IRIs, and in particular for converting Knora type IRIs between internal and external schemas. It validates each IRI it parses. To use it, import the following:</p> <pre><code>import org.knora.webapi.messages.SmartIri\nimport org.knora.webapi.messages.IriConversions._\n</code></pre> <p>Ensure that an implicit instance of <code>StringFormatter</code> is in scope:</p> <pre><code>import org.knora.webapi.messages.StringFormatter\nimplicit val stringFormatter: StringFormatter = StringFormatter.getGeneralInstance\n</code></pre> <p>Then, if you have a string representing an IRI, you can can convert it to a <code>SmartIri</code> like this:</p> <pre><code>val propertyIri: SmartIri = \"http://0.0.0.0:3333/ontology/0001/anything/v2#hasInteger\".toSmartIri\n````\n\nIf the IRI came from a request, use this method to throw a specific\nexception if the IRI is invalid:\n\n```scala\nval propertyIri: SmartIri = propertyIriStr.toSmartIriWithErr(throw BadRequestException(s\"Invalid property IRI: &lt;$propertyIriStr&gt;\"))\n</code></pre> <p>You can then use methods such as <code>SmartIri.isKnoraApiV2EntityIri</code> and <code>SmartIri.getProjectCode</code> to obtain information about the IRI. To convert it to another schema, call <code>SmartIri.toOntologySchema</code>. Converting a non-Knora IRI returns the same IRI.</p> <p>If the IRI represents a Knora internal value class such as <code>knora-base:TextValue</code>, converting it to the <code>ApiV2Simple</code> schema will return the corresponding simplified type, such as <code>xsd:string</code>. But this conversion is not performed in the other direction (external to internal), since this would require knowledge of the context in which the IRI is being used.</p> <p>The performance penalty for using a <code>SmartIri</code> instead of a string is very small. Instances are automatically cached once they are constructed.</p> <p>There is no advantage to using <code>SmartIri</code> for data IRIs, since they are not schema-specific (and are not cached). If a data IRI has been received from a client request, it is better just to validate it using <code>StringFormatter.validateAndEscapeIri</code>, and represent it as an <code>org.knora.webapi.IRI</code> (an alias for <code>String</code>).</p>"},{"location":"05-internals/design/api-v2/smart-iris/#implementation","title":"Implementation","text":"<p>The smart IRI implementation, <code>SmartIriImpl</code>, is nested in the <code>StringFormatter</code> class, because it uses Knora's hostname, which isn't available until the Akka <code>ActorSystem</code> has started. However, this means that the Scala type of a <code>SmartIriImpl</code> instance is dependent on the instance of <code>StringFormatter</code> that constructed it. Therefore, instances of <code>SmartIriImpl</code> created by different instances of <code>StringFormatter</code> can't be compared directly.</p> <p>There are in fact two instances of <code>StringFormatter</code>:</p> <ul> <li>one returned by <code>StringFormatter.getGeneralInstance</code>, which is   available after Akka has started and has the API server's hostname   (and can therefore provide <code>SmartIri</code> instances capable of parsing   IRIs containing that hostname). This instance is used throughout the   DSP-API server.</li> <li>one returned by <code>StringFormatter.getInstanceForConstantOntologies</code>,   which is available before Akka has started, and is used only by the   hard-coded constant <code>knora-api</code> ontologies (see   Generation of Ontologies in External Schemas).</li> </ul> <p>This is the reason for the existence of the <code>SmartIri</code> trait, which is a top-level definition and has its own <code>equals</code> and <code>hashCode</code> methods. Instances of <code>SmartIri</code> can thus be compared (e.g. to use them as unique keys in collections), regardless of which instance of <code>StringFormatter</code> created them.</p>"},{"location":"05-internals/design/api-v2/standoff/","title":"Standoff Markup","text":""},{"location":"05-internals/design/api-v2/standoff/#requirements","title":"Requirements","text":"<p>In Knora, text with markup is stored using standoff markup, i.e. markup that is stored separately from the content it applies to.</p> <p>Knora's standoff design is based on these requirements:</p> <ul> <li> <p>Overlapping markup should be supported.</p> </li> <li> <p>Markup should be stored as RDF, so it can be searched and analysed using the same tools that are used   with other data managed by Knora.</p> </li> <li> <p>In particular, Gravsearch queries should be able   to specify search criteria that refer to the markup tags attached to a text, together with   any other search criteria relating to the resource that contains the text.</p> </li> <li> <p>It should be possible to import any XML document into Knora, store the markup as standoff, and   at any time export the document as an equivalent XML document.</p> </li> </ul>"},{"location":"05-internals/design/api-v2/standoff/#rdf-design","title":"RDF Design","text":"<p>See Text with Standoff Markup.</p>"},{"location":"05-internals/design/api-v2/standoff/#querying-standoff","title":"Querying Standoff","text":"<p>Since the number of standoff tags that can be attached to a text value is unlimited, standoff is queried in pages of a limited size, to avoid requesting huge SPARQL query results from the triplestore.</p> <p>When <code>ResourcesResponderV2</code> or <code>SearchResponderV2</code> need to return a text value with all its markup, they first query the text value with at most one page of standoff. If the text value has more than one page of standoff, <code>ConstructResponseUtilV2.makeTextValueContentV2</code> then sends a <code>GetRemainingStandoffFromTextValueRequestV2</code> message to <code>StandoffResponderV2</code>, which queries the rest of the standoff in the text value, one page at a time. The resulting standoff is concatenated together and returned.</p> <p>To optimise query performance:</p> <ul> <li> <p>Each text value with standoff has the predicate <code>knora-base:valueHasMaxStandoffStartIndex</code>, so that when Knora   queries a page of standoff, it knows whether it has reached the last page.</p> </li> <li> <p>The last path component of the IRI of a standoff tag is the integer object of its   <code>knora-base:standoffTagHasStartIndex</code> predicate. When querying standoff, it is necessary to convert   the IRI objects of <code>knora-base:standoffTagHasStartParent</code> and <code>knora-base:standoffTagHasEndParent</code> to   integer indexes (the start indexes of those tags). Including each tag's start index in its IRI makes it   unnecessary to query the parent tags to determine their start indexes.</p> </li> </ul>"},{"location":"05-internals/design/api-v2/standoff/#conversion-between-standoff-and-xml","title":"Conversion Between Standoff and XML","text":"<p><code>XMLToStandoffUtil</code> does the low-level conversion of documents between standoff and XML, using a simple data structure to represent standoff. This data structure knows nothing about RDF, and each standoff tag contains its XML element name and namespace and those of its attributes.</p> <p>In DSP-API, it is possible to define mappings to control how standoff/RDF is converted to XML and vice versa. Different mappings can be used to convert the same standoff/RDF to different sorts of XML documents. <code>StandoffTagUtilV2</code> converts between standoff/RDF and XML using mappings, delegating the lower-level work to <code>XMLToStandoffUtil</code>.</p>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/","title":"Class and Property Hierarchies","text":""},{"location":"05-internals/design/domain/class-and-property-hierarchies/#class-hierarchy","title":"Class Hierarchy","text":"<p>While <code>knora-admin</code> and <code>salsah-gui</code> have relatively flat class hierarchies,  in <code>knora-base</code> there are very complicated - yet highly relevant - inheritance structures.  The following class diagrams try to model these structures.  For the sake of comprehensibility, it was necessary to split the ontology into multiple diagrams, even though this obliterates the evident connections between those diagrams.</p> <p>Legend</p> <p>dotted lines: the boxes are copies from another diagram.</p>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#resources","title":"Resources","text":"<pre><code>classDiagram\n  %% Classes\n  class Resource {\n    string label\n    boolean isDeleted\n    Resource hasStandoffLinkTo\n    LinkValue hasStandoffLinkToValue\n    User attachedToUser\n    Project attachedToProject\n    string hasPermissions\n    date creationDate\n    date lastModificationDate\n    date deleteDate\n    User deletedBy\n    string deleteComment\n  }\n  class Annotation {\n    TextValue hasComment\n    Resource isAnnotationOf\n    LinkValue isAnnotationOfValue\n  }\n  class LinkObj{\n    TextValue hasComment\n    Resource hasLinkTo\n    LinkValue hasLinkToValue\n  }\n  class Representation {\n    FileValue hasFileValue\n  }\n  class ExternalResource {\n    ExternalResValue hasExternalResValue\n  }\n  class Region {\n    ColorValue hasColor\n    Representation isRegionOf\n    GeomValue hasGemoetry\n    LinkValue isRegionOfValue\n    TextValue hasComment\n  }\n  class ArchiveRepresentation {\n    ArchiveFileValue hasArchiveFileValue\n  }\n  class AudioRepresentation {\n    AudioFileValue hasAudioFileValue\n  }\n  class DDDRepresentation {\n    DDDFileValue hasDDDFileValue\n  }\n  class DocumentRepresentation {\n    DocumentFileValue hasDocumentFileValue\n  }\n  class MovingImageRepresentation {\n    MovingImageFileValue hasMovingImageFileValue\n  }\n  class StillImageRepresentation {\n    StillImageFileValue hasStillImageFileValue\n  }\n  class TextRepresentation {\n    TextFileValue hasTextFileValue\n  }\n\n  %% Relationships\n  Resource &lt;|-- Annotation\n  Resource &lt;|-- Representation\n  Resource &lt;|-- LinkObj\n  Resource &lt;|-- ExternalResource\n  Resource &lt;|-- DeletedResource\n  Resource &lt;|-- Region\n  Representation &lt;|-- ArchiveRepresentation\n  Representation &lt;|-- AudioRepresentation\n  Representation &lt;|-- DDDRepresentation\n  Representation &lt;|-- DocumentRepresentation\n  Representation &lt;|-- MovingImageRepresentation\n  Representation &lt;|-- StillImageRepresentation\n  Representation &lt;|-- TextRepresentation\n  TextRepresentation &lt;|-- XSLTransformation</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#values","title":"Values","text":"<pre><code>classDiagram\n  %% Classes\n  class Value {\n    date valueCreationDate\n    User attachedToUser\n    string hasPermissions\n    integer valueHasOrder\n    string valueHasComment\n    boolean isDeleted\n    date deleteDate\n    User deletedBy\n    string deleteComment\n    Value previousValue\n    string valueHasString\n    string valueHasUUID\n  }\n  class ColorBase {\n    string valueHasColor\n  }\n  class DateBase {\n    string valueHasCalendar\n    string valueHasEndPrecision\n    integer valueHasEndJDN\n    string valueHasStartPrecision\n    integer valueHasStartJDN\n  }\n  class IntBase {\n    integer valueHasInteger\n  }\n  class BooleanBase {\n    boolean valueHasBoolean\n  }\n  class DecimalBase {\n    decimal valueHasDecimal\n  }\n  class UriBase {\n    URI valueHasUri\n  }\n  class IntervalBase {\n    decimal valueHasIntervalStart\n    decimal valueHasIntervalEnd\n  }\n  class TimeBase {\n    date valueHasTimeStamp\n  }\n  class ListValue {\n    ListNode valueHasListNode\n  }\n  class TextValue {\n    StandoffTag valueHasStandoff\n    integer valueHasMaxStandoffStartIndex\n    string valueHasLanguage\n    XSLToStandoffMApping valueHasMapping\n  }\n  class LinkValue {\n    integer valueHasRefCount\n  }\n  class GeomValue {\n    string valueHasGeometry\n  }\n  class GeonameValue {\n    string valueHasGeonameCode\n  }\n  class ExternalResValue {\n    string extResId\n    string extResProvider\n    string extResAccessInfo\n  }\n  class FileValue {\n    string internalFileName\n    string internalMimeType\n    string originalFileName\n    string originalMimeType\n  }\n  class ArchiveFileValue {\n\n  }\n  class AudioFileValue {\n    decimal duration\n  }\n  class DDDFileValue\n  class DocumentFileValue {\n    integer pageCount\n    integer dimX\n    integer dimY\n  }\n  class MovingImageFileValue\n  class StillImageFileValue {\n    integer dimX\n    integer dimY\n  }\n  class StillImageExternalFileValue {\n    anyUri externalUrl\n  }\n  class TextFileValue\n\n\n  %% Relationships\n  ValueBase &lt;|-- Value\n  ValueBase &lt;|-- ColorBase\n  ValueBase &lt;|-- DateBase\n  ValueBase &lt;|-- IntBase\n  ValueBase &lt;|-- BooleanBase\n  ValueBase &lt;|-- DecimalBase\n  ValueBase &lt;|-- UriBase\n  ValueBase &lt;|-- IntervalBase\n  ValueBase &lt;|-- TimeBase\n  Value &lt;|-- ListValue\n  Value &lt;|-- TextValue\n  Value &lt;|-- LinkValue\n  Value &lt;|-- GeomValue\n  Value &lt;|-- GeonameValue\n  Value &lt;|-- ExternalResValue\n  Value &lt;|-- FileValue\n  Value &lt;|-- DeletedValue\n  Value &lt;|-- ColorValue\n  ColorBase &lt;|-- ColorValue\n  Value &lt;|-- DateValue\n  DateBase &lt;|-- DateValue\n  Value &lt;|-- IntValue\n  IntBase &lt;|-- IntValue\n  Value &lt;|-- BooleanValue\n  BooleanBase &lt;|-- BooleanValue\n  Value &lt;|-- DecimalValue\n  DecimalBase &lt;|-- DecimalValue\n  Value &lt;|-- UriValue\n  UriBase &lt;|-- UriValue\n  Value &lt;|-- IntervalValue\n  IntervalBase &lt;|-- IntervalValue\n  Value &lt;|-- TimeValue\n  TimeBase &lt;|-- TimeValue\n  FileValue &lt;|-- ArchiveFileValue\n  FileValue &lt;|-- AudioFileValue\n  FileValue &lt;|-- DDDFileValue\n  FileValue &lt;|-- DocumentFileValue\n  FileValue &lt;|-- MovingImageFileValue\n  FileValue &lt;|-- StillImageFileValue\n  FileValue &lt;|-- StillImageExternalFileValue\n  FileValue &lt;|-- TextFileValue\n  ValueBase .. StandoffInternalReferenceTag\n  ColorBase .. StandoffColorTag\n  DateBase .. StandoffDateTag\n  IntBase .. StandoffIntegerTag\n  BooleanBase .. StandoffBooleanTag\n  DecimalBase .. StandoffDecimalTag\n  UriBase .. StandoffUriTag\n  IntervalBase .. StandoffIntervalTag\n  TimeBase .. StandoffTimeTag</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#standoff-in-knora-base","title":"Standoff in knora-base","text":"<pre><code>classDiagram\n  %% Classes\n  class StandoffTag {\n    integer standoffHasStartTag\n    integer standoffHasEndTag\n    string standoffHasUUID\n    string standoffHasOriginalXMLID\n    integer standoffHasStartIndex\n    integer standoffHasEndIndex\n    StandoffTag standoffTagHasStartParent\n    StandoffTag standoffTagHasEndParent\n    ??? standoffParentClassConstraint\n  }\n  class StandoffInternalReferenceTag {\n    StandoffTag standoffHasInternalReference\n  }\n  class StandoffLinkTag {\n    Resource standoffHasLink\n  }\n\n\n  %% Relationships\n  StandoffTag &lt;|-- StandoffDataTypeTag\n  StandoffTag &lt;|-- StandoffLinkTag\n  StandoffDataTypeTag &lt;|-- StandoffColorTag\n  StandoffDataTypeTag &lt;|-- StandoffDateTag\n  StandoffDataTypeTag &lt;|-- StandoffIntegerTag\n  StandoffDataTypeTag &lt;|-- StandoffBooleanTag\n  StandoffDataTypeTag &lt;|-- StandoffDecimalTag\n  StandoffDataTypeTag &lt;|-- StandoffUriTag\n  StandoffDataTypeTag &lt;|-- StandoffIntervalTag\n  StandoffDataTypeTag &lt;|-- StandoffTimeTag\n  ValueBase .. ColorBase\n  ValueBase .. DateBase\n  ValueBase .. IntBase\n  ValueBase .. BooleanBase\n  ValueBase .. DecimalBase\n  ValueBase .. UriBase\n  ValueBase .. IntervalBase\n  ValueBase .. TimeBase\n  ValueBase .. StandoffInternalReferenceTag\n  ColorBase .. StandoffColorTag\n  DateBase .. StandoffDateTag\n  IntBase .. StandoffIntegerTag\n  BooleanBase .. StandoffBooleanTag\n  DecimalBase .. StandoffDecimalTag\n  UriBase .. StandoffUriTag\n  IntervalBase .. StandoffIntervalTag\n  TimeBase .. StandoffTimeTag</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#standoff-ontology","title":"Standoff Ontology","text":"<pre><code>flowchart BT\n  StandoffRootTag[\"StandoffRootTag \\n ----- \\n string standoffRootTagHasDocumentType\"]\n  StandoffHyperlinkTag[\"StandoffHyperlinkTag \\n ----- \\n string standoffHyperlinkTagHasTarget\"]\n  StandoffVisualTag -..-&gt; StandoffTag \n  StandoffRootTag -.-&gt; StandoffTag \n  StandoffHyperlinkTag -.-&gt; StandoffTag \n  StandoffStructuralTag -....-&gt; StandoffTag \n\n  StandoffItalicTag --&gt; StandoffVisualTag \n  StandoffBoldTag --&gt; StandoffVisualTag \n  StandoffCiteTag --&gt; StandoffVisualTag \n  StandoffUnderlineTag --&gt; StandoffVisualTag \n  StandoffStrikethroughTag --&gt; StandoffVisualTag \n  StandoffSuperscriptTag --&gt; StandoffVisualTag \n  StandoffSubscriptTag --&gt; StandoffVisualTag \n  StandoffLineTag --&gt; StandoffVisualTag \n  StandoffPreTag --&gt; StandoffVisualTag \n  StandoffBlockquoteTag --&gt; StandoffStructuralTag \n  StandoffCodeTag --&gt; StandoffStructuralTag \n  StandoffParagraphTag --&gt; StandoffStructuralTag \n  StandoffHeader_1_to_6_Tag --&gt; StandoffStructuralTag \n  StandoffOrderedListTag --&gt; StandoffStructuralTag \n  StandoffUnorderedListTag --&gt; StandoffStructuralTag \n  StandoffListElementTag --&gt; StandoffStructuralTag \n  StandoffTableBodyTag --&gt; StandoffStructuralTag \n  StandoffTableTag --&gt; StandoffStructuralTag \n  StandoffTableRowTag --&gt; StandoffStructuralTag \n  StandoffTableCellTag --&gt; StandoffStructuralTag \n  StandoffBrTag --&gt; StandoffStructuralTag </code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#property-hierarchy","title":"Property Hierarchy","text":""},{"location":"05-internals/design/domain/class-and-property-hierarchies/#properties-and-values","title":"Properties and Values","text":"<pre><code>flowchart BT\n  hasValue ---&gt; resourceProperty\n  hasLinkTo --&gt; resourceProperty\n\n  hasFileValue ----&gt; hasValue\n  hasColor ---&gt; hasValue\n  hasGeometry ---&gt; hasValue\n  hasComment ---&gt; hasValue\n  seqnum ---&gt; hasValue\n  hasExtResValue ---&gt; hasValue\n  hasLinkToValue ----&gt; hasValue \n\n  hasArchiveFileValue ---&gt; hasFileValue\n  hasDocumentFileValue ---&gt; hasFileValue\n  hasTextFileValue ---&gt; hasFileValue\n  hasStillImageFileValue ---&gt; hasFileValue\n  hasMovingImageFileValue ---&gt; hasFileValue\n  hasAudioFileValue ---&gt; hasFileValue\n  hasDDDFileValue ---&gt; hasFileValue\n\n  isPartOfValue ---&gt; hasLinkToValue\n  hasAnnotationOfValue ---&gt; hasLinkToValue\n  hasRepresentationValue ---&gt; hasLinkToValue\n  hasStandoffLinkToValue ---&gt; hasLinkToValue\n  isRegionOfValue ---&gt; hasLinkToValue\n\n  isPartOf ---&gt; hasLinkTo\n  isAnnotationOf ---&gt; hasLinkTo\n  hasRepresentation ---&gt; hasLinkTo\n  hasStandoffLinkTo ---&gt; hasLinkTo\n  isRegionOf ---&gt; hasLinkTo</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#resource-metadata","title":"Resource Metadata","text":"<pre><code>flowchart BT\n  creationDate ---&gt; objectCannotBeMarkedAsDeleted\n  deleteDate --&gt; objectCannotBeMarkedAsDeleted\n  isDeleted ---&gt; objectCannotBeMarkedAsDeleted\n  isRootNode ---&gt; objectCannotBeMarkedAsDeleted\n  hasRootNode ---&gt; objectCannotBeMarkedAsDeleted\n  lastModificationDate ---&gt; objectCannotBeMarkedAsDeleted\n  listNodePosition ---&gt; objectCannotBeMarkedAsDeleted\n  listNodeName ---&gt; objectCannotBeMarkedAsDeleted\n  deleteComment ---&gt; objectCannotBeMarkedAsDeleted\n  hasPermissions ---&gt; objectCannotBeMarkedAsDeleted\n  deletedBy --&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasLink ---&gt; objectCannotBeMarkedAsDeleted \n  hasSubListNode --&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasEnd ---&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasInternalReference --&gt; objectCannotBeMarkedAsDeleted \n  valueHas ----&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasStart --&gt; objectCannotBeMarkedAsDeleted \n  standoffTagHasStartIndex ---&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasEndIndex --&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasUuid ---&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasEndParent --&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasOriginalXMLID ---&gt; objectCannotBeMarkedAsDeleted\n  targetHasOriginalXMLID --&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasStartAncestor ----&gt; objectCannotBeMarkedAsDeleted \n  standoffTagHasStartParent --&gt; objectCannotBeMarkedAsDeleted\n  standoffTagHasStartParent --&gt; standoffTagHasStartAncestor\n  hasMappingElement ---&gt; objectCannotBeMarkedAsDeleted\n  mappingHasXMLTagname --&gt; objectCannotBeMarkedAsDeleted\n  mappingHasXMLNamespace ---&gt; objectCannotBeMarkedAsDeleted\n  mappingHasXMLClass --&gt; objectCannotBeMarkedAsDeleted\n  mappingHasStandoffClass ---&gt; objectCannotBeMarkedAsDeleted\n  mappingHasXMLAttribute --&gt; objectCannotBeMarkedAsDeleted\n  mappingHasXMLAttributename ---&gt; objectCannotBeMarkedAsDeleted\n  mappingHasStandoffProperty --&gt; objectCannotBeMarkedAsDeleted\n  mappingHasStandoffDataTypeClass ---&gt; objectCannotBeMarkedAsDeleted\n  mappingElementRequiresSeparator --&gt; objectCannotBeMarkedAsDeleted\n  mappingHasDefaultXSLTransformation ---&gt; objectCannotBeMarkedAsDeleted\n\n  duration --&gt; valueHas\n  pageCount ---&gt; valueHas\n  dimY --&gt; valueHas\n  dimX ---&gt; valueHas\n  valueHasStandoff --&gt; valueHas\n  valueHasMaxStandoffStartIndex ---&gt; valueHas\n  previousValue --&gt; valueHas\n  ValueHasMapping ---&gt; valueHas\n  extResAccessInfo --&gt; valueHas\n  extResId ---&gt; valueHas\n  extResProvider --&gt; valueHas\n  fps ---&gt; valueHas\n  internalFilename --&gt; valueHas\n  internalMimeType ---&gt; valueHas\n  originalFilename ---&gt; valueHas\n  originalMimeType ---&gt; valueHas\n  valueHasComment ---&gt; valueHas\n  valueCreationDate ---&gt; valueHas\n  valueHasUUID ---&gt; valueHas\n  valueHasCalendar ---&gt; valueHas\n  valueHasColor ---&gt; valueHas\n  valueHasEndJDN ---&gt; valueHas\n  valueHasEndPrecision ---&gt; valueHas\n  valueHasDecimal ---&gt; valueHas\n  valueHasGeometry ---&gt; valueHas\n  valueHasGeonameCode ---&gt; valueHas\n  valueHasInteger ---&gt; valueHas\n  valueHasBoolean ---&gt; valueHas\n  valueHasUri ---&gt; valueHas\n  valueHasIntervalEnd ---&gt; valueHas\n  valueHasIntervalStart ---&gt; valueHas\n  valueHasTimeStamp ---&gt; valueHas\n  valueHasListNode ---&gt; valueHas\n  valueHasOrder ---&gt; valueHas\n  valueHasRefCount ---&gt; valueHas\n  valueHasStartJDN ---&gt; valueHas\n  valueHasStartPrecision ---&gt; valueHas\n  valueHasString ---&gt; valueHas\n\n  valueHasLanguage</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#property-triple-structure","title":"Property Triple Structure","text":""},{"location":"05-internals/design/domain/class-and-property-hierarchies/#text-related-triples","title":"Text Related Triples","text":"<pre><code>flowchart LR\n  %% Classes\n  MappingComponent(MappingComponent)\n  MappingElement(MappingElement)\n  MappingXMLAttribute(MappingXMLAttribute)\n  MappingStandoffDataTypeClass(MappingStandoffDataTypeClass)\n  TextValue(TextValue)\n  XMLToStandoffMapping(XMLToStandoffMapping)\n  XSLTransformation(XSLTransformation)\n  StandoffTag(StandoffTag)\n  StandoffInternalReferenceTag(StandoffInternalReferenceTag)\n  Resource(Resource)\n\n  %% Duplicates\n  _StandoffTag{{StandoffTag}}\n\n  %% Values\n  string1([xsd:string])\n  string2([xsd:string])\n  string3([xsd:string])\n  boolean1([xsd:boolean])\n  integer1([xsd:integer])\n\n  %% Relations\n  TextValue --&gt; valueHasMapping --&gt; XMLToStandoffMapping\n  XMLToStandoffMapping --&gt; hasMappingElement --&gt; MappingElement\n  XMLToStandoffMapping --&gt; mappingHasDefaultXSLTransformation --&gt; XSLTransformation\n  TextValue --&gt; valueHasStandoff --&gt; StandoffTag\n  subgraph standoffProperties\n    standoffTagHasEndIndex\n    standoffTagHasStartIndex\n    standoffTagHasEnd\n    standoffTagHasStart\n    standoffTagHasLink\n    standoffTagHasOriginalXMLID\n    targetHasOriginalXMLID\n    standoffTagHasUuid\n    standoffTagHasEndParent\n    standoffTagHasStartAncestor\n    standoffTagHasStartParent\n    standoffTagHasInternalReference\n  end\n  StandoffTag --&gt; standoffTagHasEndIndex --&gt; integer1\n  StandoffTag --&gt; standoffTagHasStartIndex --&gt; integer1\n  StandoffTag --&gt; standoffTagHasEnd --&gt; integer1\n  StandoffTag --&gt; standoffTagHasStart --&gt; integer1\n  StandoffTag --&gt; standoffTagHasLink --&gt; Resource\n  StandoffTag --&gt; standoffTagHasOriginalXMLID --&gt; string2\n  StandoffTag --&gt; targetHasOriginalXMLID --&gt; string2\n  StandoffTag --&gt; standoffTagHasUuid --&gt; string2\n  StandoffTag --&gt; standoffTagHasEndParent --&gt; _StandoffTag\n  StandoffTag --&gt; standoffTagHasStartAncestor --&gt; _StandoffTag\n  StandoffTag --&gt; standoffTagHasStartParent --&gt; _StandoffTag\n  StandoffInternalReferenceTag --&gt; standoffTagHasInternalReference --&gt; _StandoffTag\n  TextValue --&gt; valueHasLanguage --&gt; string3\n\n  MappingComponent --&gt; mappingHasXMLAttributename --&gt; string1\n  MappingComponent --&gt; mappingHasStandoffClass --&gt; string1\n  MappingComponent --&gt; mappingHasXMLNamespace --&gt; string1\n  MappingElement --&gt; mappingHasXMLClass --&gt; string1\n  MappingElement --&gt; mappingHasXMLTagname --&gt; string1\n  MappingElement --&gt; mappingHasXMLAttribute --&gt; MappingXMLAttribute --&gt; mappingHasStandoffProperty\n  MappingElement --&gt; mappingHasStandoffDataTypeClass --&gt; MappingStandoffDataTypeClass\n  MappingElement --&gt; mappingElementRequiresSeparator --&gt; boolean1</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#resource-triples-structure","title":"Resource Triples Structure","text":"<p>Legend</p> <ul> <li>round boxes: resources</li> <li>square boxes: properties</li> <li>hexagonal boxes: resoures that are duplicated for graphical reasons</li> <li>oval boxes: xsd values</li> <li>grey squares: thematic units</li> </ul> <pre><code>flowchart LR\n  LinkValue(LinkValue)\n  GeomValue(GeomValue)\n  ColorValue(ColorValue)\n  ExternalResValue(ExternalResValue)\n\n  date([xsd:dateTime])\n  string([xsd:string])\n  _Representation{{Representation}}\n  _Representation2{{Representation}}\n  _TextValue{{TextValue}}\n  _Value{{Value}}\n  _Resource{{Resource}}\n\n  subgraph Resources\n    Resource(Resource)\n    Annotation(Annotation)\n    Region(Region)\n    ExternalResource(ExternalResource)\n    Representation(Representation)\n    StillImageRepresentation(\"StillImageRepresentation etc.\")\n  end\n\n  subgraph Links\n    hasRepresentation\n    hasLinkTo\n    hasStandoffLinkTo\n    isPartOf\n  end\n\n  subgraph LinkValues\n    hasRepresentationValue\n    hasLinkToValue\n    hasStandoffLinkToValue\n    isPartOfValue\n  end\n\n  subgraph FileValues\n    direction LR\n    hasFileValue\n    FileValue(FileValue)\n    hasStillImageRepresentation[\"hasStillImageRepresentation etc.\"]\n    StillImageFileValue(\"StillImageFileValue etc.\")\n  end\n\n  Resource --&gt; creationDate --&gt; date\n  Resource --&gt; hasComment --&gt; _TextValue\n  Resource --&gt; hasValue --&gt; _Value\n\n  Resource --&gt; hasRepresentation --&gt; _Representation\n\n  Resource --&gt; hasLinkTo --&gt; _Resource\n  Resource --&gt; hasStandoffLinkTo --&gt; _Resource\n  Resource --&gt; isPartOf --&gt; _Resource\n\n  Resource --&gt; hasLinkToValue --&gt; LinkValue\n  Resource --&gt; hasStandoffLinkToValue --&gt; LinkValue\n  Resource --&gt; hasRepresentationValue --&gt; LinkValue\n  Resource --&gt; isPartOfValue --&gt; LinkValue\n\n  Annotation --&gt; isAnnotationOfValue --&gt; LinkValue\n  Annotation --&gt; isAnnotationOf --&gt; _Resource\n\n  Region --&gt; isRegionOfValue --&gt; LinkValue\n  Region --&gt; isRegionOf --&gt; _Representation2\n  Region --&gt; hasGeometry --&gt; GeomValue\n  Region --&gt; hasColorValue --&gt; ColorValue\n\n  ExternalResource --&gt; hasExtResValue --&gt; ExternalResValue\n  ExternalResValue --&gt; extResId --&gt; string\n  ExternalResValue --&gt; extResAccessInfo --&gt; string\n  ExternalResValue --&gt; extResProvider --&gt; string\n\n  Representation --&gt; hasFileValue --&gt; FileValue\n  StillImageRepresentation --&gt; hasStillImageRepresentation --&gt; StillImageFileValue</code></pre>"},{"location":"05-internals/design/domain/class-and-property-hierarchies/#properties-without-subject-class-constraint","title":"Properties without Subject Class Constraint","text":"<pre><code>flowchart LR\n  na[[no subject class constraint defined]]\n\n  %% Classes\n  User(admin:User)\n  IntValue(IntValue)\n  IntervalValue(IntervalValue)\n\n  %% Values\n  date([xsd:dateTime])\n  boolean([xsd:boolean])\n\n  %% Relations\n  na --&gt; deletedBy --&gt; User\n  na --&gt; seqnum --&gt; IntValue\n  na --&gt; deleteDate --&gt; date\n  na --&gt; isDeleted --&gt; boolean</code></pre>"},{"location":"05-internals/design/domain/domain-entities-and-relations/","title":"Domain Entities and Relations","text":"<p>In the context of DEV-1415: Domain Model we attempted to gain a clear overview over the DSP's domain, as implicitly modelled by the ontologies, code, validations and documentation of the DSP-API.</p> <p>The following document aims to give a higher level overview of said domain.</p> <p>Note</p> <ul> <li>As a high level overview, this document does not aim for exhaustivity.</li> <li>Naming is tried to be kept as simple as possible,    while trying to consolidate different naming schemes   (ontologies, code, API),   which in result means that no naming scheme is strictly followed.</li> <li>The split between V2 and Admin is arbitrary as those are intertwined within the system.   It merely serves the purpose of organizing the presented entities.</li> </ul>"},{"location":"05-internals/design/domain/domain-entities-and-relations/#domain-entities","title":"Domain Entities","text":"<p>The following Diagrams visualize the top level entities present in the DSP.  The attributes of these entities should be exhaustive. Cardinalities or validation constraints are normally not depicted.  The indicated relationships are of conceptual nature and are more complicated in the actual system.</p>"},{"location":"05-internals/design/domain/domain-entities-and-relations/#admin","title":"Admin","text":"<pre><code>erDiagram\n    %% entities\n    User {\n        IRI id\n        string userName \"unique\"\n        string email \"unique\"\n        string givenName\n        string familyName\n        string password\n        string language \"2 character ISO language code\"\n        boolean status\n        boolean systemAdmin\n    }\n    Project {\n        IRI id\n        string shortcode \"4 character hex\"\n        string shortname \"xsd:NCNAME\"\n        string longname \"optional\"\n        langstring description\n        string keywords\n        boolean status\n        boolean selfjoin\n        string logo \"optional\"\n        string restrictedViewSize\n        string restrictedViewWatermark\n    }\n    Group {\n        IRI id\n        string name\n        langstring description\n        boolean status\n        boolean selfjoin\n    }\n    ListNode {\n        IRI id\n        IRI projectIri \"only for root node\"\n        langstring labels\n        langstring comments\n        string name\n        boolean isRootNode\n        integer listNodePosition\n    }\n    DefaultObjectAccessPermission {\n        IRI id\n        string hasPermission \"the 'RV, V, M, D, CR' string\"\n    }\n    AdministrativePermission {\n        IRI id\n        string hasPermission \"a different string representation\"\n    }\n    Property {}\n    ResourceClass {}\n\n    %% relations\n    User }|--|{ Project: \"is member/admin of\"\n    User }o--|{ Group: \"is member of\"\n    Group }o--|| Project: \"belongs to\"\n    ListNode }o--|| Project: \"belongs to\"\n    ListNode }o--o{ ListNode: \"hasSubListNode\"\n    ListNode |o--o| ListNode: \"hasRootNode\"\n    AdministrativePermission |{--o| Project: \"points to\"\n    AdministrativePermission |{--|{ Group: \"points to\"\n\n    DefaultObjectAccessPermission |{--o{ Group: \"points to\"\n    DefaultObjectAccessPermission |{--|| Project: \"points to\"\n    DefaultObjectAccessPermission |{--o{ Property: \"points to\"\n    DefaultObjectAccessPermission |{--o{ ResourceClass: \"points to\"\n</code></pre>"},{"location":"05-internals/design/domain/domain-entities-and-relations/#overview-v2","title":"Overview V2","text":"<pre><code>erDiagram\n    Ontology ||--o{ ResourceClass: \"consists of\"\n    Ontology ||--o{ Property: \"consists of\"\n    ResourceClass o{--o{ Cardinality: defines\n    Cardinality ||--|| Property: on\n    ResourceClass ||--o{ Resource: \"can be instantiated as\"\n    Property ||--o{ Value: \"can be instantiated as\"\n    Resource ||--o{ Value: has\n    Value }o--|| ObjectAccessPermission: grants\n    Resource }o--|| ObjectAccessPermission: grants\n    Resource }o--|| User: \"attached to\"\n    Resource }o--|| Project: \"attached to\"</code></pre>"},{"location":"05-internals/design/domain/domain-entities-and-relations/#ontology","title":"Ontology","text":"<pre><code>erDiagram\n    Project {}\n    Ontology {\n        IRI id\n        string ontologyName\n        string label\n        string comment \"optional\"\n        boolean isShared\n        date lastModificationDate\n    }\n    ResourceClass {\n        IRI id\n        langstring label\n        langstring comment\n    }\n    Property {\n        IRI id\n        langstring label\n        langstring comment\n        string guiAttribute\n    }\n    GuiElement {}\n    Cardinality {\n        owl_cardinality cardinality \"1, 0-1, 0-n, 1-n\"\n        integer guiOrder\n    }\n    Ontology o{--|| Project: \"attached to\"\n    Ontology ||--o{ ResourceClass: \"consists of\"\n    Ontology ||--o{ Property: \"consists of\"\n    ResourceClass }o--o{ ResourceClass: subClassOf\n    ResourceClass ||--o{ Cardinality: defines\n    Cardinality ||--|| Property: specifies\n    Property }o--o{ Property: subPropertyOf\n    Property }o--o| ResourceClass: subjectType\n    Property }o--o| ResourceClass: objectType\n    Property }o--|| GuiElement: has\n    Cardinality ||--|| Property: specifies</code></pre>"},{"location":"05-internals/design/domain/domain-entities-and-relations/#data","title":"Data","text":"<pre><code>erDiagram\n    User {}\n    Project {}\n    Resource {\n        IRI id\n        string label\n        boolean isDeleted\n        string hasPermission\n        date creationDate\n        date lastModificationDate\n        date deleteDate\n        string deleteComment\n    }\n    Value {\n        IRI id\n        date valueCreationDate\n        string hasPermission\n        integer valueHasOrder\n        langstring valueHasComment\n        boolean isDeleted\n        date deleteDate\n        langstring deleteComment\n        string valueHasString\n        UUID valueHasUUID\n    }\n    Resource ||--o{ Value: contains\n    Resource o{--o{ Value: hasStandoffLinkTo\n    Resource o{--|| User: attachedToUser\n    Resource o{--o| User: deletedBy\n    Resource o{--|| Project: attachedToProject\n    Value ||--|| ValueLiteral: \"is represented by\"\n    Value }o--o{ Resource: \"links to\"\n    Value }o--o{ ListNode: \"links to\"\n    Value o{--|| User: attachedToUser\n    Value o{--o| User: deletedBy\n    Value o|--o| Value: previousValue</code></pre>"},{"location":"05-internals/design/domain/system-instances/","title":"System Instances","text":"<p>Apart from class and property definitions,  <code>knora-base</code> and <code>knora-admin</code> provide a small number of class instances  that should be present in any running DSP stack:</p>"},{"location":"05-internals/design/domain/system-instances/#built-in-user-groups","title":"Built-in User Groups","text":"<pre><code>classDiagram\n%% Classes\n  class UserGroup {\n\n  }\n  class UnknownUser {\n\n  }\n  class KnownUser {\n\n  }\n  class Creator {\n\n  }\n  class ProjectMember {\n\n  }\n  class ProjectAdmin {\n\n  }\n  class SystemAdmin {\n\n  }\n%% Relationships\n  UserGroup &lt;|-- UnknownUser\n  UserGroup &lt;|-- KnownUser\n  UserGroup &lt;|-- Creator\n  UserGroup &lt;|-- ProjectMember\n  UserGroup &lt;|-- ProjectAdmin\n  UserGroup &lt;|-- SystemAdmin</code></pre>"},{"location":"05-internals/design/domain/system-instances/#built-in-users","title":"Built-in Users","text":"<pre><code>classDiagram\n%% Classes\n  class User {\n\n  }\n  class AnonymousUser {\n\n  }\n  class SystemUser {\n\n  }\n%% Relationships\n  User &lt;|-- AnonymousUser\n  User &lt;|-- SystemUser</code></pre>"},{"location":"05-internals/design/domain/system-instances/#built-in-projects","title":"Built-in Projects","text":"<pre><code>classDiagram\n%% Classes\n  class Project {\n\n  }\n  class SystemProject {\n\n  }\n  class DefaultSharedOntologiesProject {\n\n  }\n%% Relationships\n  Project &lt;|-- SystemProject\n  Project &lt;|-- DefaultSharedOntologiesProject</code></pre>"},{"location":"05-internals/design/principles/authentication/","title":"Authentication in Knora","text":""},{"location":"05-internals/design/principles/authentication/#scope","title":"Scope","text":"<p>Authentication is the process of making sure that if someone is accessing something then this someone is actually also the person they pretend to be. The process of making sure that someone is authorized, (i.e. has the permission to access something, is handled as described in Authorisation).</p>"},{"location":"05-internals/design/principles/authentication/#implementation","title":"Implementation","text":"<p>The authentication in Knora is based on Basic Auth HTTP basic authentication, URL parameters or JSON Web Token.  This means that on every request (to any of the routes), credentials need to be sent either via authorization header.</p> <p>All routes are always accessible and if there are no credentials provided, a default user is assumed. If credentials are sent and they are not correct (e.g., wrong username, password incorrect, token expired), then the request will end in an error message.</p>"},{"location":"05-internals/design/principles/authentication/#skipping-authentication","title":"Skipping Authentication","text":"<p>There is the possibility to turn skipping authentication on and use a hardcoded user (Test User). In application.conf set the <code>skip-authentication = true</code> and Test User will be always assumed.</p>"},{"location":"05-internals/design/principles/consistency-checking/","title":"Consistency Checking","text":"<p>Attention! GraphDB is not supported anymore, therefore parts related  to it in this document are redundant.</p>"},{"location":"05-internals/design/principles/consistency-checking/#requirements","title":"Requirements","text":"<p>Knora is designed to prevent inconsistencies in RDF data, as far as is practical, in a triplestore-independent way (see Triplestore Updates). However, it is also useful to enforce consistency constraints in the triplestore itself, for two reasons:</p> <ol> <li>To prevent inconsistencies resulting from bugs in the DSP-API server.</li> <li>To prevent users from inserting inconsistent data directly into the triplestore, bypassing Knora.</li> </ol> <p>The design of the <code>knora-base</code> ontology supports two ways of specifying constraints on data (see knora-base: Consistency Checking for details):</p> <ol> <li>A property definition should specify the types that are allowed as   subjects and objects of the property, using   <code>knora-base:subjectClassConstraint</code> and (if it is an object   property) <code>knora-base:objectClassConstraint</code>. Every subproperty of   <code>knora-base:hasValue</code> or a <code>knora-base:hasLinkTo</code> (i.e. every   property of a resource that points to a <code>knora-base:Value</code> or to   another resource) is required have this constraint, because the   DSP-API server relies on it to know what type of object to expect   for the property. Use of <code>knora-base:subjectClassConstraint</code> is   recommended but not required.</li> <li>A class definition should use OWL cardinalities    (see OWL 2 Quick Reference Guide)   to indicate the properties that instances of the class are allowed to   have, and to constrain the number of objects that each property can   have. Subclasses of <code>knora-base:Resource</code> are required to have a   cardinality for each subproperty of <code>knora-base:hasValue</code> or a   <code>knora-base:hasLinkTo</code> that resources of that class can have.</li> </ol> <p>Specifically, consistency checking should prevent the following:</p> <ul> <li>An object property or datatype property has a subject of the wrong   class, or an object property has an object of the wrong class   (GraphDB's consistency checke cannot check the types of literals).</li> <li>An object property has an object that does not exist (i.e. the   object is an IRI that is not used as the subject of any statements   in the repository). This can be treated as if the object is of the   wrong type (i.e. it can cause a violation of   <code>knora-base:objectClassConstraint</code>, because there is no compatible   <code>rdf:type</code> statement for the object).</li> <li>A class has <code>owl:cardinality 1</code> or <code>owl:minCardinality 1</code> on an   object property or datatype property, and an instance of the class   does not have that property.</li> <li>A class has <code>owl:cardinality 1</code> or <code>owl:maxCardinality 1</code> on an   object property or datatype property, and an instance of the class   has more than one object for that property.</li> <li>An instance of <code>knora-base:Resource</code> has an object property pointing   to a <code>knora-base:Value</code> or to another <code>Resource</code>, and its class has   no cardinality for that property.</li> <li>An instance of <code>knora-base:Value</code> has a subproperty of   <code>knora-base:valueHas</code>, and its class has no cardinality for that   property.</li> <li>A datatype property has an empty string as an object.</li> </ul> <p>Cardinalities in base classes are inherited by derived classes. Derived classes can override inherited cardinalities by making them more restrictive, i.e. by specifying a subproperty of the one specified in the original cardinality.</p> <p>Instances of <code>Resource</code> and <code>Value</code> can be marked as deleted, using the property <code>isDeleted</code>. This must be taken into account as follows:</p> <ul> <li>With <code>owl:cardinality 1</code> or <code>owl:maxCardinality 1</code>, if the object of   the property can be marked as deleted, the property must not have   more than one object that has not been marked as deleted. In other   words, it's OK if there is more than one object, as long only one of   them has <code>knora-base:isDeleted false</code>.</li> <li>With <code>owl:cardinality 1</code> or <code>owl:minCardinality 1</code>, the property   must have an object, but it's OK if the property's only object is   marked as deleted. We allow this because the subject and object may   have different owners, and it may not be feasible for them to   coordinate their work. The owner of the object should always be able   to mark it as deleted. (It could be useful to notify the owner of   the subject when this happens, but that is beyond the scope of   consistency checking.)</li> </ul>"},{"location":"05-internals/design/principles/consistency-checking/#design","title":"Design","text":"<p>Ontotext GraphDB provides a mechanism for checking the consistency of data in a repository each time an update transaction is committed. Knora provides GraphDB-specific consistency rules that take advantage of this feature to provide an extra layer of consistency checks, in addition to the checks that are implemented in Knora.</p> <p>When a repository is created in GraphDB, a set of consistency rules can be provided, and GraphDB's consistency checker can be turned on to ensure that each update transaction respects these rules, as described in the section Reasoning of the GraphDB documentation. Like custom inference rules, consistency rules are defined in files with the <code>.pie</code> filename extension, in a GraphDB-specific syntax.</p> <p>We have added rules to the standard RDFS inference rules file <code>builtin_RdfsRules.pie</code>, to create the file <code>KnoraRules.pie</code>. The <code>.ttl</code> configuration file that is used to create the repository must contain these settings:</p> <pre><code>owlim:ruleset \"/path/to/KnoraRules.pie\" ;\nowlim:check-for-inconsistencies \"true\" ;\n</code></pre> <p>The path to <code>KnoraRules.pie</code> must be an absolute path. The scripts provided with Knora to create test repositories set this path automatically.</p> <p>Consistency checking in GraphDB relies on reasoning. GraphDB's reasoning is Forward-chaining, which means that reasoning is applied to the contents of each update, before the update transaction is committed, and the inferred statements are added to the repository.</p> <p>A GraphDB rules file can contain two types of rules: inference rules and consistency rules. Before committing an update transaction, GraphDB applies inference rules, then consistency rules. If any of the consistency rules are violated, the transaction is rolled back.</p> <p>An inference rule has this form:</p> <pre><code>Id: &lt;rule_name&gt;\n    &lt;premises&gt; &lt;optional_constraints&gt;\n    -------------------------------\n    &lt;consequences&gt; &lt;optional_constraints&gt;\n</code></pre> <p>The premises are a pattern that tries to match statements found in the data. Optional constraints, which are enclosed in square brackets, make it possible to specify the premises more precisely, or to specify a named graph (see examples below). Consequences are the statements that will be inferred if the premises match. A line of hyphens separates premises from consequences.</p> <p>A GraphDB consistency rule has a similar form:</p> <pre><code>Consistency: &lt;rule_name&gt;\n    &lt;premises&gt; &lt;optional_constraints&gt;\n    -------------------------------\n    &lt;consequences&gt; &lt;optional_constraints&gt;\n</code></pre> <p>The differences between inference rules and consistency rules are:</p> <ul> <li>A consistency rule begins with <code>Consistency</code> instead of <code>Id</code>.</li> <li>In a consistency rule, the consequences are optional. Instead of   representing statements to be inferred, they represent statements   that must exist if the premises are satisfied. In other words, if   the premises are satisfied and the consequences are not found, the   rule is violated.</li> <li>If a consistency rule doesn't specify any consequences, and the   premises are satisfied, the rule is violated.</li> </ul> <p>Rules use variable names for subjects, predicates, and objects, and they can use actual property names.</p>"},{"location":"05-internals/design/principles/consistency-checking/#empty-string-as-object","title":"Empty string as object","text":"<p>If subject <code>i</code> has a predicate <code>p</code> whose object is an empty string, the constraint is violated:</p> <pre><code>Consistency: empty_string\n    i p \"\"\n    ------------------------------------\n</code></pre>"},{"location":"05-internals/design/principles/consistency-checking/#subject-and-object-class-constraints","title":"Subject and object class constraints","text":"<p>If subject <code>i</code> has a predicate <code>p</code> that requires a subject of type <code>t</code>, and <code>i</code> is not a <code>t</code>, the constraint is violated:</p> <pre><code>Consistency: subject_class_constraint\n    p &lt;knora-base:subjectClassConstraint&gt; t\n    i p j\n    ------------------------------------\n    i &lt;rdf:type&gt; t\n</code></pre> <p>If subject <code>i</code> has a predicate <code>p</code> that requires an object of type <code>t</code>, and the object of <code>p</code> is not a <code>t</code>, the constraint is violated:</p> <pre><code>Consistency: object_class_constraint\n    p &lt;knora-base:objectClassConstraint&gt; t\n    i p j\n    ------------------------------------\n    j &lt;rdf:type&gt; t\n</code></pre>"},{"location":"05-internals/design/principles/consistency-checking/#cardinality-constraints","title":"Cardinality constraints","text":"<p>A simple implementation of a consistency rule to check <code>owl:maxCardinality 1</code>, for objects that can be marked as deleted, could look like this:</p> <pre><code>Consistency: max_cardinality_1_with_deletion_flag\n    i &lt;rdf:type&gt; r\n    r &lt;owl:maxCardinality&gt; \"1\"^^xsd:nonNegativeInteger\n    r &lt;owl:onProperty&gt; p\n    i p j\n    i p k [Constraint j != k]\n    j &lt;knora-base:isDeleted&gt; \"false\"^^xsd:boolean\n    k &lt;knora-base:isDeleted&gt; \"false\"^^xsd:boolean\n    ------------------------------------\n</code></pre> <p>This means: if resource <code>i</code> is a subclass of an <code>owl:Restriction</code> <code>r</code> with <code>owl:maxCardinality 1</code> on property <code>p</code>, and the resource has two different objects for that property, neither of which is marked as deleted, the rule is violated. Note that this takes advantage of the fact that <code>Resource</code> and <code>Value</code> have <code>owl:cardinality 1</code> on <code>isDeleted</code> (<code>isDeleted</code> must be present even if false), so we do not need to check whether <code>i</code> is actually something that can be marked as deleted.</p> <p>However, this implementation would be much too slow. We therefore use two optimisations suggested by Ontotext:</p> <ol> <li>Add custom inference rules to make tables (i.e. named graphs) of    pre-calculated information about the cardinalities on properties of    subjects, and use those tables to simplify the consistency rules.</li> <li>Use the <code>[Cut]</code> constraint to avoid generating certain redundant    compiled rules (see Entailment    rules).</li> </ol> <p>For example, to construct a table of subjects belonging to classes that have <code>owl:maxCardinality 1</code> on some property <code>p</code>, we use the following custom inference rule:</p> <pre><code>Id: maxCardinality_1_table\n    i &lt;rdf:type&gt; r\n    r &lt;owl:maxCardinality&gt; \"1\"^^xsd:nonNegativeInteger\n    r &lt;owl:onProperty&gt; p\n    ------------------------------------\n    i p r [Context &lt;onto:_maxCardinality_1_table&gt;]\n</code></pre> <p>The constraint <code>[Context &lt;onto:_maxCardinality_1_table&gt;]</code> means that the inferred triples are added to the context (i.e. the named graph) <code>http://www.ontotext.com/_maxCardinality_1_table</code>. (Note that we have defined the prefix <code>onto</code> as <code>http://www.ontotext.com/</code> in the <code>Prefices</code> section of the rules file.) As the GraphDB documentation on Rules explains:</p> <p>If the context is provided, the statements produced as rule consequences are not \u2018visible\u2019 during normal query answering. Instead, they can only be used as input to this or other rules and only when the rule premise explicitly uses the given context.</p> <p>Now, to find out whether a subject belongs to a class with that cardinality on a given property, we only need to match one triple. The revised implementation of the rule <code>max_cardinality_1_with_deletion_flag</code> is as follows:</p> <pre><code>Consistency: max_cardinality_1_with_deletion_flag\n    i p r [Context &lt;onto:_maxCardinality_1_table&gt;]\n    i p j [Constraint j != k]\n    i p k [Cut]\n    j &lt;knora-base:isDeleted&gt; \"false\"^^xsd:boolean\n    k &lt;knora-base:isDeleted&gt; \"false\"^^xsd:boolean\n    ------------------------------------\n</code></pre> <p>The constraint <code>[Constraint j != k]</code> means that the premises will be satisfied only if the variables <code>j</code> and <code>k</code> do not refer to the same thing.</p> <p>With these optimisations, the rule is faster by several orders of magnitude.</p> <p>Since properties whose objects can be marked as deleted must be handled differently to properties whose objects cannot be marked as deleted, the <code>knora-base</code> ontology provides a property called <code>objectCannotBeMarkedAsDeleted</code>. All properties in <code>knora-base</code> whose objects cannot take the <code>isDeleted</code> flag (including datatype properties) should be derived from this property. This is how it is used to check <code>owl:maxCardinality 1</code> for objects that cannot be marked as deleted:</p> <pre><code>Consistency: max_cardinality_1_without_deletion_flag\n    i p r [Context &lt;onto:_maxCardinality_1_table&gt;]\n    p &lt;rdfs:subPropertyOf&gt; &lt;knora-base:objectCannotBeMarkedAsDeleted&gt;\n    i p j [Constraint j != k]\n    i p k [Cut]\n    ------------------------------------\n</code></pre> <p>To check <code>owl:minCardinality 1</code>, we do not care whether the object can be marked as deleted, so we can use this simple rule:</p> <pre><code>Consistency: min_cardinality_1_any_object\n    i p r [Context &lt;onto:_minCardinality_1_table&gt;]\n    ------------------------------------\n    i p j\n</code></pre> <p>This means: if a subject <code>i</code> belongs to a class that has <code>owl:minCardinality 1</code> on property <code>p</code>, and <code>i</code> has no object for <code>p</code>, the rule is violated.</p> <p>To check <code>owl:cardinality 1</code>, we need two rules: one that checks whether there are too few objects, and one that checks whether there are too many. To check whether there are too few objects, we don't care whether the objects can be marked as deleted, so the rule is the same as <code>min_cardinality_1_any_object</code>, except for the cardinality:</p> <pre><code>Consistency: cardinality_1_not_less_any_object\n    i p r [Context &lt;onto:_cardinality_1_table&gt;]\n    ------------------------------------\n    i p j\n</code></pre> <p>To check whether there are too many objects, we need to know whether the objects can be marked as deleted or not. In the case where the objects can be marked as deleted, the rule is the same as <code>max_cardinality_1_with_deletion_flag</code>, except for the cardinality:</p> <pre><code>Consistency: cardinality_1_not_greater_with_deletion_flag\n    i p r [Context &lt;onto:_cardinality_1_table&gt;]\n    i p j [Constraint j != k]\n    i p k [Cut]\n    j &lt;knora-base:isDeleted&gt; \"false\"^^xsd:boolean\n    k &lt;knora-base:isDeleted&gt; \"false\"^^xsd:boolean\n    ------------------------------------\n</code></pre> <p>In the case where the objects cannot be marked as deleted, the rule is the same as <code>max_cardinality_1_without_deletion_flag</code>, except for the cardinality:</p> <pre><code>Consistency: cardinality_1_not_less_any_object\n    i p r [Context &lt;onto:_cardinality_1_table&gt;]\n    ------------------------------------\n    i p j\n</code></pre> <p>Knora allows a subproperty of <code>knora-base:hasValue</code> or <code>knora-base:hasLinkTo</code> to be a predicate of a resource only if the resource's class has some cardinality for the property. For convenience, <code>knora-base:hasValue</code> and <code>knora-base:hasLinkTo</code> are subproperties of <code>knora-base:resourceProperty</code>, which is used to check this constraint in the following rule:</p> <pre><code>Consistency: resource_prop_cardinality_any\n    i &lt;knora-base:resourceProperty&gt; j\n    ------------------------------------\n    i p j\n    i &lt;rdf:type&gt; r\n    r &lt;owl:onProperty&gt; p\n</code></pre> <p>If resource <code>i</code> has a subproperty of <code>knora-base:resourceProperty</code>, and <code>i</code> is not a member of a subclass of an <code>owl:Restriction</code> <code>r</code> with a cardinality on that property (or on one of its base properties), the rule is violated.</p> <p>A similar rule, <code>value_prop_cardinality_any</code>, ensures that if a value has a subproperty of <code>knora-base:valueHas</code>, the value's class has some cardinality for that property.</p>"},{"location":"05-internals/design/principles/design-overview/","title":"DSP-API Server Design Overview","text":""},{"location":"05-internals/design/principles/design-overview/#introduction","title":"Introduction","text":"<p>DSP-API's responsibilites are:</p> <ul> <li>Querying, creating, updating, and deleting data</li> <li>Creating, updating and deleting data models (ontologies)</li> <li>Managing projects and users</li> <li>Authentication of clients</li> <li>Authorisation of clients' requests</li> </ul> <p>DSP-API is developed with Scala and uses the Akka framework for message-based concurrency. It is designed to work with the Apache Jena Fuseki triplestore which is compliant to the SPARQL 1.1 Protocol. For file storage, it uses Sipi.</p>"},{"location":"05-internals/design/principles/design-overview/#dsp-api-versions","title":"DSP-API Versions","text":"<ul> <li>DSP-API v2: the latest DSP-API that should be used.</li> <li>DSP-API v1: has been removed after a long period of deprecation.</li> </ul> <p>There is also an Admin API for administrating DSP projects.</p>"},{"location":"05-internals/design/principles/design-overview/#error-handling","title":"Error Handling","text":"<p>The error-handling design has these aims:</p> <ol> <li>Simplify the error-handling code in actors as much as possible.</li> <li>Produce error messages that clearly indicate the context in which    the error occurred (i.e. what the application was trying to do).</li> <li>Ensure that clients receive an appropriate error message when an    error occurs.</li> <li>Ensure that <code>ask</code> requests are properly terminated with an    <code>akka.actor.Status.Failure</code> message in the event of an error,    without which they will simply time out (see    Ask: Send and Receive Future).</li> <li>When a actor encounters an error that isn't the client's fault (e.g.    a triplestore failure), log it, but don't do this with errors caused    by bad input.</li> <li>When logging errors, include the full JVM stack trace.</li> </ol> <p>A hierarchy of exception classes is defined in <code>Exceptions.scala</code>, representing different sorts of errors that could occur. The hierarchy has two main branches:</p> <ul> <li><code>RequestRejectedException</code>, an abstract class for errors that are   the client's fault. These errors are not logged.</li> <li><code>InternalServerException</code>, an abstract class for errors that are not   the client's fault. These errors are logged.</li> </ul> <p>Exception classes in this hierarchy can be defined to include a wrapped <code>cause</code> exception. When an exception is logged, its stack trace will be logged along with the stack trace of its <code>cause</code>. It is therefore recommended that low-level code should catch low-level exceptions, and wrap them in one of our higher-level exceptions, in order to clarify the context in which the error occurred.</p> <p>To simplify error-handling in responders, a utility method called <code>future2Message</code> is provided in <code>ActorUtils</code>. It is intended to be used in an actor's <code>receive</code> method to respond to messages in the <code>ask</code> pattern. If the responder's computation is successful, it is sent to the requesting actor as a response to the <code>ask</code>. If the computation fails, the exception representing the failure is wrapped in a <code>Status.Failure</code>, which is sent as a response to the <code>ask</code>. If the error is a subclass of <code>RequestRejectedException</code>, only the sender is notified of the error; otherwise, the error is also logged and rethrown (so that the <code>KnoraExceptionHandler</code> can handle the exception).</p> <p>In many cases, we transform data from the triplestore into a <code>Map</code> object. To simplify checking for required values in these collections, the class <code>ErrorHandlingMap</code> is provided. You can wrap any <code>Map</code> in an <code>ErrorHandlingMap</code>. You must provide a function that will generate an error message when a required value is missing, and optionally a function that throws a particular exception. Rows of SPARQL query results are already returned in <code>ErrorHandlingMap</code> objects.</p> <p>If you want to add a new exception class, see the comments in <code>Exceptions.scala</code> for instructions.</p>"},{"location":"05-internals/design/principles/design-overview/#transformation-of-exception-to-client-responses","title":"Transformation of Exception to Client Responses","text":"<p>The <code>org.knora.webapi.KnoraExceptionHandler</code> is brought implicitly into scope of <code>pekko-http</code>, and by doing so registered and used to handle the transformation of all <code>KnoraExceptions</code> into <code>HttpResponses</code>. This handler handles only exceptions thrown inside the route and not the actors. However, the design of reply message passing from actors (by using <code>future2Message</code>), makes sure that any exceptions thrown inside actors, will reach the route, where they will be handled.</p>"},{"location":"05-internals/design/principles/design-overview/#api-routing","title":"API Routing","text":"<p>The API routes in the <code>routing</code> package are defined using the DSL provided by the pekko-http library. A routing function has to do the following:</p> <ol> <li>Authenticate the client.</li> <li>Figure out what the client is asking for.</li> <li>Construct an appropriate request message and send it to the appropriate responder.</li> <li>Return a result to the client.</li> </ol> <p>To simplify the coding of routing functions, they are contained in objects that extend <code>org.knora.webapi.routing.Authenticator</code>. Each routing function performs the following operations:</p> <ol> <li><code>Authenticator.getUserADM</code> is called to authenticate the user.</li> <li>The request parameters are interpreted and validated, and a request    message is constructed to send to the responder. If the request is    invalid, <code>BadRequestException</code> is thrown. If the request message is    requesting an update operation, it must include a UUID generated by    <code>UUID.randomUUID</code>, so the responder can obtain a write lock on the    resource being updated.</li> </ol> <p>The routing function then passes the message to a function in an API-specific routing utility: <code>RouteUtilV2</code> or <code>RouteUtilADM</code>. This utility function sends the message to <code>ResponderManager</code> (which forwards it to the relevant responder), returns a response to the client in the appropriate format, and handles any errors.</p>"},{"location":"05-internals/design/principles/design-overview/#logging","title":"Logging","text":"<p>Logging in DSP-API is configurable through <code>logback.xml</code>, allowing fine grain configuration of what classes / objects should be logged from which level.</p> <p>The Akka Actors use Akka Logging while logging inside plain Scala Objects and Classes is done through Scala Logging.</p>"},{"location":"05-internals/design/principles/rdf-api/","title":"RDF Processing API","text":"<p>DSP provides an API for parsing and formatting RDF data and for working with RDF graphs. This allows DSP developers to use a single, idiomatic Scala API as a fa\u00e7ade for a Java RDF library.</p>"},{"location":"05-internals/design/principles/rdf-api/#overview","title":"Overview","text":"<p>The API is in the package <code>org.knora.webapi.messages.util.rdf</code>. It includes:</p> <ul> <li> <p><code>RdfModel</code>, which represents a set of RDF graphs (a default graph and/or one or more named graphs).   A model can be constructed from scratch, modified, and searched.</p> </li> <li> <p><code>RdfNode</code> and its subclasses, which represent RDF nodes (IRIs, blank nodes, and literals).</p> </li> <li> <p><code>Statement</code>, which represents a triple or quad.</p> </li> <li> <p><code>RdfNodeFactory</code>, which creates nodes and statements.</p> </li> <li> <p><code>RdfModelFactory</code>, which creates empty RDF models.</p> </li> <li> <p><code>RdfFormatUtil</code>, which parses and formats RDF models.</p> </li> <li> <p><code>JsonLDUtil</code>, which provides specialised functionality for working   with RDF in JSON-LD format, and for converting between RDF models   and JSON-LD documents. <code>RdfFormatUtil</code> uses <code>JsonLDUtil</code> when appropriate.</p> </li> <li> <p><code>ShaclValidator</code>, which validates RDF models using SHACL shapes.</p> </li> </ul> <p>To work with RDF models, start with <code>RdfFeatureFactory</code>, which returns instances of <code>RdfNodeFactory</code>, <code>RdfModelFactory</code>, <code>RdfFormatUtil</code>, and <code>ShaclValidator</code>.  <code>JsonLDUtil</code> does not need a feature factory.</p> <p>To iterate efficiently over the statements in an <code>RdfModel</code>, use its <code>iterator</code> method. An <code>RdfModel</code> cannot be modified while you are iterating over it. If you are iterating to look for statements to modify, you can collect a <code>Set</code> of statements to remove and a <code>Set</code> of statements to add, and perform these update operations after you have finished the iteration.</p>"},{"location":"05-internals/design/principles/rdf-api/#rdf-stream-processing","title":"RDF stream processing","text":"<p>To read or write a large amount of RDF data without generating a large string object, you can use the stream processing methods in <code>RdfFormatUtil</code>.</p> <p>To parse an <code>InputStream</code> to an <code>RdfModel</code>, use <code>inputStreamToRdfModel</code>. To format an <code>RdfModel</code> to an <code>OutputStream</code>, use <code>rdfModelToOutputStream</code>.</p> <p>To parse RDF data from an <code>InputStream</code> and process it one statement at a time, you can write a class that implements the <code>RdfStreamProcessor</code> trait, and use it with the <code>RdfFormatUtil.parseWithStreamProcessor</code> method. Your <code>RdfStreamProcessor</code> can also send one statement at a time to a formatting stream processor, which knows how to write RDF to an <code>OutputStream</code> in a particular format. Use <code>RdfFormatUtil.makeFormattingStreamProcessor</code> to construct one of these.</p>"},{"location":"05-internals/design/principles/rdf-api/#sparql-queries","title":"SPARQL queries","text":"<p>In tests, it can be useful to run SPARQL queries to check the content of an <code>RdfModel</code>. To do this, use the <code>RdfModel.asRepository</code> method, which returns an <code>RdfRepository</code> that can run <code>SELECT</code> queries.</p> <p>The configuration of the default graph depends on which underlying RDF library is used. If you are querying data in named graphs, use <code>FROM</code> or quad patterns rather than the default graph.</p>"},{"location":"05-internals/design/principles/rdf-api/#shacl-validation","title":"SHACL validation","text":"<p>On startup, graphs of SHACL shapes are loaded from Turtle files in a directory specified by <code>app.shacl.shapes-dir</code> in <code>application.conf</code>, and in subdirectories of that directory. To validate the default graph of an <code>RdfModel</code> using a graph of SHACL shapes, call <code>ShaclValidator.validate</code>, specifying the relative path of the Turtle file containing the graph of shapes.</p>"},{"location":"05-internals/design/principles/rdf-api/#implementations","title":"Implementations","text":"<ul> <li> <p>The Jena-based implementation, in package <code>org.knora.webapi.messages.util.rdf.jenaimpl</code>.</p> </li> <li> <p>The RDF4J-based implementation, in package <code>org.knora.webapi.messages.util.rdf.rdf4jimpl</code>.</p> </li> </ul>"},{"location":"05-internals/design/principles/store-module/","title":"Store Module","text":""},{"location":"05-internals/design/principles/store-module/#overview","title":"Overview","text":"<p>The store module houses the different types of data stores supported by Knora. At the moment, only triplestores and IIIF servers (Sipi) are supported. The triplestore support is implemented in the <code>org.knora.webapi.store.triplestore</code> package and the IIIF server support in <code>org.knora.webapi.store.iiif</code> package.</p>"},{"location":"05-internals/design/principles/store-module/#lifecycle","title":"Lifecycle","text":"<p>At the top level, the store package houses the <code>StoreManager</code>-Actor which is started when Knora starts. The <code>StoreManager</code> then starts the <code>TriplestoreManager</code> and <code>IIIFManager</code>, which each in turn starts their correct actor implementation.</p>"},{"location":"05-internals/design/principles/store-module/#triplestores","title":"Triplestores","text":"<p>Currently, the only supported triplestore is Apache Jena Fuseki, a HTTP-based triplestore.</p> <p>HTTP-based triplestore support is implemented in the <code>org.knora.webapi.triplestore.http</code> package.</p> <p>An HTTP-based triplestore is one that is accessed remotely over the HTTP protocol. <code>HttpTriplestoreConnector</code> supports the open source triplestore Apache Jena Fuseki.</p>"},{"location":"05-internals/design/principles/store-module/#iiif-servers","title":"IIIF Servers","text":"<p>Currently, only support for SIPI is implemented in <code>org.knora.webapi.store.iiifSipiConnector</code>.</p>"},{"location":"05-internals/design/principles/triplestore-updates/","title":"Triplestore Updates","text":""},{"location":"05-internals/design/principles/triplestore-updates/#requirements","title":"Requirements","text":""},{"location":"05-internals/design/principles/triplestore-updates/#general","title":"General","text":"<p>The supported update operations are:</p> <ul> <li>Create a new resource with its initial values.</li> <li>Add a new value.</li> <li>Change a value.</li> <li>Delete a value (i.e. mark it as deleted).</li> <li>Delete a resource (i.e. mark it as deleted).</li> </ul> <p>Users must be able to edit the same data concurrently.</p> <p>Each update must be atomic and leave the database in a consistent, meaningful state, respecting ontology constraints and permissions.</p> <p>The application must not use any sort of long-lived locks, because they tend to hinder concurrent edits, and it is difficult to ensure that they are released when they are no longer needed. Instead, if a user requests an update based on outdated information (because another user has just changed something, and the first user has not found out yet), the update must be not performed, and the application must notify the user who requested it, suggesting that the user should check the relevant data and try again if necessary. (We may eventually provide functionality to help users merge edits in such a situation. The application can also encourage users to coordinate with one another when they are working on the same data, and may eventually provide functionality to facilitate this coordination.)</p> <p>We can assume that each SPARQL update operation will run in its own database transaction with an isolation level of 'read committed'. We cannot assume that it is possible to run more than one SPARQL update in a single database transaction. The SPARQL 1.1 Protocol does not provide a way to do this, and currently it can be done only by embedding the triplestore in the application and using a vendor-specific API, but we cannot require this in Knora.)</p>"},{"location":"05-internals/design/principles/triplestore-updates/#permissions","title":"Permissions","text":"<p>To create a new value (as opposed to a new version of an existing value), the user must have permission to modify the containing resource.</p> <p>To create a new version of an existing value, the user needs only to have permission to modify the current version of the value; no permissions on the resource are needed.</p> <p>Since changing a link requires deleting the old link and creating a new one (as described in Linking), a user wishing to change a link must have modify permission on both the containing resource and the <code>knora-base:LinkValue</code> for the existing link.</p> <p>When a new resource or value is created, it can be given default permissions specified the project's admin data, or (only in API v2) custom permissions can be specified.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#ontology-constraints","title":"Ontology Constraints","text":"<p>Knora must not allow an update that would violate an ontology constraint.</p> <p>When creating a new value (as opposed to adding a new version of an existing value), Knora must not allow the update if the containing resource's OWL class does not contain a cardinality restriction for the submitted property, or if the new value would violate the cardinality restriction.</p> <p>It must also not allow the update if the type of the submitted value does not match the <code>knora-base:objectClassConstraint</code> of the property, or if the property has no <code>knora-base:objectClassConstraint</code>. In the case of a property that points to a resource, Knora must ensure that the target resource belongs to the OWL class specified in the property's <code>knora-base:objectClassConstraint</code>, or to a subclass of that class.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#versioning","title":"Versioning","text":"<p>Each Knora value (i.e. something belonging to an OWL class derived from <code>knora-base:Value</code>) is versioned. This means that once created, a value is never modified. Instead, 'changing' a value means creating a new version of the value --- actually a new value --- that points to the previous version using <code>knora-base:previousValue</code>. The versions of a value are a singly-linked list, pointing backwards into the past. When a new version of a value is made, the triple that points from the resource to the old version (using a subproperty of <code>knora-base:hasValue</code>) is removed, and a triple is added to point from the resource to the new version. Thus the resource always points only to the current version of the value, and the older versions are available only via the current version's <code>knora-base:previousValue</code> predicate.</p> <p>Unlike values, resources (members of OWL classes derived from <code>knora-base:Resource</code>) are not versioned. The data that is attached to a resource, other than its values, can be modified.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#deleting","title":"Deleting","text":"<p>Knora does not actually delete resources or values; it only marks them as deleted. Deleted data is normally hidden. All resources and values must have the predicate <code>knora- base:isDeleted</code>, whose object is a boolean. If a resource or value has been marked as deleted, it has <code>knora-base:isDeleted true</code> and has a <code>knora-base:deleteDate</code>. An optional <code>knora-base:deleteComment</code> may be added to explain why the resource or value has been marked as deleted.</p> <p>Normally, a value is marked as deleted without creating a new version of it. However, link values must be treated as a special case. Before a <code>LinkValue</code> can be marked as deleted, its reference count must be decremented to 0. Therefore, a new version of the <code>LinkValue</code> is made, with a reference count of 0, and it is this new version that is marked as deleted.</p> <p>Since it is necessary to be able to find out when a resource was deleted, it is not possible to undelete a resource. Moreover, to simplify the checking of cardinality constraints, and for consistency with resources, it is not possible to undelete a value, and no new versions of a deleted value can be made. Instead, if desired, a new resource or value can be created by copying data from a deleted resource or value.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#linking","title":"Linking","text":"<p>Links must be treated differently to other types of values. Knora needs to maintain information about the link, including permissions and a version history. Since the link does not have a unique IRI of its own, Knora uses RDF reifications for this purpose. Each link between two resources has exactly one (non-deleted) <code>knora-base:LinkValue</code>. The resource itself has a predicate that points to the <code>LinkValue</code>, using a naming convention in which the word <code>Value</code> is appended to the name of the link predicate to produce the link value predicate. For example, if a resource representing a book has a predicate called <code>hasAuthor</code> that points to another resource, it must also have a predicate called <code>hasAuthorValue</code> that points to the <code>LinkValue</code> in which information about the link is stored. To find a particular <code>LinkValue</code>, one can query it either by using its IRI (if known), or by using its <code>rdf:subject</code>, <code>rdf:predicate</code>, and <code>rdf:object</code> (and excluding link values that are marked as deleted).</p> <p>Like other values, link values are versioned. The link value predicate always points from the resource to the current version of the link value, and previous versions are available only via the current version's <code>knora-base:previousValue</code> predicate. Deleting a link means deleting the triple that links the two resources, and making a new version of the link value, marked with <code>knora-base:isDeleted</code>. A triple then points from the resource to this new, deleted version (using the link value property).</p> <p>The API allows a link to be 'changed' so that it points to a different target resource. This is implemented as follows: the existing triple connecting the two resources is removed, and a new triple is added using the same link property and pointing to the new target resource. A new version of the old link's <code>LinkValue</code> is made, marked with <code>knora-base:isDeleted</code>. A new <code>LinkValue</code> is made for the new link. The new <code>LinkValue</code> has no connection to the old one.</p> <p>When a resource contains <code>knora-base:TextValue</code> with Standoff markup that includes a reference to another resource, this reference is materialised as a direct link between the two resources, to make it easier to query. A special link property, <code>knora-base:hasStandoffLinkTo</code>, is used for this purpose. The corresponding link value property, <code>knora-base:hasStandoffLinkToValue</code>, points to a <code>LinkValue</code>. This <code>LinkValue</code> contains a reference count, indicated by <code>knora-base:valueHasRefCount</code>, that represents the number of text values in the containing resource that include one or more Standoff references to the specified target resource. Each time this number changes, a new version of this <code>LinkValue</code> is made. When the reference count reaches zero, the triple with <code>knora-base:hasStandoffLinkTo</code> is removed, and a new version of the <code>LinkValue</code> is made and marked with <code>knora-base:isDeleted</code>. If the same resource reference later appears again in a text value, a new triple is added using <code>knora-base:hasStandoffLinkTo</code>, and a new <code>LinkValue</code> is made, with no connection to the old one.</p> <p>For consistency, every <code>LinkValue</code> contains a reference count. If the link property is not <code>knora-base:hasStandoffLinkTo</code>, the reference count will always be either 1 (if the link exists) or 0 (if it has been deleted, in which case the link value will also be marked with <code>knora-base:isDeleted</code>).</p> <p>When a <code>LinkValue</code> is created for a standoff resource reference, it is given the same permissions as the text value containing the reference.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#design","title":"Design","text":""},{"location":"05-internals/design/principles/triplestore-updates/#responsibilities-of-responders","title":"Responsibilities of Responders","text":"<p>The resources responder (<code>ResourcesResponderV2</code>) has sole responsibility for generating SPARQL to create and updating resources, and the values responder (<code>ValuesResponderV2</code>) has sole responsibility for generating SPARQL to create and update values. When a new resource is created with its values, the values responder generates SPARQL statements that can be included in the <code>INSERT</code> clause of a SPARQL update to create the values, and the resources responder adds these statements to the SPARQL update that creates the resource. This ensures that the resource and its values are created in a single SPARQL update operation, and hence in a single triplestore transaction.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#application-level-locking","title":"Application-level Locking","text":"<p>The 'read committed' isolation level cannot prevent a scenario where two users want to add the same data at the same time. It is possible that both requests would do pre-update checks and simultaneously find that it is OK to add the data, and that both updates would then succeed, inserting redundant data and possibly violating ontology constraints. Therefore, Knora uses short-lived, application-level write locks on resources, to ensure that only one request at a time can update a given resource. Before each update, the application acquires a lock on a resource. To prevent deadlocks, Knora locks only one resource per API operation. It then does the pre-update checks and the update, then releases the lock. The lock implementation (in <code>IriLocker</code>) requires each API request message to include a random UUID, which is generated in the API Routing package. Using application-level locks allows us to do pre-update checks in their own transactions, and finally to do the SPARQL update in its own transaction.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#ensuring-data-consistency","title":"Ensuring Data Consistency","text":"<p>Knora enforces consistency constraints using three redundant mechanisms:</p> <ol> <li>By doing pre-update checks using SPARQL SELECT queries and cached    ontology data.</li> <li>By doing checks in the <code>WHERE</code> clauses of SPARQL updates.</li> </ol> <p>We take the view that redundant consistency checks are a good thing.</p> <p>Pre-update checks are SPARQL <code>SELECT</code> queries that are executed while holding an application-level lock on the resource to be updated. These checks should work with any triplestore, and can return helpful, Knora-specific error messages to the client if the request would violate a consistency constraint.</p> <p>However, the SPARQL update itself is our only chance to do pre-update checks in the same transaction that will perform the update. The design of the SPARQL 1.1 Update standard makes it possible to ensure that if certain conditions are not met, the update will not be performed. In our SPARQL update code, each update contains a <code>WHERE</code> clause, possibly a <code>DELETE</code> clause, and an <code>INSERT</code> clause. The <code>WHERE</code> clause is executed first. It performs consistency checks and provides values for variables that are used in the <code>DELETE</code> and/or <code>INSERT</code> clauses. In our updates, if the expectations of the <code>WHERE</code> clause are not met (e.g. because the data to be updated does not exist), the <code>WHERE</code> clause should return no results; as a result, the update will not be performed.</p> <p>Regardless of whether the update changes the contents of the triplestore, it returns nothing. If the update did nothing because the conditions of the WHERE clause were not met, the only way to find out is to do a <code>SELECT</code> afterwards. Moreover, in this case, there is no straightforward way to find out which conditions was not met. This is one reason why Knora does pre-update checks using separate <code>SELECT</code> queries and/or cached ontology data, before performing the update. This makes it possible to return specific error messages to the user to indicate why an update cannot be performed.</p> <p>Moreover, while some checks are easy to do in a SPARQL update, others are difficult, impractical, or impossible. Easy checks include checking whether a resource or value exists or is deleted, and checking that the <code>knora-base:objectClassConstraint</code> of a predicate matches the <code>rdf:type</code> of its intended object. Cardinality checks are not very difficult, but they perform poorly on Jena. Knora does not do permission checks in SPARQL, because its permission-checking algorithm is too complex to be implemented in SPARQL. For this reason, Knora's check for duplicate values cannot be done in SPARQL update code, because it relies on permission checks.</p> <p>In a bulk import operation, which can create a large number of resources in a single SPARQL update, a <code>WHERE</code> clause can become very expensive for the triplestore, in terms of memory as well as execution time. Moreover, RDF4J (and hence GraphDB) uses a recursive algorithm to parse SPARQL queries with <code>WHERE</code> clauses, so the size of a <code>WHERE</code> clause is limited by the stack space available to the Java Virtual Machine. Therefore, in bulk import operations, Knora uses <code>INSERT DATA</code>, which does not involve a <code>WHERE</code> clause. Bulk imports thus rely on checks (1) and (3) above.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#sparql-update-examples","title":"SPARQL Update Examples","text":"<p>The following sample SPARQL update code is simpler than what Knora actually does. It is included here to illustrate the way Knora's SPARQL updates are structured and how concurrent updates are handled.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#finding-a-value-iri-in-a-values-version-history","title":"Finding a value IRI in a value's version history","text":"<p>We will need this query below. If a value is present in a resource property's version history, the query returns everything known about the value, or nothing otherwise:</p> <pre><code>prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nprefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nprefix knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt;\n\nSELECT ?p ?o\nWHERE {\n    BIND(IRI(\"http://rdfh.ch/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://www.knora.org/ontology/0803/incunabula#book_comment\") as ?property)\n    BIND(IRI(\"http://rdfh.ch/c5058f3a/values/testComment002\") as ?searchValue)\n\n    ?resource ?property ?currentValue .\n    ?currentValue knora-base:previousValue* ?searchValue .\n    ?searchValue ?p ?o .\n}\n</code></pre>"},{"location":"05-internals/design/principles/triplestore-updates/#creating-the-initial-version-of-a-value","title":"Creating the initial version of a value","text":"<pre><code>prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nprefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nprefix knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt;\n\nWITH &lt;http://www.knora.org/ontology/0803/incunabula&gt;\nINSERT {\n    ?newValue rdf:type ?valueType ;\n              knora-base:valueHasString \"\"\"Comment 1\"\"\" ;\n              knora-base:attachedToUser &lt;http://rdfh.ch/users/91e19f1e01&gt; ;\n              knora-base:attachedToProject &lt;http://rdfh.ch/projects/77275339&gt; ;\n              knora-base:hasPermissions \"V knora-admin:KnownUser,knora-admin:UnknownUser|M knora-admin:ProjectMember\"  ;\n              knora-base:valueTimestamp ?currentTime .\n\n    ?resource ?property ?newValue .\n} WHERE {\n    BIND(IRI(\"http://rdfh.ch/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://www.knora.org/ontology/0803/incunabula#book_comment\") as ?property)\n    BIND(IRI(\"http://rdfh.ch/c5058f3a/values/testComment001\") AS ?newValue)\n    BIND(IRI(\"http://www.knora.org/ontology/knora-base#TextValue\") AS ?valueType)\n    BIND(NOW() AS ?currentTime)\n\n    # Do nothing if the resource doesn't exist.\n    ?resource rdf:type ?resourceClass .\n\n    # Do nothing if the submitted value has the wrong type.\n    ?property knora-base:objectClassConstraint ?valueType .\n}\n</code></pre> <p>To find out whether the insert succeeded, the application can use the query in Finding a value IRI in a value's version history to look for the new IRI in the property's version history.</p>"},{"location":"05-internals/design/principles/triplestore-updates/#adding-a-new-version-of-a-value","title":"Adding a new version of a value","text":"<pre><code>prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nprefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nprefix knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt;\n\nWITH &lt;http://www.knora.org/ontology/0803/incunabula&gt;\nDELETE {\n    ?resource ?property ?currentValue .\n} INSERT {\n    ?newValue rdf:type ?valueType ;\n              knora-base:valueHasString \"\"\"Comment 2\"\"\" ;\n              knora-base:previousValue ?currentValue ;\n              knora-base:attachedToUser &lt;http://rdfh.ch/users/91e19f1e01&gt; ;\n              knora-base:attachedToProject &lt;http://rdfh.ch/projects/77275339&gt; ;\n              knora-base:hasPermissions \"V knora-admin:KnownUser,knora-admin:UnknownUser|M knora-admin:ProjectMember\"  ;\n              knora-base:valueTimestamp ?currentTime .\n\n    ?resource ?property ?newValue .\n} WHERE {\n    BIND(IRI(\"http://rdfh.ch/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://rdfh.ch/c5058f3a/values/testComment001\") AS ?currentValue)\n    BIND(IRI(\"http://rdfh.ch/c5058f3a/values/testComment002\") AS ?newValue)\n    BIND(IRI(\"http://www.knora.org/ontology/knora-base#TextValue\") AS ?valueType)\n    BIND(NOW() AS ?currentTime)\n\n    ?resource ?property ?currentValue .\n    ?property knora-base:objectClassConstraint ?valueType .\n}\n</code></pre> <p>The update request must contain the IRI of the most recent version of the value (<code>http://rdfh.ch/c5058f3a/values/c3295339</code>). If this is not in fact the most recent version (because someone else has done an update), this operation will do nothing (because the <code>WHERE</code> clause will return no rows). To find out whether the update succeeded, the application will then need to do a SELECT query using the query in Finding a value IRI in a value's version history. In the case of concurrent updates, there are two possibilities:</p> <ol> <li>Users A and B are looking at version 1. User A submits an update and    it succeeds, creating version 2, which user A verifies using a    SELECT. User B then submits an update to version 1 but it fails,    because version 1 is no longer the latest version. User B's SELECT    will find that user B's new value IRI is absent from the value's    version history.</li> <li>Users A and B are looking at version 1. User A submits an update and    it succeeds, creating version 2. Before User A has time to do a    SELECT, user B reads the new value and updates it again. Both users    then do a SELECT, and find that both their new value IRIs are    present in the value's version history.</li> </ol>"},{"location":"05-internals/design/principles/triplestore-updates/#getting-all-versions-of-a-value","title":"Getting all versions of a value","text":"<pre><code>prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;\nprefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;\nprefix knora-base: &lt;http://www.knora.org/ontology/knora-base#&gt;\n\nSELECT ?value ?valueTimestamp ?previousValue\nWHERE {\n    BIND(IRI(\"http://rdfh.ch/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://www.knora.org/ontology/0803/incunabula#book_comment\") as ?property)\n    BIND(IRI(\"http://rdfh.ch/c5058f3a/values/testComment002\") AS ?currentValue)\n\n    ?resource ?property ?currentValue .\n    ?currentValue knora-base:previousValue* ?value .\n\n    OPTIONAL {\n        ?value knora-base:valueTimestamp ?valueTimestamp .\n    }\n\n    OPTIONAL {\n        ?value knora-base:previousValue ?previousValue .\n    }\n}\n</code></pre> <p>This assumes that we know the current version of the value. If the version we have is not actually the current version, this query will return no rows.</p>"},{"location":"05-internals/development/building-and-running/","title":"Building and Running","text":""},{"location":"05-internals/development/building-and-running/#setting-up-docker","title":"Setting up Docker","text":"<ol> <li>Install Docker</li> <li>Go to Docker preferences and increase the memory allocation.        The stack's memory usage is limited to ~20GB, though it should only use that much during heavy workloads. You should    be good to go in any case if you allocate 22GB or more.</li> </ol>"},{"location":"05-internals/development/building-and-running/#running-the-stack","title":"Running the stack","text":"<p>With Docker installed and configured,</p> <ol> <li>Run the following:</li> </ol> <pre><code>make init-db-test\n</code></pre> <p>to initialize Fuseki's dsp-repo dataset with loading some test data into the triplestore </p> <ol> <li>Start the entire knora-stack (fuseki (db), sipi, api, salsah1) with the following command:</li> </ol> <pre><code>make stack-up\n</code></pre> <p>Note: To delete the existing containers and for a clean start, before creating the knora-test repository explained in the first step above, run the following:</p> <pre><code>make stack-down-delete-volumes\n</code></pre> <p>This stops the knora-stack and deletes any created volumes (deletes the database!).</p> <p>To only shut down the Knora-Stack without deleting the containers:</p> <pre><code>make stack-down\n</code></pre> <p>To restart the knora-api use the following command:</p> <pre><code>make stack-restart-api\n</code></pre> <p>If a change is made to knora-api code, only its image needs to be rebuilt. In that case, use</p> <pre><code>make stack-up-fast\n</code></pre> <p>which starts the knora-stack by skipping rebuilding most of the images (only api image is rebuilt).</p> <p>To work on Metadata, use</p> <pre><code>make stack-up-with-metadata\n</code></pre> <p>which will put three example metadata sets to the projects <code>anything</code>, <code>images</code> and <code>dokubib</code>. This data can then be consumed from <code>localhost:3333/v2/metadata/http%3A%2F%2Frdfh.ch%2Fprojects%2F0001</code>, <code>localhost:3333/v2/metadata/http%3A%2F%2Frdfh.ch%2Fprojects%2F00FF</code> and <code>localhost:3333/v2/metadata/http%3A%2F%2Frdfh.ch%2Fprojects%2F0804</code>.</p>"},{"location":"05-internals/development/building-and-running/#managing-containers-in-docker-dashboard","title":"Managing Containers in Docker Dashboard","text":"<p>The Docker Desktop is installed on your computer during the installation of docker, it enables easy management of docker containers and access to Docker Hub. To manage your docker containers, docker desktop provides a dashbord.</p> <p></p> <p>In docker dashboard, you can see all the running containers, stop, start, restart, or completely delete them. For example, when you start the knora-stack as explained above, in the docker dashboard you will see following:</p> <p></p>"},{"location":"05-internals/development/building-and-running/#access-the-logs","title":"Access the logs","text":"<p>To read information logged out of any container (db, api, etc.), click on the container in the dashboard and choose <code>logs</code>. The example, below shows the logs of the database (db) container that includes the last SPARQL query sent to the triplestore.</p> <p></p> <p>Note that, you can also print out the log information directly from the command line. For example, the same logs of the database container can be printed out using the following command:</p> <pre><code>make stack-logs-db\n</code></pre> <p>Similarly, the logs of the other containers can be printed out by running make with <code>stack-logs-api</code> or <code>stack-logs-sipi</code>. These commands print out and follow the logs, to only print the logs out without following, use <code>-no-follow</code> version of the commands for example:</p> <pre><code>make stack-logs-db-no-follow\n</code></pre> <p>Lastly, to print out the entire logs of the running knora-stack, use</p> <pre><code>make stack-logs\n</code></pre> <p>With the Docker plugin installed, you can attach a terminal to the docker container within VS Code. This will stream the docker logs to the terminal window of the editor.</p> <p></p> <p>The docker plugin also allows for a number of other useful features, like inspecting the container's file system or attaching a shell to the container.</p>"},{"location":"05-internals/development/building-and-running/#running-against-the-dev-database","title":"Running against the dev database","text":"<p>When changes are hard to test with local test data (e.g. they need realistic data), you can run the API locally against the remote dev Fuseki triplestore:</p> <ol> <li>Create a <code>.env</code> file in the repo root with <code>DEV_DB_PASSWORD=&lt;password&gt;</code> (this file is git-ignored). Passwords can be found in ops-deploy/host_vars.</li> <li>Run:</li> </ol> <pre><code>just run-with-dev-db\n</code></pre> <ol> <li>The API will start connected to <code>db.dev.dasch.swiss</code> via HTTPS.</li> </ol>"},{"location":"05-internals/development/building-and-running/#running-the-automated-tests","title":"Running the automated tests","text":"<p>To run all test targets, use the following in the command line:</p> <pre><code>make test-all\n</code></pre> <p>To run a single test from the command line, for example <code>SearchV2R2RSpec</code>, run the following:</p> <pre><code>sbt \" webapi / testOnly *SearchV2R2RSpec* \"\n</code></pre> <p>Note: to run tests, the api container must be stopped first!</p>"},{"location":"05-internals/development/building-and-running/#build-and-publish-documentation","title":"Build and Publish Documentation","text":"<p>First, you need to install the requirements through:</p> <pre><code>make docs-install-requirements\n</code></pre> <p>Then, to build docs into the local <code>site</code> folder, run the following command:</p> <pre><code>make docs-build\n</code></pre> <p>At this point, you can serve the docs to view them locally using</p> <pre><code>make docs-serve\n</code></pre> <p>Lastly, to build and publish docs to Github Pages, use</p> <pre><code>make docs-publish\n</code></pre>"},{"location":"05-internals/development/building-and-running/#build-and-publish-docker-images","title":"Build and Publish Docker Images","text":"<p>To build and publish all Docker images locally</p> <pre><code>make docker-build\n</code></pre> <p>To publish all Docker images to Dockerhub</p> <pre><code>make docker-publish\n</code></pre>"},{"location":"05-internals/development/building-and-running/#continuous-integration","title":"Continuous Integration","text":"<p>For continuous integration testing, we use Github CI Actions. Every commit pushed to the git repository or every pull request, triggers the build. Additionally, in Github there is a small checkmark beside every commit, signaling the status of the build (successful, unsuccessful, ongoing).</p> <p>The build that is executed on Github CI Actions is defined in the <code>.github/workflows/*.yml</code> files.</p>"},{"location":"05-internals/development/building-and-running/#webapi-server-startup-flags","title":"Webapi Server Startup-Flags","text":"<p>The Webapi-Server can be started with a number of flags.</p>"},{"location":"05-internals/development/building-and-running/#loaddemodata-flag","title":"<code>loadDemoData</code> - Flag","text":"<p>When the webapi-server is started with the <code>loadDemoData</code> flag, then at startup, the data which is configured in <code>application.conf</code> under the <code>app.triplestore.rdf-data</code> key is loaded into the triplestore, and any data in the triplestore is removed beforehand.</p>"},{"location":"05-internals/development/docker-cheat-sheet/","title":"Docker Cheat Sheet","text":"<p>A complete cheat sheet can be found on GitHub.</p>"},{"location":"05-internals/development/docker-cheat-sheet/#lifecycle","title":"Lifecycle","text":"<ul> <li>docker create   creates a container but does not start it.</li> <li>docker run   creates and starts a container in one operation.</li> <li>docker rename   allows the container to be renamed.</li> <li>docker rm   deletes a container.</li> <li>docker update   updates a container's resource limits.</li> </ul> <p>If you want a transient container, <code>docker run --rm</code> will remove the container after it stops.</p> <p>If you want to map a directory on the host to a docker container, <code>docker run -v $HOSTDIR:$DOCKERDIR</code>.</p>"},{"location":"05-internals/development/docker-cheat-sheet/#starting-and-stopping","title":"Starting and Stopping","text":"<ul> <li>docker start   starts a container so it is running.</li> <li>docker stop stops a   running container.</li> <li>docker restart   stops and starts a container.</li> <li>docker pause   pauses a running container, \"freezing\" it in place.</li> <li>docker attach   will connect to a running container.</li> </ul>"},{"location":"05-internals/development/docker-cheat-sheet/#info","title":"Info","text":"<ul> <li>docker ps   shows running containers.</li> <li>docker logs gets   logs from container. (You can use a custom log driver, but logs is   only available for json-file and journald in 1.10)</li> <li>docker inspect   looks at all the info on a container (including IP address).</li> <li>docker events   gets events from container.</li> <li>docker port shows   public facing port of container.</li> <li>docker top   shows running processes in container.</li> <li>docker stats shows   containers' resource usage statistics.</li> <li>docker diff shows   changed files in the container's FS.</li> </ul> <p><code>docker ps -a</code> shows running and stopped containers.</p> <p><code>docker stats --all</code> shows a running list of containers.</p>"},{"location":"05-internals/development/docker-cheat-sheet/#executing-commands","title":"Executing Commands","text":"<ul> <li>docker exec to   execute a command in container.</li> </ul> <p>To enter a running container, attach a new shell process to a running container called foo, use: <code>docker exec -it foo /bin/bash</code>.</p>"},{"location":"05-internals/development/docker-cheat-sheet/#images","title":"Images","text":"<ul> <li>docker images shows all images.</li> <li>docker build creates image from Dockerfile.</li> </ul>"},{"location":"05-internals/development/docker-compose/","title":"Starting the Knora Stack inside Docker Container","text":"<p>To run Knora locally, we provide <code>docker-compose.yml</code> which can be used to start Fuseki, Sipi, Webapi running each in its own Docker container.</p> <p>To run the whole stack:</p> <pre><code>make stack-up\n</code></pre> <p>For additional information please see the Docker Compose documentation</p>"},{"location":"05-internals/development/overview/","title":"Overview","text":"<p>Developing for DSP-API requires a complete local installation of Knora. The different parts are:</p> <ol> <li>The cloned DSP-API Github    repository</li> <li>Fuseki - supplied triplestore in the DSP-API Github repository.</li> <li>Sipi by building from     source or using the docker     image</li> </ol>"},{"location":"05-internals/development/overview/#knora-github-repository","title":"Knora Github Repository","text":"<pre><code>git clone https://github.com/dasch-swiss/dsp-api\n</code></pre>"},{"location":"05-internals/development/overview/#triplestore","title":"Triplestore","text":"<p>A number of triplestore implementations are available, including free software as well as proprietary options. DSP-API is designed to work with any standards-compliant triplestore. It is primarily tested with Apache Jena Fuseki.</p>"},{"location":"05-internals/development/overview/#sipi","title":"Sipi","text":""},{"location":"05-internals/development/overview/#build-sipi-docker-image","title":"Build Sipi Docker Image","text":"<p>The Sipi docker image needs to be build by hand, as it requires the Kakadu distribution.</p> <p>To build the image, and push it to the docker hub, follow the following steps:</p> <pre><code>$ git clone https://github.com/dhlab-basel/docker-sipi\n(copy the Kakadu distribution ``v7_8-01382N.zip`` to the ``docker-sipi`` directory)\n$ docker build -t daschswiss/sipi\n$ docker run --name sipi --rm -it -p 1024:1024 daschswiss/sipi\n(Ctrl-c out of terminal will stop and delete container)\n$ docker push daschswiss/sipi\n</code></pre> <p>Pushing the image to the docker hub requires prior authentication with <code>$ docker login</code>. The user needs to be registered on <code>hub.docker.com</code>. Also, the user needs to be allowed to push to the <code>dblabbasel</code> organisation.</p>"},{"location":"05-internals/development/overview/#running-sipi","title":"Running Sipi","text":"<p>To use the docker image stored locally or on the docker hub repository type:</p> <pre><code>docker run --name sipi -d -p 1024:1024 daschswiss/sipi\n</code></pre> <p>This will create and start a docker container with the <code>daschswiss/sipi</code> image in the background. The default behaviour is to start Sipi by calling the following command:</p> <pre><code>/sipi/local/bin/sipi -config /sipi/config/sipi.test-config.lua\n</code></pre> <p>To override this default behaviour, start the container by supplying another config file:</p> <pre><code>docker run --name sipi \\\n             -d \\\n             -p 1024:1024 \\\n             daschswiss/sipi \\\n             /sipi/local/bin/sipi -config /sipi/config/sipi.config.lua\n</code></pre> <p>You can also mount a directory (the local directory in this example), and use a config file that is outside of the docker container:</p> <pre><code>docker run --name sipi \\\n             -d \\\n             -p 1024:1024 \\\n             -v $PWD:/localdir \\\n             daschswiss/sipi \\\n             /sipi/local/bin/sipi -config /localdir/sipi.test-config.lua\n</code></pre>"},{"location":"05-internals/development/testing/","title":"Testing","text":""},{"location":"05-internals/development/testing/#how-to-write-and-run-unit-tests","title":"How to Write and Run Unit Tests","text":"<p>A test is not a unit test if:</p> <ul> <li>It talks to the database</li> <li>It communicates across the network</li> <li>It touches the file system</li> <li>It can\u2019t run at the same time as any of your other unit tests</li> <li>You have to do special things to your environment (such as editing config files) to run it</li> </ul> <p>Unit tests live in the <code>src/test</code> folder of our sbt projects.</p> <p>Run all unit tests from terminal:</p> <pre><code>sbt test\n</code></pre>"},{"location":"05-internals/development/testing/#how-to-write-and-run-integration-tests","title":"How to Write and Run Integration Tests","text":"<p>Mostly you should consider writing unit tests.  These can be executed fast and help developers more in their daily work.</p> <p>You might need to create an integration test because:</p> <ul> <li>The test needs to talk to a database</li> <li>It requires network</li> <li>It is slow and cannot run in parallel with other tests</li> <li>You have to do special things to the environment in order to run it</li> </ul> <p>In this case create it in the <code>modules/test-it/src/test/scala/</code> directory.</p> <p>Run all integration tests from the terminal.</p> <pre><code>make test-it\n</code></pre> <p>Run all end-to-end HTTP API tests from the terminal.</p> <pre><code>make test-e2e\n</code></pre>"},{"location":"05-internals/development/testing/#sipi-image-versioning","title":"Sipi Image Versioning","text":"<p>Integration tests use different Sipi image versions based on environment:</p> <ul> <li>Local development: Uses <code>daschswiss/knora-sipi:latest</code> (default)</li> <li>CI environment: Uses exact git version (e.g., <code>v31.20.0-6-gfa52f5f</code>)</li> </ul> <p>You can override this behavior with environment variables:</p> <ul> <li><code>SIPI_VERSION=&lt;version&gt;</code> - Use specific version</li> <li><code>SIPI_USE_EXACT_VERSION=true</code> - Force exact git version locally</li> </ul> <p>If the required image doesn't exist locally, build it with:</p> <pre><code>make docker-build-sipi-image\n</code></pre>"},{"location":"05-internals/development/testing/#debugging","title":"Debugging","text":"<p>You can debug unit tests directly in your IDE. </p> <p>For debugging integration tests locally with <code>sbt</code> or your IDE, tests will use the <code>latest</code> Sipi image by default. If you need a specific version, use the environment variables described above.</p>"},{"location":"05-internals/development/third-party/","title":"Third-Party Dependencies","text":"<p>Third party libraries are managed by SBT.</p>"},{"location":"05-internals/development/third-party/#defining-dependencies-in-dependenciesscala","title":"Defining Dependencies in <code>Dependencies.scala</code>","text":"<p>Within the <code>build.sbt</code> file, the <code>Dependencies</code> package is referenced, which is located in <code>project/Dependencies.scala</code>. All third party dependencies need to be declared there.</p>"},{"location":"05-internals/development/third-party/#referencing-a-third-party-library","title":"Referencing a third party library","text":"<p>There is an object <code>Dependencies</code> where each library should be declared in a <code>val</code>.</p> <pre><code>val akkaHttpCors = \"ch.megard\" %% \"pekko-http-cors\" % \"1.0.0\"\n</code></pre> <p>The first string corresponds to the group/organization in the library's maven artefact, the second string corresponds to the artefact ID and the third string defines the version.</p> <p>The strings are combined with <code>%</code> or <code>%%</code> operators, the latter fixing the dependency to the specified scala-version.</p> <p>It is also possible to use variables in these definitions, e.g. if multiple dependencies share a version number:</p> <pre><code>val ZioVersion = \"2.0.0-RC2\"\nval zio = \"dev.zio\" %% \"zio\" % ZioVersion\nval zioTest = \"dev.zio\" %% \"zio-test\" % ZioVersion\n</code></pre>"},{"location":"05-internals/development/third-party/#assigning-the-dependencies-to-a-specific-subproject","title":"Assigning the dependencies to a specific subproject","text":"<p>For each SBT project, there is one <code>Seq</code> in the <code>Dependencies</code> object. In order to make use of the declared dependencies, they must be referred to in the <code>Seq</code> of the respective subproject.</p> <pre><code>val webapiLibraryDependencies = Seq(\n    akkaActor,\n    akkaHttp,\n    akkaSlf4j % Runtime,\n    akkaHttpTestkit % Test,\n    ...\n)\n</code></pre> <p>By default, the dependencies will be scoped to compile time. But it's possible to override this to <code>Runtime</code> or <code>Test</code>.</p>"},{"location":"05-internals/development/third-party/#docker-image-versions","title":"Docker Image Versions","text":"<p>The required Docker image versions of <code>Sipi</code> and <code>Fuseki</code> are also defined in the <code>Dependencies.scala</code> file.</p>"},{"location":"05-internals/development/updating-repositories/","title":"Updating Repositories","text":""},{"location":"05-internals/development/updating-repositories/#requirements","title":"Requirements","text":"<ul> <li> <p>When a new version of Knora requires an existing repository to be updated,   do this automatically when Knora starts, if possible.</p> </li> <li> <p>Make the update process as fast as possible, with some indication of progress   as it runs.</p> </li> </ul>"},{"location":"05-internals/development/updating-repositories/#design","title":"Design","text":"<p>As explained in Knora Ontology Versions, the <code>knora-base</code> ontology contains a version string to ensure compatibility between a repository and a given version of Knora. The same version string is therefore hard-coded in the Knora source code, in the string constant <code>org.knora.webapi.KnoraBaseVersion</code>. For new pull requests, the format of this string is <code>knora-base vN</code>, where <code>N</code> is an integer that is incremented for each version.</p> <p>During Knora's startup process, <code>ApplicationActor</code> sends an <code>UpdateRepositoryRequest</code> message to the <code>StoreManager</code>, which forwards it to <code>TriplestoreManager</code>, which delegates it to <code>org.knora.webapi.store.triplestore.upgrade.RepositoryUpdater</code>.</p> <p><code>RepositoryUpdater</code> does the following procedure:</p> <ol> <li> <p>Check the <code>knora-base</code> version string in the repository.</p> </li> <li> <p>Consult <code>org.knora.webapi.store.triplestore.upgrade.RepositoryUpdatePlan</code> to see which    transformations are needed.</p> </li> <li> <p>Download the entire repository from the triplestore into an N-Quads file.</p> </li> <li> <p>Read the N-Quads file into an <code>RdfModel</code>.</p> </li> <li> <p>Update the <code>RdfModel</code> by running the necessary transformations, and replacing the    built-in DSP ontologies with the current ones.</p> </li> <li> <p>Save the <code>RdfModel</code> to a new N-Quads file.</p> </li> <li> <p>Empty the repository in the triplestore.</p> </li> <li> <p>Upload the transformed repository file to the triplestore.</p> </li> </ol> <p>To update the <code>RdfModel</code>, <code>RepositoryUpdater</code> runs a sequence of upgrade plugins, each of which is a class in <code>org.knora.webapi.store.triplestore.upgrade.plugins</code> and is registered in <code>RepositoryUpdatePlan</code>.</p>"},{"location":"05-internals/development/updating-repositories/#design-rationale","title":"Design Rationale","text":"<p>We tried and rejected several other designs:</p> <ul> <li> <p>Running SPARQL updates in the triplestore: too slow, and no way to report   progress during the update.</p> </li> <li> <p>Downloading the repository and transforming it in Python using   rdflib: too slow.</p> </li> <li> <p>Downloading the repository and transforming it in C++ using   Redland: also too slow.</p> </li> </ul> <p>The Scala implementation is the fastest by far.</p> <p>The whole repository is uploaded in a single transaction, rather than uploading one named graph at a time, because GraphDB's consistency checker can enforce dependencies between named graphs.</p>"},{"location":"05-internals/development/updating-repositories/#adding-an-upgrade-plugin","title":"Adding an Upgrade Plugin","text":"<p>Each time a pull request introduces changes that are not compatible with existing data, the following must happen:</p> <ul> <li> <p>The <code>knora-base</code> version number must be incremented in <code>knora-base.ttl</code> and   in the string constant <code>org.knora.webapi.KnoraBaseVersion</code>.</p> </li> <li> <p>A plugin must be added in the package <code>org.knora.webapi.store.triplestore.upgrade.plugins</code>,   to transform existing repositories so that they are compatible with the code changes   introduced in the pull request. Each new plugin must be registered   by adding it to the sequence returned by <code>RepositoryUpdatePlan.makePluginsForVersions</code>.</p> </li> </ul> <p>The order of version numbers (and the plugins) must correspond to the order in which the pull requests are merged.</p> <p>An upgrade plugin is a Scala class that extends <code>UpgradePlugin</code>. The name of the plugin class should refer to the pull request that made the transformation necessary, using the format <code>UpgradePluginPRNNNN</code>, where <code>NNNN</code> is the number of the pull request.</p> <p>A plugin's <code>transform</code> method takes an <code>RdfModel</code> (a mutable object representing the repository) and modifies it as needed.</p> <p>Before transforming the data, a plugin can check whether a required manual transformation has been carried out. If the requirement is not met, the plugin can throw <code>InconsistentRepositoryDataException</code> to abort the upgrade process.</p>"},{"location":"05-internals/development/updating-repositories/#testing-update-plugins","title":"Testing Update Plugins","text":"<p>Each plugin should have a unit test that extends <code>UpgradePluginSpec</code>. A typical test loads a file containing RDF test data into a <code>RdfModel</code>, runs the plugin, makes an <code>RdfRepository</code> containing the transformed <code>RdfModel</code>, and uses SPARQL to check the result.</p>"},{"location":"05-internals/development/vscode-config/","title":"Setup Visual Studio Code for development of DSP-API","text":"<p>To have full functionality, the Scala Metals plugin should be installed.</p> <p>Additionally, a number of plugins can be installed for convenience, but are not required.  Those include but are by no means limited to:</p> <ul> <li>Docker - to attach to running docker containers</li> <li>Stardog RDF grammar - TTL syntax highlighting</li> <li>Lua</li> <li>REST client</li> <li>...</li> </ul>"},{"location":"05-internals/development/vscode-config/#formatter","title":"Formatter","text":"<p>As a formatter, we use Scalafmt. Metals automatically recognizes the formatting configuration in the <code>.scalafmt.conf</code> file in the root directory. VSCode should be configured so that it austomatically formats (e.g. on file saved).</p>"},{"location":"05-internals/development/vscode-config/#running-tests","title":"Running Tests","text":"<p>The tests can be run through make commands or through SBT. The most convenient way to run the tests is through VSCode. Metals recognizes scalatest suits and lets you run them in the text explorer:</p> <p></p> <p>Or with the setting <code>\"metals.testUserInterface\": \"Code Lenses\"</code> directly in the text:</p> <p></p>"},{"location":"05-internals/development/vscode-config/#debugger","title":"Debugger","text":"<p>It is currently not possible to start the stack in debug mode.</p> <p>Tests can be run in debug mode by running them as described above but choosing <code>debug test</code> instead of <code>test</code>.</p>"},{"location":"06-sipi/","title":"The Sipi Media Server","text":"<p>Sipi is a high-performance media server written in C++, for serving and converting binary media files such as images and video. Sipi can efficiently convert between many different formats on demand, preserving embedded metadata, and implements the International Image Interoperability Framework (IIIF). DSP-API is designed to use Sipi for converting and serving media files.</p> <ul> <li>Interaction Between Sipi and DSP-API</li> </ul>"},{"location":"06-sipi/sipi-and-dsp-api/","title":"Interaction Between Sipi and DSP-API","text":""},{"location":"06-sipi/sipi-and-dsp-api/#general-remarks","title":"General Remarks","text":"<p>DSP-API and Sipi (Simple Image Presentation Interface) are two complementary software projects. Whereas DSP-API deals with data that is written to and read from a triplestore (metadata and annotations), Sipi takes care of storing, converting and serving image files as well as other types of files such as audio, video, or documents (binary files it just stores and serves).</p> <p>DSP-API and Sipi stick to a clear division of responsibility regarding files: DSP-API knows about the names of files that are attached to resources as well as some metadata and is capable of creating the URLs for the client to request them from Sipi, but the whole handling of files (storing, naming, organization of the internal directory structure, format conversions, and serving) is taken care of by Sipi.</p>"},{"location":"06-sipi/sipi-and-dsp-api/#adding-files-to-dsp","title":"Adding Files to DSP","text":"<p>A file is first uploaded to Sipi, then its metadata is submitted to DSP. The implementation of this procedure is described in DSP-API and Sipi. Instructions for the client are given in Creating File Values.</p>"},{"location":"06-sipi/sipi-and-dsp-api/#retrieving-files-from-sipi","title":"Retrieving Files from Sipi","text":""},{"location":"06-sipi/sipi-and-dsp-api/#file-urls-in-api-v2","title":"File URLs in API v2","text":"<p>In DSP-API v2, image file URLs are provided in IIIF format. In the simple ontology schema, a file value is simply a IIIF URL that can be used to retrieve the file from Sipi. In the complex schema, it is a <code>StillImageFileValue</code> with additional properties that the client can use to construct different IIIF URLs, e.g. at different resolutions. See the <code>knora-api</code> ontology for details.</p>"},{"location":"06-sipi/sipi-and-dsp-api/#authentication-of-users-with-sipi","title":"Authentication of Users with Sipi","text":"<p>File access is restricted to users who have the permission to view the resource that the file is attached to. In order to check whether a user has the permission to view a resource, Sipi needs to know the user's identity. The identity is provided by DSP-API in the form of a JWT token. The token must be provided in the <code>Authorization</code> header of the request as a <code>Bearer</code> type token.</p> <p>Any other method of authentication is deprecated.</p>"},{"location":"07-lucene/lucene-query-parser-syntax/","title":"Lucene","text":"<p>The Lucene full-text index provided by the triplestore is used to perform full-text searches in DSP.</p>"},{"location":"07-lucene/lucene-query-parser-syntax/#lucene-query-parser-syntax","title":"Lucene Query Parser Syntax","text":"<p>Full-text searches in DSP are based on Lucene.  Therefore, full-text searches support the  Lucene Query Parser Syntax.</p> <p>A full-text search consists of a single word in the simplest case, but could also be composed of several words combined with  Boolean operators. By default, Lucene combines two or more terms separated by space with a logical OR.</p> <p>For examples, see  Lucene Query Parser Syntax.</p>"},{"location":"08-faq/","title":"Frequently Asked Questions","text":""},{"location":"08-faq/#file-formats","title":"File Formats","text":""},{"location":"08-faq/#what-file-formats-does-knora-store","title":"What file formats does Knora store?","text":"<p>See File Formats in Knora.</p>"},{"location":"08-faq/#does-knora-store-xml-files","title":"Does Knora store XML files?","text":"<p>XML files do not lend themselves to searching and linking. Knora's RDF storage is better suited to its goal of facilitating data reuse.</p> <p>If your XML files represent text with markup (e.g. TEI/XML), the recommended approach is to allow Knora to store it as Standoff/RDF. This will allow both text and markup to be searched using Gravsearch. Knora can also regenerate, at any time, an XML document that is equivalent to the original one.</p> <p>If you have XML that simply represents structured data (rather than text documents), we recommend converting it to Knora resources, which are stored as RDF.</p>"},{"location":"08-faq/#triplestores","title":"Triplestores","text":""},{"location":"08-faq/#which-triplestores-can-be-used-with-dsp-api","title":"Which triplestores can be used with DSP-API?","text":"<p>DSP-API is tested with Apache Jena Fuseki.</p>"},{"location":"08-faq/#dsp-ontologies","title":"DSP Ontologies","text":""},{"location":"08-faq/#can-a-project-use-classes-or-properties-defined-in-another-projects-ontology","title":"Can a project use classes or properties defined in another project's ontology?","text":"<p>DSP-API does not allow this to be done with project-specific ontologies. Each project must be free to change its own ontologies, but this is not possible if they have been used in ontologies or data created by other projects.</p> <p>However, an ontology can be defined as shared, meaning that it can be used by multiple projects, and that its creators promise not to change it in ways that could affect other ontologies or data that are based on it. See Shared Ontologies for details.</p>"},{"location":"08-faq/#why-doesnt-dsp-api-use-rdfsdomain-and-rdfsrange-for-consistency-checking","title":"Why doesn't DSP-API use <code>rdfs:domain</code> and <code>rdfs:range</code> for consistency checking?","text":"<p>DSP-API's consistency checking uses specific properties, which are called <code>knora-base:subjectClassConstraint</code> and <code>knora-base:objectClassConstraint</code> in the <code>knora-base</code> ontology, and <code>knora-api:subjectType</code> and <code>knora-api:objectType</code> in the <code>knora-api</code> ontologies. These properties express restrictions on the possible subjects and objects of a property. If a property's subject or object does not conform to the specified restrictions, DSP-API considers it an error.</p> <p>In contrast, the RDF Schema specification says that <code>rdfs:domain</code> and <code>rdfs:range</code> can be used to \"infer additional information\" about the subjects and objects of properties, rather than to enforce restrictions. This is, in fact, what RDFS reasoners do in practice. For example, consider these statements:</p> <pre><code>example:hasAuthor rdfs:range example:Person .\ndata:book1 example:hasAuthor data:oxygen .\n</code></pre> <p>To an RDFS reasoner, the first statement means: if something is used as the object of <code>example:hasAuthor</code>, we can infer that it's an <code>example:Person</code>.</p> <p>The second statement is a mistake; oxygen is not a person. But an RDFS reasoner would infer that <code>data:oxygen</code> is actually an <code>example:Person</code>, since it is used as the object of <code>example:hasAuthor</code>. Queries looking for persons would then get <code>data:oxygen</code> in their results, which would be incorrect.</p> <p>Therefore, <code>rdfs:domain</code> and <code>rdfs:range</code> are not suitable for consistency checking.</p> <p>DSP-API therefore uses its own properties, along with OWL cardinalities, which it interprets according to a \"closed world\" assumption. DSP-API performs its own consistency checks to enforce these restrictions. DSP-API repositories can also take advantage of triplestore-specific consistency checking mechanisms.</p> <p>The constraint language SHACL may someday provide a standard, triplestore-independent way to implement consistency checks, if the obstacles to its adoption can be overcome (see Diverging views of SHACL). For further discussion of these issues, see SHACL and OWL Compared.</p>"},{"location":"08-faq/#can-a-user-created-property-be-an-owltransitiveproperty","title":"Can a user-created property be an <code>owl:TransitiveProperty</code>?","text":"<p>No, because in DSP-API, a resource controls its properties. This basic assumption is what allows DSP-API to enforce permissions and transaction integrity. The concept of a transitive property would break this assumption.</p> <p>Consider a link property <code>hasLinkToFoo</code> that is defined as an <code>owl:TransitiveProperty</code>, and is used to link resource <code>Foo1</code> to resource <code>Foo2</code>:</p> <p></p> <p>Suppose that <code>Foo1</code> and <code>Foo2</code> are owned by different users, and that the owner of <code>Foo2</code> does not have permission to change <code>Foo1</code>. Now suppose that the owner of <code>Foo2</code> adds a link from <code>Foo2</code> to <code>Foo3</code>, using the transitive property:</p> <p></p> <p>Since the property is transitive, a link from <code>Foo1</code> to <code>Foo3</code> is now inferred. But this should not be allowed, because the owner of <code>Foo2</code> does not have permission to add a link to <code>Foo1</code>.</p> <p>Moreover, even if the owner of <code>Foo2</code> did have that permission, the inferred link would not have a <code>knora-base:LinkValue</code> (a reification), which every link must have. The <code>LinkValue</code> is what stores metadata about the creator of the link, its creation date, its permissions, and so on (see LinkValue).</p> <p>Finally, if an update to a resource could modify another resource, this would violate DSP-API's model of transaction integrity, in which each transaction can modify only one resource (see Application-level Locking). DSP-API would then be unable to ensure that concurrent transactions do not interfere with each other.</p>"},{"location":"09-release-notes/","title":"Changelog","text":"<p>{%    include-markdown \"../../CHANGELOG.md\" %}</p>"},{"location":"10-migration-guides/","title":"Overview","text":"<p>Generally, DSP-API is designed to be backward compatible. Whenever a new major version of DSP-API is released, the existing data is migrated to the new version automatically. The public Rest API is also stable and should remain backward compatible.</p> <p>However, when a feature appears not to be used, or if there are urgent technical reasons to change the API, we may decide to release breaking changes. In these instances, we try to provide a migration guide, in case some project or application is affected by the change.</p> <p>If you experience any issues with the migration, please contact us via the DaSCH Help Center.</p>"},{"location":"10-migration-guides/#migration-guides","title":"Migration Guides","text":""},{"location":"10-migration-guides/#planned-removal-of-knora-baseissequenceof-and-knora-basehassequencebounds","title":"Planned: Removal of <code>knora-base:isSequenceOf</code> and <code>knora-base:hasSequenceBounds</code>","text":"<p>If you have used <code>knora-base:isSequenceOf</code> and <code>knora-base:hasSequenceBounds</code> in your data, this should be replaced by <code>knora-base:isAudioSegmentOf</code> or <code>knora-base:isVideoSegmentOf</code> respectively, and <code>knora-base:hasSegmentBounds</code>.</p> <p>The issue with that is that these properties are only allowed on resources of type <code>knora-base:AudioSegment</code> and <code>knora-base:VideoSegment</code>, whereas previously <code>knora-base:isSequenceOf</code> could be added to any <code>knora-base:Resource</code>. This means that you will have to change the type of the resources that you have been using to be of type <code>knora-base:AudioSegment</code> or <code>knora-base:VideoSegment</code>.</p>"},{"location":"10-migration-guides/#deprecation-warnings","title":"Deprecation Warnings","text":""},{"location":"10-migration-guides/#issequenceof-and-hassequencebounds","title":"<code>isSequenceOf</code> and <code>hasSequenceBounds</code>","text":"<p>With the introduction of the new <code>Segment</code> concept in DSP-API v30.11.0, the previously existing properties <code>knora-base:isSequenceOf</code> and <code>knora-base:hasSequenceBounds</code> have been deprecated and will be removed in a future version.</p> <p>If you are creating a new ontology, please do not use these properties anymore. Instead, use the newly introduced Segment type.</p> <p>More information on Segments can be found in the knora-base ontology documentation.</p>"},{"location":"10-migration-guides/#updating-doaps","title":"Updating DOAPs","text":"<p>For updating DOAPs, using the general-purpose route <code>/admin/permissions/{permissionIri}/group|hasPermissions</code> is deprecated and will be removed in a future version.</p> <p>Insteads use <code>/admin/permissions/doap/{permissionIri}</code> as described in the permission documentation.</p>"},{"location":"10-migration-guides/#retrieving-list-information","title":"Retrieving List Information","text":"<p>For retrieving list infos, the routes <code>/admin/lists/infos/{listIri}</code> and <code>/admin/lists/nodes/{listIri}</code> are deprecated and will be removed in a future version. Instead, use <code>/admin/lists/{listIri}/info</code>  as described in the lists api documentation. </p>"},{"location":"10-migration-guides/#authentication","title":"Authentication","text":"<p>All authentication methods other than the bearer token are deprecated. This includes DSP-API and Sipi. For more information, see the Authentication page and the SIPI documentation.</p>"},{"location":"10-migration-guides/#cardinality-replacement-check","title":"Cardinality Replacement Check","text":"<p>The unparametrised check if it is possible to replace a cardinality of a property on a resource class is deprecated. Instead of <code>/v2/ontologies/canreplacecardinalities/{classIRI}</code>, use <code>/v2/ontologies/canreplacecardinalities/{classIRI}?propertyIri={propertyIRI}&amp;newCardinality=[0-1|1|1-n|0-n]</code>.</p> <p>For more information, see the api documentation.</p>"},{"location":"10-migration-guides/#admin-project-exportimport","title":"Admin Project Export/Import","text":"<p>The following admin endpoints for project export and import are deprecated and will be removed in a future version:</p> <ul> <li><code>GET /admin/projects/export</code></li> <li><code>POST /admin/projects/shortcode/{projectShortcode}/export</code></li> <li><code>POST /admin/projects/shortcode/{projectShortcode}/export-await</code></li> <li><code>POST /admin/projects/shortcode/{projectShortcode}/import</code></li> </ul> <p>These endpoints are not in use and a similar functionality will be implemented the new v3 project data export/import API.</p>"},{"location":"10-migration-guides/#filevaluehasexternalurl","title":"<code>fileValueHasExternalUrl</code>","text":"<p>For still image file values, the property <code>knora-base:fileValueHasExternalUrl</code> is deprecated. Instead, use <code>knora-base:stillImageFileValueExternalFileValue</code>. Additionally, this property should no longer be typed as a string literal, but as a <code>xsd:anyURI</code> instead.</p> <p>For more information, see the api documentation.</p>"},{"location":"architecture/","title":"C4 Model and ADRs","text":""},{"location":"architecture/#installation","title":"Installation","text":"<pre><code>brew install adr-tools\n</code></pre>"},{"location":"architecture/#usage","title":"Usage","text":"<p>Run the following command from the root directory to start the C4 model browser:</p> <pre><code>make structurizer\n</code></pre>"},{"location":"architecture/docs/http-request-flow-with-events/","title":"Http request flow with events","text":""},{"location":"architecture/docs/http-request-flow-with-events/#example-for-an-http-request-flow-with-events","title":"Example for an HTTP Request Flow with Events","text":""},{"location":"architecture/docs/http-request-flow-with-events/#create-a-user","title":"Create a User","text":"<pre><code>sequenceDiagram\n    autonumber\n    user                    -&gt;&gt; userRoute:               \"sends HTTP request\"\n    userRoute               -&gt;&gt; userRoute:               \"validates input (payload) and creates value objects\"\n    userRoute               -&gt;&gt; userHandler:             \"sends value objects\"\n    userHandler             -&gt;&gt; userRepo:                \"reserves username\"\n    userRepo                -&gt;&gt; eventStoreService:       \"reserves username\"\n    eventStoreService       -&gt;&gt; eventStoreService:       \"checks if username exists\"\n    eventStoreService       -&gt;&gt; eventStoreService:       \"reserves username\"\n    userHandler             -&gt;&gt; userDomain:              \"calls User.make() with value objects\"\n    userDomain              -&gt;&gt; userDomain:              \"creates userDomainEntity + userCreatedEvent(who, what)\"\n    userDomain              -&gt;&gt; userHandler:             \"returns (userDomainEntity + userCreatedEvent)\"\n    userHandler             -&gt;&gt; userRepo:                \"storeUser(userDomainEntity + userCreatedEvent)\"\n    userRepo                -&gt;&gt; eventStoreService:       \"storeUser(userDomainEntity + userCreatedEvent)\"\n    eventStoreService       -&gt;&gt; eventStoreService:       \"store event(s), userCreatedEvent(who, what, when(!))\"\n    eventStoreService       -&gt;&gt; eventListener:           \"publishEvent(userCreatedEvent)\"\n    eventListener           -&gt;&gt; triplestoreService:      \"writeToTsService(E)\"\n    triplestoreService      -&gt;&gt; triplestoreService:      \"SPARQL update - write user to triplestore\"\n    eventListener           -&gt;&gt; arkService:              \"writeToArkService(E)\"\n    arkService              -&gt;&gt; arkService:              \"create ARK(URL)\"\n    eventListener           -&gt;&gt; elasticSearchService:    \"writeToEsService(E)\"\n    elasticSearchService    -&gt;&gt; elasticSearchService:    \"write\"</code></pre>"},{"location":"architecture/docs/http-request-flow/","title":"Http request flow","text":""},{"location":"architecture/docs/http-request-flow/#http-request-flow-v2-vs-v3","title":"HTTP Request Flow V2 vs. V3","text":"<p>V2 / admin:</p> <pre><code>sequenceDiagram\n    autonumber\n    client              -&gt;&gt; route: send http request\n    route               -&gt;&gt; authenticator: authenticate user\n    authenticator       -&gt;&gt; route: user authenticated\n    route               -&gt;&gt; application actor: send message\n    application actor   -&gt;&gt; responder manager: forward message\n    responder manager   -&gt;&gt; responder: forward message\n    responder           -&gt;&gt; responder manager: return result\n    responder manager   -&gt;&gt; application actor: forward result\n    application actor   -&gt;&gt; route: forward result\n    route               -&gt;&gt; client: send http response</code></pre>"},{"location":"learnings/CLAUDE/","title":"Learnings Directory","text":""},{"location":"learnings/CLAUDE/#format-requirements","title":"Format Requirements","text":"<p>All learning files in this directory must conform to the format produced by the <code>eng:workflows:compound</code> plugin (the <code>/eng:workflows:compound</code> skill).</p> <p>Before adding or modifying any learning file, verify that:</p> <ol> <li>YAML frontmatter includes all required fields: <code>title</code>, <code>date</code>, <code>category</code>, <code>component</code>, <code>module</code>, <code>problem_type</code>, <code>severity</code>, <code>symptoms</code>, <code>root_cause</code>, <code>tags</code></li> <li>Category subdirectory matches the <code>category</code> field in the frontmatter (e.g. <code>build-errors/</code>, <code>logic-errors/</code>, <code>performance/</code>)</li> <li>Body sections follow the standard structure: <code>## Problem</code>, <code>## Root Cause</code>, <code>## Solution</code>, <code>## Prevention</code>, <code>## References</code></li> </ol> <p>If you are unsure whether the format is correct, prompt the user to run the <code>eng:workflows:compound</code> skill to verify or generate the learning in the correct format.</p>"},{"location":"learnings/build-errors/fork-long-lived-processes-from-build-tools/","title":"Long-lived processes need process isolation from the build tool","text":"","tags":["sbt","process-isolation","shutdown","developer-experience","server-applications"]},{"location":"learnings/build-errors/fork-long-lived-processes-from-build-tools/#problem","title":"Problem","text":"<p>Running a long-lived server application (HTTP server, ZIO app with Netty) via the build tool and pressing Ctrl+C resulted in a broken shutdown: <code>NoClassDefFoundError</code> cascades and a hung process requiring <code>kill -9</code>.</p>","tags":["sbt","process-isolation","shutdown","developer-experience","server-applications"]},{"location":"learnings/build-errors/fork-long-lived-processes-from-build-tools/#root-cause","title":"Root Cause","text":"<p>When a build tool runs an application in-process (its default mode), the build tool and the application share the same JVM, classloaders, and thread pool. On Ctrl+C, the build tool initiates its own shutdown \u2014 tearing down classloaders and internal state \u2014 while the application's threads are still running. This mismatch causes class-loading errors and prevents clean shutdown.</p> <p>The general principle: build tools and long-lived applications have conflicting shutdown lifecycles. The build tool wants to clean up and exit; the application needs to run its own graceful shutdown sequence (draining connections, flushing buffers, etc.). When they share a process, neither can shut down correctly.</p>","tags":["sbt","process-isolation","shutdown","developer-experience","server-applications"]},{"location":"learnings/build-errors/fork-long-lived-processes-from-build-tools/#solution","title":"Solution","text":"<p>Run the application in a separate (forked) process so that shutdown signals propagate directly to the application rather than being intercepted by the build tool.</p> <p>In sbt:</p> <pre><code>run / fork := true // run in a forked JVM so Ctrl+C shuts down cleanly\n</code></pre> <p>The same principle applies to other build tools (Gradle <code>JavaExec</code>, Maven exec plugin, etc.): always fork a separate process for server applications.</p>","tags":["sbt","process-isolation","shutdown","developer-experience","server-applications"]},{"location":"learnings/build-errors/fork-long-lived-processes-from-build-tools/#prevention","title":"Prevention","text":"<ul> <li>Default to forking for server apps: Any project that runs a long-lived process (HTTP server, message consumer, etc.) via the build tool should fork by default.</li> <li>Test the shutdown path: After setting up a <code>run</code> configuration, verify that Ctrl+C results in a clean shutdown \u2014 not just that the process starts correctly.</li> </ul>","tags":["sbt","process-isolation","shutdown","developer-experience","server-applications"]},{"location":"learnings/build-errors/fork-long-lived-processes-from-build-tools/#references","title":"References","text":"<ul> <li>PR #3962</li> <li><code>build.sbt</code> \u2014 <code>run / fork := true</code> setting</li> </ul>","tags":["sbt","process-isolation","shutdown","developer-experience","server-applications"]},{"location":"learnings/build-errors/non-deterministic-build-inputs-cause-recompilation/","title":"Non-deterministic build inputs cause excessive recompilation","text":"","tags":["sbt","buildinfo","incremental-compilation","build-performance","developer-experience"]},{"location":"learnings/build-errors/non-deterministic-build-inputs-cause-recompilation/#problem","title":"Problem","text":"<p>Running <code>sbt compile</code> twice in succession with no code changes still triggered a full recompilation. This made the development feedback loop unnecessarily slow \u2014 every compile took as long as a clean build.</p>","tags":["sbt","buildinfo","incremental-compilation","build-performance","developer-experience"]},{"location":"learnings/build-errors/non-deterministic-build-inputs-cause-recompilation/#root-cause","title":"Root Cause","text":"<p>The <code>build.sbt</code> used <code>Instant.now</code> and <code>BuildInfoOption.BuildTime</code> to embed a build timestamp into the generated <code>BuildInfo.scala</code> file. Because this value changed on every sbt invocation, the generated source file was always different, which invalidated sbt's incremental compilation cache and forced a full recompile.</p> <p>More generally: any non-deterministic input to the build pipeline (timestamps, random values, git-dirty flags that fluctuate) that ends up in generated source will break incremental compilation.</p>","tags":["sbt","buildinfo","incremental-compilation","build-performance","developer-experience"]},{"location":"learnings/build-errors/non-deterministic-build-inputs-cause-recompilation/#solution","title":"Solution","text":"<p>Replace non-deterministic build values with environment variables that have stable defaults for local development:</p> <pre><code>// Before: changes on every invocation, breaks incremental compilation\nlazy val buildTime = Instant.now.toString\nbuildInfoOptions += BuildInfoOption.BuildTime\n\n// After: stable default for local dev, real value injected in CI/Docker\nlazy val buildTime = sys.env.getOrElse(\"BUILD_TIME\", \"dev\")\nbuildInfoKeys += BuildInfoKey(\"buildTime\" -&gt; sys.env.getOrElse(\"BUILD_TIME\", \"dev\"))\n</code></pre> <p>The <code>Makefile</code> exports the real value for CI and Docker builds:</p> <pre><code>export BUILD_TIME := $(shell date -u +\"%Y-%m-%dT%H:%M:%SZ\")\n</code></pre> <p>This way local development gets fast incremental compilation, while production builds still get accurate metadata.</p>","tags":["sbt","buildinfo","incremental-compilation","build-performance","developer-experience"]},{"location":"learnings/build-errors/non-deterministic-build-inputs-cause-recompilation/#prevention","title":"Prevention","text":"<ul> <li>Audit generated sources for non-determinism: Any value that changes between invocations without code changes will break incremental compilation. Timestamps, random IDs, and volatile git metadata are common culprits.</li> <li>Use env vars with stable defaults: For build metadata that must vary between environments, read from environment variables with a fixed default for local dev.</li> <li>Test incremental compilation: After changing <code>build.sbt</code>, run <code>sbt compile</code> twice and verify the second run reports no recompilation.</li> </ul>","tags":["sbt","buildinfo","incremental-compilation","build-performance","developer-experience"]},{"location":"learnings/build-errors/non-deterministic-build-inputs-cause-recompilation/#references","title":"References","text":"<ul> <li>PR #3963</li> <li><code>build.sbt</code> \u2014 <code>buildTime</code> definition</li> <li><code>Makefile</code> \u2014 <code>BUILD_TIME</code> export</li> </ul>","tags":["sbt","buildinfo","incremental-compilation","build-performance","developer-experience"]},{"location":"learnings/configuration-errors/fuseki-remote-dev-db-config-recipe/","title":"Testing against the dev database was not documented or automated","text":"","tags":["fuseki","testing-workflow","local-development","justfile","developer-experience"]},{"location":"learnings/configuration-errors/fuseki-remote-dev-db-config-recipe/#problem","title":"Problem","text":"<p>The local development setup assumes a fully local Fuseki triplestore seeded with test data. For many changes this works fine, but some changes are hard to test meaningfully without realistic data. In those cases, running the API against the dev database (db.dev.dasch.swiss) is the practical option \u2014 but how to do this was neither documented nor automated. Developers had to figure out the correct environment variables, HTTPS settings, and credential management on their own.</p>","tags":["fuseki","testing-workflow","local-development","justfile","developer-experience"]},{"location":"learnings/configuration-errors/fuseki-remote-dev-db-config-recipe/#root-cause","title":"Root Cause","text":"<p>The development tooling only covered the local Docker setup (<code>just stack-start-dev</code>). The alternative workflow of connecting to the remote dev Fuseki was undocumented tribal knowledge, requiring five environment variable overrides with non-obvious values (HTTPS on port 443 instead of HTTP on 3030).</p>","tags":["fuseki","testing-workflow","local-development","justfile","developer-experience"]},{"location":"learnings/configuration-errors/fuseki-remote-dev-db-config-recipe/#solution","title":"Solution","text":"<p>Added a <code>just run-with-dev-db</code> recipe to the justfile that encapsulates all the configuration:</p> <pre><code># Run API locally against the dev Fuseki\nrun-with-dev-db:\n    #!/usr/bin/env bash\n    set -euo pipefail\n    source .env\n    export KNORA_WEBAPI_TRIPLESTORE_HOST=db.dev.dasch.swiss\n    export KNORA_WEBAPI_TRIPLESTORE_USE_HTTPS=true\n    export KNORA_WEBAPI_TRIPLESTORE_FUSEKI_PORT=443\n    export KNORA_WEBAPI_TRIPLESTORE_FUSEKI_USERNAME=admin\n    export KNORA_WEBAPI_TRIPLESTORE_FUSEKI_PASSWORD=$DEV_DB_PASSWORD\n    ./sbtx \"webapi/run\"\n</code></pre> <p>Prerequisites: A <code>.env</code> file in the repo root (git-ignored) containing <code>DEV_DB_PASSWORD=&lt;password&gt;</code>. Passwords can be found in ops-deploy/host_vars.</p>","tags":["fuseki","testing-workflow","local-development","justfile","developer-experience"]},{"location":"learnings/configuration-errors/fuseki-remote-dev-db-config-recipe/#prevention","title":"Prevention","text":"<ul> <li>Automate alternative workflows too: When the primary dev setup doesn't cover all testing scenarios, provide recipes for the alternatives.</li> <li>Avoid tribal knowledge: If a workflow needs explaining, it should be a <code>just</code> recipe instead.</li> </ul>","tags":["fuseki","testing-workflow","local-development","justfile","developer-experience"]},{"location":"learnings/configuration-errors/fuseki-remote-dev-db-config-recipe/#references","title":"References","text":"<ul> <li><code>webapi/src/main/resources/application.conf:133-165</code> \u2014 triplestore config block with env var overrides</li> <li><code>docs/04-publishing-deployment/configuration.md:41-47</code> \u2014 environment variable documentation</li> </ul>","tags":["fuseki","testing-workflow","local-development","justfile","developer-experience"]},{"location":"learnings/logic-errors/hashmap-loses-insertion-order-use-listmap/","title":"HashMap loses insertion order \u2014 use ListMap","text":"","tags":["scala","collections","hashmap","listmap","insertion-order","zio"]},{"location":"learnings/logic-errors/hashmap-loses-insertion-order-use-listmap/#problem","title":"Problem","text":"<p>Values arrived at the handler in scrambled order despite being correctly ordered during parsing. The ordering was lost somewhere in the ZIO effect pipeline.</p>","tags":["scala","collections","hashmap","listmap","insertion-order","zio"]},{"location":"learnings/logic-errors/hashmap-loses-insertion-order-use-listmap/#root-cause","title":"Root Cause","text":"<p><code>ZioHelper.sequence</code> used <code>HashMap</code> internally, which doesn't preserve insertion order:</p> <pre><code>// BUG: HashMap scrambles key ordering\nZIO.foreach(map.toList) { case (k, v) =&gt; ... }.map(_.toMap)  // .toMap -&gt; HashMap\n</code></pre>","tags":["scala","collections","hashmap","listmap","insertion-order","zio"]},{"location":"learnings/logic-errors/hashmap-loses-insertion-order-use-listmap/#solution","title":"Solution","text":"<p>Switch to <code>ListMap</code> to preserve insertion order through the ZIO effect pipeline:</p> <pre><code>// CORRECT: ListMap preserves insertion order\nZIO.foreach(map.toList) { case (k, v) =&gt; ... }.map(results =&gt; ListMap(results: _*))\n</code></pre>","tags":["scala","collections","hashmap","listmap","insertion-order","zio"]},{"location":"learnings/logic-errors/hashmap-loses-insertion-order-use-listmap/#prevention","title":"Prevention","text":"<ul> <li>In Scala, always verify which <code>Map</code> implementation flows through your code if ordering matters.</li> <li><code>HashMap</code> scrambles; <code>ListMap</code> and <code>LinkedHashMap</code> preserve insertion order.</li> <li>Pay special attention to <code>.toMap</code> calls \u2014 they produce <code>HashMap</code> by default.</li> </ul>","tags":["scala","collections","hashmap","listmap","insertion-order","zio"]},{"location":"learnings/logic-errors/hashmap-loses-insertion-order-use-listmap/#references","title":"References","text":"<ul> <li><code>ZioHelper.scala</code></li> </ul>","tags":["scala","collections","hashmap","listmap","insertion-order","zio"]},{"location":"learnings/logic-errors/inject-metadata-before-lossy-parse/","title":"Cross-parse-boundary matching is fragile \u2014 inject metadata before lossy parse","text":"","tags":["json-ld","jena","value-ordering","parsing","design-pattern","type-agnostic"]},{"location":"learnings/logic-errors/inject-metadata-before-lossy-parse/#problem","title":"Problem","text":"<p>An earlier approach (PR #3942) tried to preserve ordering by capturing JSON array positions before Jena parsing and then matching them back after using <code>knora-api:valueAsString</code>. This failed because <code>valueAsString</code> only exists on <code>TextValue</code> and <code>DateValue</code> \u2014 not on the other 13 value types.</p>","tags":["json-ld","jena","value-ordering","parsing","design-pattern","type-agnostic"]},{"location":"learnings/logic-errors/inject-metadata-before-lossy-parse/#root-cause","title":"Root Cause","text":"<p>Each value type uses a different identifying field in JSON-LD:</p> Value Type Identifying Field TextValue <code>knora-api:valueAsString</code> DateValue <code>knora-api:valueAsString</code> IntegerValue <code>knora-api:intValueAsInt</code> LinkValue <code>knora-api:linkValueHasTargetIri</code> FileValue <code>knora-api:fileValueHasFilename</code> ... (13 more types) <p>Post-hoc matching would require per-type extraction logic \u2014 fragile and hard to maintain.</p>","tags":["json-ld","jena","value-ordering","parsing","design-pattern","type-agnostic"]},{"location":"learnings/logic-errors/inject-metadata-before-lossy-parse/#solution","title":"Solution","text":"<p>Replaced the match-based approach with <code>injectOrderIndices</code>, which injects an <code>orderIndex</code> property into the raw JSON before Jena parses it. The index survives as a regular RDF property on each blank node, so no per-type matching is needed. The <code>orderHint: Option[Int]</code> field on <code>CreateValueInNewResourceV2</code> threads the index through to the handler.</p>","tags":["json-ld","jena","value-ordering","parsing","design-pattern","type-agnostic"]},{"location":"learnings/logic-errors/inject-metadata-before-lossy-parse/#prevention","title":"Prevention","text":"<ul> <li>Don't try to match values across a lossy parse boundary. Instead, inject the metadata you need before the lossy step so it comes out the other side intact.</li> <li>Prefer type-agnostic solutions over per-type extraction.</li> </ul>","tags":["json-ld","jena","value-ordering","parsing","design-pattern","type-agnostic"]},{"location":"learnings/logic-errors/inject-metadata-before-lossy-parse/#references","title":"References","text":"<ul> <li><code>ApiComplexV2JsonLdRequestParser.scala</code></li> <li><code>CreateValueInNewResourceV2</code></li> <li><code>CreateResourceV2Handler</code></li> <li>PR #3942 \u2014 earlier failed approach</li> </ul>","tags":["json-ld","jena","value-ordering","parsing","design-pattern","type-agnostic"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/","title":"Jena's JSON-LD parser loses array order","text":"","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#problem","title":"Problem","text":"<p>When creating a resource with multiple values for the same property via the API, the JSON array order was not preserved. Users expected values submitted as <code>[\"Alpha\", \"Bravo\", \"Charlie\"]</code> to appear in that exact order when reading the resource back, but the order was scrambled \u2014 especially for rich text values with standoff markup.</p>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#symptoms","title":"Symptoms","text":"<ul> <li>Plain text values sometimes appeared in the correct order (by coincidence of IRI sorting)</li> <li>Rich text values with standoff/XML consistently appeared in reversed order</li> <li>Integer values appeared in arbitrary order</li> </ul> <p>Rich text values were most visibly affected because their more complex blank node structure caused Jena to reorder them more aggressively than simple values.</p>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#root-cause","title":"Root Cause","text":"<p>Apache Jena's JSON-LD parser uses hash-based <code>GraphMem2</code> internally. JSON array order is silently lost after parsing:</p> <pre><code>// Input JSON-LD array order:  [Value-A, Value-B, Value-C]\n// After Jena parse:           [Value-C, Value-A, Value-B]  (hash-dependent)\n</code></pre> <p>This affects all value types, but rich text values (with standoff markup and mapping references) were most visibly affected because their more complex blank node structure caused Jena to reorder them more aggressively than simple values.</p>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#solution","title":"Solution","text":"","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#pre-parse-order-injection","title":"Pre-parse Order Injection","text":"<p>Inject array position indices into the JSON before Jena parses it, so the index survives as a regular RDF property on each value's blank node.</p> <pre><code>private val OrderIndexProperty = \"http://knora.org/internal/orderIndex\"\n\nprivate[common] def injectOrderIndices(rawJson: String): String =\n  rawJson.fromJson[Json.Obj].toOption match\n    case None      =&gt; rawJson\n    case Some(obj) =&gt;\n      val modified = obj.fields.map {\n        case (key, Json.Arr(values)) if !key.startsWith(\"@\") =&gt;\n          val indexed = values.zipWithIndex.map {\n            case (Json.Obj(fields), idx) =&gt;\n              Json.Obj(fields :+ (OrderIndexProperty -&gt; Json.Num(idx)))\n            case (other, _) =&gt; other\n          }\n          (key, Json.Arr(indexed))\n        case other =&gt; other\n      }\n      Json.Obj(Chunk.from(modified)).toJson\n</code></pre> <p>The injection happens in <code>RootResource.fromJsonLd</code> before Jena parsing. After Jena parses the JSON-LD, <code>extractValues</code> reads the <code>orderIndex</code> back and uses it to sort values before passing them to the creation handler.</p> <p>This approach is type-agnostic: it works on all 15 value types without needing to know their internal JSON-LD structure.</p>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#map-ordering-fix","title":"Map Ordering Fix","text":"<p><code>ZioHelper.sequence</code> was also updated to use <code>ListMap</code> instead of <code>HashMap</code> to preserve insertion order through the ZIO effect pipeline:</p> <pre><code>def sequence[K, R, A](x: Map[K, ZIO[R, Throwable, A]]): ZIO[R, Throwable, Map[K, A]] =\n  ZIO\n    .foreach(Chunk.from(x.toSeq)) { case (k, v) =&gt; v.map(k -&gt; _) }\n    .map(pairs =&gt; ListMap.from(pairs))\n</code></pre>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#test-coverage-added","title":"Test Coverage Added","text":"Test Type What It Proves Boolean values preserve order Unit JSON boolean literals work Color values preserve order Unit String-based properties work Decimal values preserve order Unit <code>xsd:decimal</code> typed literals work URI values preserve order Unit <code>xsd:anyURI</code> typed literals work Link values preserve order Unit <code>@id</code> reference objects work Rich text XML round-trip Unit Standoff XML survives injection + Jena IntValue array E2E E2E Full stack (API -&gt; triplestore -&gt; read back)","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#prevention","title":"Prevention","text":"<ul> <li>Never assume JSON array order survives a Jena parse round-trip. If array order matters, encode it explicitly as data before handing JSON to Jena \u2014 don't try to reconstruct it after.</li> <li>Test with structurally distinct value types: plain text, booleans, typed literals (<code>xsd:decimal</code>), IRI references (<code>@id</code>), and rich text with standoff all have different JSON-LD structures.</li> <li>When adding new value types, include them in <code>ValueOrderingSpec</code> to verify ordering.</li> <li>Any change to the JSON-LD parsing pipeline should re-run <code>ValueOrderingSpec</code> to catch regressions.</li> <li>E2E tests for ordering should cover at least one simple and one complex value type.</li> </ul>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/jena-jsonld-parser-loses-array-order/#references","title":"References","text":"<ul> <li><code>ApiComplexV2JsonLdRequestParser.scala</code> \u2014 injection logic</li> <li><code>ZioHelper.scala</code> \u2014 ListMap fix</li> <li><code>ValueOrderingSpec</code> \u2014 unit tests for ordering</li> <li><code>ValuesEndpointsE2ESpec</code> \u2014 E2E ordering tests</li> </ul>","tags":["json-ld","jena","value-ordering","rdf","array-order","parsing"]},{"location":"learnings/logic-errors/query-builder-refactoring-breaks-ordering/","title":"Query builder migration breaks ordering semantics","text":"","tags":["sparql","rdf4j","value-ordering","query-builder","migration","twirl"]},{"location":"learnings/logic-errors/query-builder-refactoring-breaks-ordering/#problem","title":"Problem","text":"<p>PR #3737 (October 2025) migrated value insert/update from Twirl templates to RDF4J's <code>InsertValueQueryBuilder</code>. After the migration, editing a value moved it to the end of the list instead of preserving its position.</p>","tags":["sparql","rdf4j","value-ordering","query-builder","migration","twirl"]},{"location":"learnings/logic-errors/query-builder-refactoring-breaks-ordering/#root-cause","title":"Root Cause","text":"<p>The old Twirl template (<code>addValueVersion.scala.txt</code>) correctly read <code>valueHasOrder</code> from the existing value and carried it forward on updates:</p> <pre><code># Old Twirl (correct) \u2014 preserves order on update\nOPTIONAL { ?currentValue knora-base:valueHasOrder ?order . }\n?newValue knora-base:valueHasOrder ?order .\n</code></pre> <p>The new builder used <code>MAX(order) + 1</code> for both creates and updates:</p> <pre><code>// New builder (buggy) \u2014 always appends to end\nExpressions.max(order).as(maxOrder),\nExpressions.add(maxOrder, literalOf(1)).as(nextOrder)\n</code></pre>","tags":["sparql","rdf4j","value-ordering","query-builder","migration","twirl"]},{"location":"learnings/logic-errors/query-builder-refactoring-breaks-ordering/#solution","title":"Solution","text":"<p>Branch the order calculation in <code>buildWhereClause()</code> based on operation type. Updates read from the existing value; creates keep <code>MAX + 1</code>.</p>","tags":["sparql","rdf4j","value-ordering","query-builder","migration","twirl"]},{"location":"learnings/logic-errors/query-builder-refactoring-breaks-ordering/#prevention","title":"Prevention","text":"<ul> <li>When migrating query generation (e.g., Twirl to RDF4J), explicitly verify ordering and positional semantics.</li> <li>Unit tests that only check SPARQL syntax won't catch behavioral regressions like this \u2014 test the actual query behavior.</li> </ul>","tags":["sparql","rdf4j","value-ordering","query-builder","migration","twirl"]},{"location":"learnings/logic-errors/query-builder-refactoring-breaks-ordering/#references","title":"References","text":"<ul> <li><code>InsertValueQueryBuilder.scala</code> (lines 632-654)</li> <li>PR #3737 \u2014 original migration</li> </ul>","tags":["sparql","rdf4j","value-ordering","query-builder","migration","twirl"]},{"location":"learnings/logic-errors/value-has-order-optional-cardinality/","title":"valueHasOrder is optional \u2014 file values may not have it","text":"","tags":["sparql","ontology","cardinality","value-ordering","optional-property"]},{"location":"learnings/logic-errors/value-has-order-optional-cardinality/#problem","title":"Problem","text":"<p>The edit-ordering fix failed on file values with a SPARQL binding error. The fix assumed <code>valueHasOrder</code> would always be present on a value.</p>","tags":["sparql","ontology","cardinality","value-ordering","optional-property"]},{"location":"learnings/logic-errors/value-has-order-optional-cardinality/#root-cause","title":"Root Cause","text":"<p>The ontology defines <code>valueHasOrder</code> with <code>owl:maxCardinality 1</code> (optional, not required). File values may not have this property set at all.</p>","tags":["sparql","ontology","cardinality","value-ordering","optional-property"]},{"location":"learnings/logic-errors/value-has-order-optional-cardinality/#solution","title":"Solution","text":"<p>Use <code>OPTIONAL</code> binding with a fallback to 0, matching the old Twirl template's behavior:</p> <pre><code>OPTIONAL { &lt;currentValueIri&gt; knora-base:valueHasOrder ?existingOrder . }\nBIND(IF(BOUND(?existingOrder), ?existingOrder, 0) AS ?nextOrder)\n</code></pre>","tags":["sparql","ontology","cardinality","value-ordering","optional-property"]},{"location":"learnings/logic-errors/value-has-order-optional-cardinality/#prevention","title":"Prevention","text":"<ul> <li>Always check the ontology's cardinality constraints (<code>minCardinality</code> / <code>maxCardinality</code>) before assuming a property exists on all instances.</li> <li>Use <code>OPTIONAL</code> + <code>BIND(IF(BOUND(...)))</code> for properties that may be absent.</li> </ul>","tags":["sparql","ontology","cardinality","value-ordering","optional-property"]},{"location":"learnings/logic-errors/value-has-order-optional-cardinality/#references","title":"References","text":"<ul> <li><code>InsertValueQueryBuilder.scala</code></li> <li><code>knora-ontologies/knora-base.ttl</code> \u2014 cardinality definition</li> </ul>","tags":["sparql","ontology","cardinality","value-ordering","optional-property"]},{"location":"learnings/performance/sparql-filter-not-exists-for-rare-predicates/","title":"SPARQL: prefer FILTER NOT EXISTS over positive match for rare predicates","text":"","tags":["sparql","fuseki","query-optimization","filter-not-exists","data-distribution"]},{"location":"learnings/performance/sparql-filter-not-exists-for-rare-predicates/#problem","title":"Problem","text":"<p>The <code>resourcesPerOntology</code> endpoint was extremely slow for projects with many resources. Two projects intermittently timed out after ~120s, and the total time across all 53 projects on the dev database was ~302 seconds.</p>","tags":["sparql","fuseki","query-optimization","filter-not-exists","data-distribution"]},{"location":"learnings/performance/sparql-filter-not-exists-for-rare-predicates/#root-cause","title":"Root Cause","text":"<p>The SPARQL query filtered out deleted resources with a positive triple pattern match:</p> <pre><code>?s kb:isDeleted false\n</code></pre> <p>This required Fuseki to join against every <code>isDeleted</code> triple in the graph. Since virtually no resources are ever deleted, the triplestore was scanning a huge index just to confirm what is true for 99%+ of resources.</p> <p>More generally: data distribution matters for query optimization. When one branch of a condition covers the vast majority of cases, the query pattern should be optimized for that majority. A positive match on a near-universal condition is expensive because it touches every matching triple. A negative existence check on the rare exception is cheap because it only needs to verify the absence of a few triples.</p>","tags":["sparql","fuseki","query-optimization","filter-not-exists","data-distribution"]},{"location":"learnings/performance/sparql-filter-not-exists-for-rare-predicates/#solution","title":"Solution","text":"<p>Replace the positive triple pattern with a negative existence check:</p> <pre><code>// Before: matches every non-deleted resource (expensive \u2014 scans huge index)\nval where = s.isA(toRdfIri(c)).andHas(KB.isDeleted, false).from(graph)\n\n// After: skips the rare deleted resources (cheap \u2014 checks for absence)\nval where = s.isA(toRdfIri(c)).filterNotExists(s.has(KB.isDeleted, true)).from(graph)\n</code></pre> <p>In SPARQL terms:</p> <pre><code># Before\n?s a &lt;class&gt; .\n?s kb:isDeleted false .\n\n# After\n?s a &lt;class&gt; .\nFILTER NOT EXISTS { ?s kb:isDeleted true }\n</code></pre> <p>Result: 25.8x overall speedup (302s to 12s), with individual projects seeing up to 120x improvement. Projects that previously timed out now complete in 1-9 seconds.</p>","tags":["sparql","fuseki","query-optimization","filter-not-exists","data-distribution"]},{"location":"learnings/performance/sparql-filter-not-exists-for-rare-predicates/#prevention","title":"Prevention","text":"<ul> <li>Consider data distribution when writing queries: Ask \"which branch is the common case?\" When filtering on a condition that is almost always true (or almost always false), structure the query to optimize for the common case.</li> <li>Prefer <code>FILTER NOT EXISTS</code> for rare exceptions: When excluding a small minority of results (soft-deleted records, flagged items, etc.), use <code>FILTER NOT EXISTS</code> to check for the rare exception rather than positively matching the common case.</li> <li>Benchmark against realistic data: This issue was invisible in unit tests with small datasets. Always validate query performance against production-scale data when optimizing.</li> </ul>","tags":["sparql","fuseki","query-optimization","filter-not-exists","data-distribution"]},{"location":"learnings/performance/sparql-filter-not-exists-for-rare-predicates/#references","title":"References","text":"<ul> <li>PR #3961</li> <li><code>webapi/src/main/scala/org/knora/webapi/slice/resources/repo/service/ResourcesRepoLive.scala:296</code></li> </ul>","tags":["sparql","fuseki","query-optimization","filter-not-exists","data-distribution"]},{"location":"learnings/test-failures/alphabetical-test-data-masks-ordering/","title":"Alphabetically-sorted test data masks ordering bugs","text":"","tags":["testing","test-data","value-ordering","false-positive","non-determinism"]},{"location":"learnings/test-failures/alphabetical-test-data-masks-ordering/#problem","title":"Problem","text":"<p>The E2E test for batch-create value ordering passed despite the bug existing in production.</p>","tags":["testing","test-data","value-ordering","false-positive","non-determinism"]},{"location":"learnings/test-failures/alphabetical-test-data-masks-ordering/#root-cause","title":"Root Cause","text":"<p>Test values were <code>[\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\"]</code> \u2014 alphabetically sorted. Jena's hash-based scrambling happened to produce the same alphabetical order, so the test passed by coincidence:</p> <pre><code>// Input:  [\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\"]\n// Jena:   [\"Alpha\", \"Bravo\", \"Charlie\", \"Delta\", \"Echo\"]  &lt;- coincidence!\n// Real:   [\"Delta\", \"Alpha\", \"Echo\", \"Bravo\", \"Charlie\"]  &lt;- what actually happens with non-alpha data\n</code></pre>","tags":["testing","test-data","value-ordering","false-positive","non-determinism"]},{"location":"learnings/test-failures/alphabetical-test-data-masks-ordering/#solution","title":"Solution","text":"<p>Replaced with non-alphabetical test data and added a 10-value stress test to increase the probability of catching non-deterministic ordering.</p>","tags":["testing","test-data","value-ordering","false-positive","non-determinism"]},{"location":"learnings/test-failures/alphabetical-test-data-masks-ordering/#prevention","title":"Prevention","text":"<ul> <li>When testing ordering, always use non-alphabetical, non-sequential test data (e.g., <code>[\"Delta\", \"Alpha\", \"Echo\", \"Bravo\", \"Charlie\"]</code>).</li> <li>Add stress tests with larger datasets (10+ items) \u2014 small datasets have higher odds of accidentally matching hash output.</li> </ul>","tags":["testing","test-data","value-ordering","false-positive","non-determinism"]},{"location":"learnings/test-failures/alphabetical-test-data-masks-ordering/#references","title":"References","text":"<ul> <li><code>ValuesEndpointsE2ESpec.scala</code></li> </ul>","tags":["testing","test-data","value-ordering","false-positive","non-determinism"]}]}