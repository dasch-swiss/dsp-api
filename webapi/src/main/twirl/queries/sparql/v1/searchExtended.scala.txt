@*
 * Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and André Fatton.
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi.IRI
@import org.knora.webapi.twirl.SearchCriterion
@import org.knora.webapi.messages.v1.responder.searchmessages.SearchComparisonOperatorV1
@import org.knora.webapi.SparqlGenerationException

@**
 * Performs an extended search. The number of rows returned per matching resource is the product of the number of
 * values that each search criterion matched in the resource.
 *
 * @param triplestore the name of the triplestore being used.
 * @param searchCriteria a list of maps containing search criteria, each of which contains:
 * @param preferredLanguage the language code of the user's preferred language.
 * @param fallbackLanguage the language code of the application's default language.
 * @param projectIri if filtering by project is desired, the IRI of the project to search.
 * @param restypeIri if filtering by resource type is desired, the IRI of the resource type to search for.
 * @param ownerIri if filtering by owner is desired, the IRI of the resource owner to search for.
 * @param limit the maximum number of results to re
 *@
@(triplestore: String,
  searchCriteria: Seq[SearchCriterion],
  preferredLanguage: String,
  fallbackLanguage: String,
  projectIriOption: Option[IRI],
  restypeIriOption: Option[IRI],
  ownerIriOption: Option[IRI])

prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix knora-base: <http://www.knora.org/ontology/knora-base#>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>

SELECT DISTINCT
    ?resource
    ?resourceLabel @* The label of a matching resource. This is called "firstprop" in the v1 API. *@
    ?resourceClass
    ?previewPath
    ?previewDimX
    ?previewDimY
    ?resourceOwner
    ?resourceProject
    @for((searchCriterion, index) <- searchCriteria.zipWithIndex) {
        ?valueObject@index
        ?valueOwner@index
        ?valueProject@index
        ?targetResource@index
        ?literal@index
        (GROUP_CONCAT(DISTINCT(?valuePermission@index); separator=";") AS ?valuePermissions@index)
    }
    (GROUP_CONCAT(DISTINCT(?resourcePermission); separator=";") AS ?resourcePermissions)
@* Ensure that inference is not used in this query. *@
@if(triplestore.startsWith("graphdb")) {
    FROM <http://www.ontotext.com/explicit>
}
WHERE {
    BIND(STR("@preferredLanguage") AS ?preferredLanguage)
    BIND(STR("@fallbackLanguage") AS ?fallbackLanguage)

    @for((searchCriterion, index) <- searchCriteria.zipWithIndex) {

        # Search criterion @index: operator @searchCriterion.comparisonOperator

        @*

        If this search criterion involves a property that points to a knora-base:Value, find a resource that has
        that property pointing to some value. If this search criterion involves a link property, the property will
        point to another resource, and this is handled in the cases for comparison operators EQ and EXISTS in the
        match-case expression below.

        *@

        @if(searchCriterion.valueType != "http://www.knora.org/ontology/knora-base#Resource") {
            ?resource <@{searchCriterion.propertyIri}> ?valueObject@index .
        }

        @*

        possible values of searchCriterion.comparisonOperator: EXISTS, EQ, NOT_EQ, GT, GT_EQ, LT, LT_EQ, MATCH, MATCH_BOOLEAN, LIKE, NOT_LIKE, IN

        *@

        @searchCriterion.comparisonOperator match {

            case SearchComparisonOperatorV1.MATCH => {

                @*

                    TODO: Handle single search terms correctly: combine them with an AND

                *@

                @triplestore match {

                    case "graphdb" | "graphdb-free" => {

                        ?valueObject@index knora-base:valueHasString ?literal@index .
                        ?literal@index <http://www.ontotext.com/owlim/lucene#fullTextSearchIndex> '@searchCriterion.searchValue' .

                    }

                    case "embedded-jena-tdb" | "fuseki" => {

                        ?valueObject@index <http://jena.apache.org/text#query> ( '@searchCriterion.searchValue' ) .
                        ?valueObject@index knora-base:valueHasString ?literal@index .

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Triplestore type $other is not supported in this SPARQL template"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.LIKE => {

                @* TODO: escape regex metachars *@
                ?valueObject@index knora-base:valueHasString ?literal@index .

                FILTER regex(?literal@index, '@searchCriterion.searchValue', "i")
            }

            case SearchComparisonOperatorV1.NOT_LIKE => {

                @*

                Previously we used FILTER NOT EXISTS here, but then we couldn't get the value of ?literal
                (the literal that doesn't match the regex). So now we use just a negated regex. However, if a
                resource has two instances of the same property and one of them matches and the other doesn't,
                it will be returned in the search results.

                *@

                ?valueObject@index knora-base:valueHasString ?literal@index .

                FILTER (!regex(?literal@index, '@searchCriterion.searchValue', "i"))
            }

            case SearchComparisonOperatorV1.EXISTS => {

                @searchCriterion.valueType match {
                    case "http://www.knora.org/ontology/knora-base#Resource" => {

                        ?resource <@searchCriterion.propertyIri> ?targetResource@index .

                        ?targetResource@index rdfs:label ?literal@index ;
                            knora-base:isDeleted false .

                        ?resource <@{searchCriterion.propertyIri}Value> ?valueObject@index .

                        ?valueObject@index rdf:type knora-base:LinkValue ;
                            rdf:subject ?resource ;
                            rdf:predicate <@searchCriterion.propertyIri> ;
                            rdf:object ?targetResource@index .
                    }

                    case other => {

                        ?valueObject@index knora-base:valueHasString ?literal@index .

                    }
                }
            }

            case SearchComparisonOperatorV1.EQ => {

                @searchCriterion.valueType match {

                    case "http://www.knora.org/ontology/knora-base#TextValue" => {

                        ?valueObject@index knora-base:valueHasString '@searchCriterion.searchValue' .

                        BIND('@searchCriterion.searchValue' AS ?literal@index)

                    }

                    case "http://www.knora.org/ontology/knora-base#IntValue" => {

                        ?valueObject@index knora-base:valueHasInteger @searchCriterion.searchValue .

                        BIND('@searchCriterion.searchValue' AS ?literal@index)

                    }

                    case "http://www.knora.org/ontology/knora-base#DecimalValue" => {

                        ?valueObject@index knora-base:valueHasDecimal @searchCriterion.searchValue .

                        BIND('@searchCriterion.searchValue' AS ?literal@index)

                    }

                    case "http://www.knora.org/ontology/knora-base#DateValue" => {

                        ?valueObject@index knora-base:valueHasStartJDC ?dateStart@index .
                        ?valueObject@index knora-base:valueHasEndJDC ?dateEnd@index .
                        ?valueObject@index knora-base:valueHasString ?dateString@index .

                        FILTER (@searchCriterion.dateStart <= ?dateEnd@index && @searchCriterion.dateEnd >= ?dateStart@index)
                        BIND(?dateString@index as ?literal@index)

                    }

                    case "http://www.knora.org/ontology/knora-base#Resource" => {

                        BIND(IRI("@searchCriterion.searchValue") AS ?targetResource@index)
                        
                        ?resource <@searchCriterion.propertyIri> <@searchCriterion.searchValue> .

                        <@searchCriterion.searchValue> rdfs:label ?literal@index ;
                            knora-base:isDeleted false .

                        ?resource <@{searchCriterion.propertyIri}Value> ?valueObject@index .

                        ?valueObject@index rdf:type knora-base:LinkValue ;
                            rdf:subject ?resource ;
                            rdf:predicate <@searchCriterion.propertyIri> ;
                            rdf:object <@searchCriterion.searchValue> .
                    }

                    case "http://www.knora.org/ontology/knora-base#ListValue" => {

                        @*

                        Get all the subnodes of the given node, including the given node (operator *)

                        *@

                        ?valueObject@index knora-base:valueHasListNode ?listNode .
                        <@searchCriterion.searchValue> knora-base:hasSubListNode* ?listNode .

                        ?listNode rdfs:label ?listNodeLabel .
                        BIND(?listNodeLabel AS ?literal@index)

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Value type $other is not supported with comparison operator ${searchCriterion.comparisonOperator}"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.NOT_EQ => {

                @searchCriterion.valueType match {

                    case "http://www.knora.org/ontology/knora-base#TextValue" => {

                        ?valueObject@index knora-base:valueHasString ?literal@index .

                        FILTER (?literal@index != '@searchCriterion.searchValue')

                    }

                    case "http://www.knora.org/ontology/knora-base#IntValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index != @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DecimalValue" => {

                        ?valueObject@index knora-base:valueHasDecimal ?literal@index .

                        FILTER (?literal@index != @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DateValue" => {

                        ?valueObject@index knora-base:valueHasStartJDC ?dateStart@index .
                        ?valueObject@index knora-base:valueHasEndJDC ?dateEnd@index .
                        ?valueObject@index knora-base:valueHasString ?dateString@index .

                        FILTER (@searchCriterion.dateEnd < ?dateStart@index || @searchCriterion.dateStart > ?dateEnd@index )
                        BIND(?dateString@index as ?literal@index)

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Value type $other is not supported with comparison operator ${searchCriterion.comparisonOperator}"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.GT => {

                @searchCriterion.valueType match {

                    case "http://www.knora.org/ontology/knora-base#IntValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index > @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DecimalValue" => {

                        ?valueObject@index knora-base:valueHasDecimal ?literal@index .

                        FILTER (?literal@index > searchCriterion.searchValue )

                    }

                    case "http://www.knora.org/ontology/knora-base#DateValue" => {

                        ?valueObject@index knora-base:valueHasStartJDC ?dateStart@index .
                        ?valueObject@index knora-base:valueHasString ?dateString@index .

                        FILTER (?dateStart@index > @searchCriterion.dateEnd)
                        BIND(?dateString@index as ?literal@index)

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Value type $other is not supported with comparison operator ${searchCriterion.comparisonOperator}"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.GT_EQ => {

                @searchCriterion.valueType match {

                    case "http://www.knora.org/ontology/knora-base#IntValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index >= @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DecimalValue" => {

                        ?valueObject@index knora-base:valueHasDecimal ?literal@index .

                        FILTER (?literal@index >= @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DateValue" => {

                        ?valueObject@index knora-base:valueHasStartJDC ?dateStart@index .
                        ?valueObject@index knora-base:valueHasString ?dateString@index .

                        FILTER (?dateStart@index >= @searchCriterion.dateEnd)
                        BIND(?dateString@index as ?literal@index)

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Value type $other is not supported with comparison operator ${searchCriterion.comparisonOperator}"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.LT => {

                @searchCriterion.valueType match {

                    case "http://www.knora.org/ontology/knora-base#IntValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index < @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DecimalValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index < @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DateValue" => {

                        ?valueObject@index knora-base:valueHasEndJDC ?dateEnd@index .
                        ?valueObject@index knora-base:valueHasString ?dateString@index .

                        FILTER (?dateEnd@index < @searchCriterion.dateStart)
                        BIND(?dateString@index as ?literal@index)

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Value type $other is not supported with comparison operator ${searchCriterion.comparisonOperator}"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.LT_EQ => {

                @searchCriterion.valueType match {

                    case "http://www.knora.org/ontology/knora-base#IntValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index <= @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DecimalValue" => {

                        ?valueObject@index knora-base:valueHasInteger ?literal@index .

                        FILTER (?literal@index <= @searchCriterion.searchValue)

                    }

                    case "http://www.knora.org/ontology/knora-base#DateValue" => {

                        ?valueObject@index knora-base:valueHasEndJDC ?dateEnd@index .
                        ?valueObject@index knora-base:valueHasString ?dateString@index .

                        FILTER (?dateEnd@index <= @searchCriterion.dateStart)
                        BIND(?dateString@index as ?literal@index)

                    }

                    case other => {
                        @{throw SparqlGenerationException(s"Value type $other is not supported with comparison operator ${searchCriterion.comparisonOperator}"); ()}
                    }
                }
            }

            case SearchComparisonOperatorV1.MATCH_BOOLEAN => {

                @* see https://dev.mysql.com/doc/refman/5.5/en/fulltext-boolean.html *@

                ?valueObject@index knora-base:valueHasString ?literal@index .

                @for(positiveTerm <- searchCriterion.matchBooleanPositiveTerms) {

                    @triplestore match {

                        case "graphdb" | "graphdb-free" => {

                            ?literal@index <http://www.ontotext.com/owlim/lucene#fullTextSearchIndex> '@positiveTerm' .

                        }

                        case "embedded-jena-tdb" | "fuseki" => {

                            ?valueObject@index <http://jena.apache.org/text#query> ( '@positiveTerm' ) .

                        }

                        case other => {
                            @{throw SparqlGenerationException(s"Triplestore type $other is not supported in this SPARQL template"); ()}
                        }
                    }
                }

                @if(searchCriterion.matchBooleanNegativeTerms.nonEmpty) {
                    MINUS {
                        @for(negativeTerm <- searchCriterion.matchBooleanNegativeTerms) {

                            @triplestore match {

                                case "graphdb" | "graphdb-free" => {

                                    ?literal@index <http://www.ontotext.com/owlim/lucene#fullTextSearchIndex> '@negativeTerm' .

                                }

                                case "embedded-jena-tdb" | "fuseki" => {

                                    ?valueObject@index <http://jena.apache.org/text#query> ( '@negativeTerm' ) .

                                }

                                case other => {
                                    @{throw SparqlGenerationException(s"Triplestore type $other is not supported in this SPARQL template"); ()}
                                }
                            }
                        }
                    }
                }
            }

            case other => {
                @{throw SparqlGenerationException(s"Comparison operator $other is not supported in this SPARQL template"); ()}
            }
        }

        ?valueObject@index knora-base:isDeleted false ;
            knora-base:attachedToUser ?valueOwner@index .

        OPTIONAL {
            ?valueObject@index knora-base:attachedToProject ?valueProject@index .
        }

        OPTIONAL {
            ?valuePermissionProp@index rdfs:subPropertyOf+ knora-base:hasPermission .
            ?valueObject@index ?valuePermissionProp@index ?valuePermissionGroup@index .
            BIND(CONCAT(STR(?valuePermissionProp@index), ",", STR(?valuePermissionGroup@index)) as ?valuePermission@index)
        }
    }

    ?resource knora-base:isDeleted false .
    ?resource rdfs:label ?resourceLabel .
    ?resource a ?resourceClass .

    @projectIriOption match {
        case Some(projectIri) => {

            # filter by projectIri
            ?resource knora-base:attachedToProject <@projectIri> .

        }

        case None => {}
    }

    @restypeIriOption match {
        case Some(restypeIri) => {

            # filter by restypeIri
            ?resource a <@restypeIri> .
        }

        case None => {}
    }


    @ownerIriOption match {
        case Some(ownerIri) => {

            # filter by ownerIri
            ?resource knora-base:attachedToUser <@ownerIri> .
        }

        case None => {}
    }

    OPTIONAL {
        ?resource knora-base:hasStillImageFileValue ?fileValue .
        ?fileValue a knora-base:StillImageFileValue .
        ?fileValue knora-base:isPreview true .
        ?fileValue knora-base:internalFilename ?previewPath .

        OPTIONAL {
            ?fileValue knora-base:dimX ?previewDimX .
            ?fileValue knora-base:dimY ?previewDimY .
        }
    }

    OPTIONAL {
        ?resourcePermissionProp rdfs:subPropertyOf+ knora-base:hasPermission .
        ?resource ?resourcePermissionProp ?resourcePermissionGroup .
        BIND(CONCAT(STR(?resourcePermissionProp), ",", STR(?resourcePermissionGroup)) as ?resourcePermission)
    }

    OPTIONAL {
        ?resource knora-base:attachedToUser ?resourceOwner .
    }

    OPTIONAL {
        ?resource knora-base:attachedToProject ?resourceProject .
    }
}
GROUP BY
    ?resource
    ?resourceLabel
    ?resourceClass
    ?previewPath
    ?previewDimX
    ?previewDimY
    ?resourceOwner
    ?resourceProject
    @for((searchCriterion, index) <- searchCriteria.zipWithIndex) {
        ?valueObject@index
        ?valueOwner@index
        ?valueProject@index
        ?targetResource@index
        ?literal@index
    }
LIMIT 500
