@*
 * Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and André Fatton.
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi._
@import org.knora.webapi.twirl.SparqlTemplateLinkUpdate
@import org.knora.webapi.messages.v1respondermessages.valuemessages._

@**
 * Generates statements to be added to the WHERE clause of a SPARQL update when creating a new value of a resource
 * property (as opposed to a new version of an existing value).
 *
 * @param valueIndex the index of the value in the sequence of values that are being created in the transaction (can
 *                   be 0 if only one value is being created). This index will be used to make SPARQL variable names
 *                   specific to the value being created.
 * @param resourceIri the resource to update.
 * @param propertyIri the resource property to update.
 * @param newValueIri the new value IRI.
 * @param valueTypeIri the type of the new value.
 * @param linkUpdates a list of [[LinkUpdate]] objects describing links and LinkValues that need to be
 *        updated for resource references in Standoff text values. This list will be empty if the links and LinkValues
 *        are being created separately.
 * @param maybeValueHasOrder an optional value for the knora-base:valueHasOrder predicate of the new value. If not
 *                           provided, the value of this predicate will be calculated using a subquery.
 *
 * The SPARQL variables `?resource` and `?resourceClass` must already be bound.
 *@
@(valueIndex: Int,
  resourceIri: IRI,
  propertyIri: IRI,
  newValueIri: IRI,
  valueTypeIri: IRI,
  linkUpdates: Seq[SparqlTemplateLinkUpdate],
  maybeValueHasOrder: Option[Int])

    # Value @valueIndex
    # Property: @propertyIri

    BIND(IRI("@propertyIri") AS ?property@valueIndex)
    BIND(IRI("@newValueIri") AS ?newValue@valueIndex)
    BIND(IRI("@valueTypeIri") AS ?valueType@valueIndex)

    @* Do nothing if the submitted value has the wrong type. *@

    ?property@valueIndex knora-base:objectClassConstraint ?propertyRange@valueIndex .
    ?valueType@valueIndex rdfs:subClassOf* ?propertyRange@valueIndex .

    @* Do nothing if neither the resource class nor any of its superclasses has a cardinality for this property. *@

    ?resourceClass rdfs:subClassOf* ?restriction@valueIndex .
    ?restriction@valueIndex a owl:Restriction .
    ?restriction@valueIndex owl:onProperty ?property@valueIndex .

    @*

    If this template is being used to create a single text value, there may be existing LinkValues that need to be updated
    for standoff links in the text. In that case, check the state of those LinkValues. For each existing LinkValue,
    bind a SPARQL variable ?linkValueN, where N is an index in the sequence linkUpdates. This is necessary so that
    a new version of the LinkValue can be inserted and point to the previous one.

    If this template is being used to create multiple values in an empty resource, linkUpdates will be empty, so there
    is nothing to check here and no SPARQL variables to bind.

    *@

    @for((linkUpdate, linkValueIndex) <- linkUpdates.zipWithIndex) {
        @if(linkUpdate.insertDirectLink) {
            @*

            Do nothing if we were asked to insert a direct link to a target that doesn't exist, is marked as deleted,
            isn't a knora-base:Resource, or belongs to the wrong OWL class for the link property.

            *@

            <@linkUpdate.linkTargetIri> rdf:type ?linkTargetClass@linkValueIndex .

            MINUS {
                <@linkUpdate.linkTargetIri> knora-base:isDeleted true .
            }

            ?linkTargetClass@linkValueIndex rdfs:subClassOf+ knora-base:Resource .
            <@linkUpdate.linkPropertyIri> knora-base:objectClassConstraint ?expectedTargetClass@linkValueIndex .
            ?linkTargetClass@linkValueIndex rdfs:subClassOf* ?expectedTargetClass@linkValueIndex .
        }

        @if(linkUpdate.directLinkExists) {
            @* Make sure the relevant direct link exists between the two resources. *@
            ?resource <@linkUpdate.linkPropertyIri> <@linkUpdate.linkTargetIri> .
        } else {
            @* Make sure there no such direct link. *@
            MINUS {
                ?resource <@linkUpdate.linkPropertyIri> <@linkUpdate.linkTargetIri> .
            }
        }

        @if(linkUpdate.linkValueExists) {
            @*

            Make sure a knora-base:LinkValue exists, describing the relevant direct link
            between the source and target resources, and has the correct reference count.

            *@
            ?resource <@{linkUpdate.linkPropertyIri}Value> ?linkValue@linkValueIndex .
            ?linkValue@linkValueIndex rdf:type knora-base:LinkValue ;
                rdf:subject ?resource ;
                rdf:predicate <@linkUpdate.linkPropertyIri> ;
                rdf:object <@linkUpdate.linkTargetIri> ;
                knora-base:valueHasRefCount @linkUpdate.currentReferenceCount .

            MINUS {
                ?linkValue@linkValueIndex knora-base:isDeleted true .
            }
        } else {
            @* Make sure there is no such knora-base:LinkValue. *@
            MINUS {
                ?resource <@{linkUpdate.linkPropertyIri}Value> ?linkValue@linkValueIndex .
                ?linkValue@linkValueIndex rdf:type knora-base:LinkValue ;
                    rdf:subject ?resource ;
                    rdf:predicate <@linkUpdate.linkPropertyIri> ;
                    rdf:object <@linkUpdate.linkTargetIri> .

                MINUS {
                  ?linkValue@linkValueIndex knora-base:isDeleted true .
                }
            }
        }
    }

    @*

    Bind a variable for knora-base:valueHasOrder for the new value.

    If this template is being used to create a single value, maybeValueHasOrder will be None, and we have to do a subquery
    to determine the next available knora-base:valueHasOrder. This works as follows: if the property already has one or more
    (non-deleted) values in the resource, find the one with the highest order, add 1 to its order, and give the resulting
    order to the new value. Otherwise, give the new value an order of 0.

    If this template is being used to create multiple values in an empty resource, there are no existing values to query in
    the resource, so maybeValueHasOrder will contain the knora-base:valueHasOrder to be used.

    *@

    @maybeValueHasOrder match {
        case Some(valueHasOrder) => {

            BIND(@valueHasOrder AS ?nextOrder@valueIndex)

        }

        case None => {

            {
                SELECT ((MAX(?order@valueIndex)) AS ?maxOrder@valueIndex) (IF(BOUND(?maxOrder@valueIndex), ?maxOrder@valueIndex + 1, 0) AS ?nextOrder@valueIndex)
                WHERE {
                    <@resourceIri> <@propertyIri> ?otherValue@valueIndex .
                    ?otherValue@valueIndex knora-base:valueHasOrder ?order@valueIndex .

                    MINUS {
                      ?otherValue@valueIndex knora-base:isDeleted true .
                    }
                }
            }

        }
    }
