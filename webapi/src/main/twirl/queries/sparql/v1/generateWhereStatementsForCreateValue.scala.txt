@*
 * Copyright © 2015 Lukas Rosenthaler, Benjamin Geer, Ivan Subotic,
 * Tobias Schweizer, André Kilchenmann, and André Fatton.
 *
 * This file is part of Knora.
 *
 * Knora is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Knora is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public
 * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
 *@

@import org.knora.webapi._
@import org.knora.webapi.twirl.SparqlTemplateLinkUpdate
@import org.knora.webapi.messages.v1.responder.valuemessages._

@**
 * Generates statements to be added to the WHERE clause of a SPARQL update when creating a new value of a resource
 * property (as opposed to a new version of an existing value). This template is used in two contexts: when creating a
 * single value in an existing resource, and when creating a new resource with its initial values.
 *
 * @param resourceIndex the index of the resource
 * @param valueIndex the index of the value in the sequence of values that are being created in the transaction (can
 *                   be 0 if only one value is being created). This index will be used to make SPARQL variable names
 *                   specific to the value being created.
 * @param resourceIri the resource to update.
 * @param propertyIri the resource property to update.
 * @param newValueIri the new value IRI.
 * @param valueTypeIri the type of the new value.
 * @param linkUpdates a list of [[LinkUpdate]] objects describing links and LinkValues that need to be
 *        updated for resource references in Standoff text values. This list will be empty if the links and LinkValues
 *        are being created separately.
 * @param maybeValueHasOrder an optional value for the knora-base:valueHasOrder predicate of the new value. If not
 *                           provided, the value of this predicate will be calculated using a subquery.
 *
 * The SPARQL variables `?resource` and `?resourceClass` must already be bound.
 *@
@(
  resourceIndex: Int,
  valueIndex: Int,
  resourceIri: IRI,
  propertyIri: IRI,
  newValueIri: IRI,
  valueTypeIri: IRI,
  linkUpdates: Seq[SparqlTemplateLinkUpdate],
  maybeValueHasOrder: Option[Int])

    # Value {@resourceIndex}_{@valueIndex}
    # Property: @propertyIri

    BIND(IRI("@propertyIri") AS ?property{@resourceIndex}_{@valueIndex})
    BIND(IRI("@newValueIri") AS ?newValue{@resourceIndex}_{@valueIndex})
    BIND(IRI("@valueTypeIri") AS ?valueType{@resourceIndex}_{@valueIndex})

    @* Do nothing if the submitted value has the wrong type. *@

    ?property{@resourceIndex}_{@valueIndex} knora-base:objectClassConstraint ?propertyRange{@resourceIndex}_{@valueIndex} .
    ?valueType{@resourceIndex}_{@valueIndex} rdfs:subClassOf* ?propertyRange{@resourceIndex}_{@valueIndex} .

    @* Do nothing if neither the resource class nor any of its superclasses has a cardinality for this property. *@

    ?resourceClass rdfs:subClassOf* ?restriction{@resourceIndex}_{@valueIndex} .
    ?restriction{@resourceIndex}_{@valueIndex} a owl:Restriction .
    ?restriction{@resourceIndex}_{@valueIndex} owl:onProperty ?property{@resourceIndex}_{@valueIndex} .

    @*

    If this template is being used to create a single text value in an existing resource, there may be existing
    LinkValues that need to be updated for standoff links in the text. In that case, check the state of those
    LinkValues. For each existing LinkValue, bind a SPARQL variable ?linkValue@linkValueIndex. This is necessary so
    that a new version of the LinkValue can be inserted and point to the previous one.

    If this template is being used to create a new resource with its initial values, linkUpdates will be empty, so there
    is nothing to check here and no SPARQL variables to bind.

    *@

    @for((linkUpdate, linkValueIndex) <- linkUpdates.zipWithIndex) {
        @if(linkUpdate.insertDirectLink) {
            @*

            Do nothing if we were asked to insert a direct link to a target that doesn't exist, is marked as deleted,
            isn't a knora-base:Resource, or belongs to the wrong OWL class for the link property.

            *@

            <@linkUpdate.linkTargetIri> rdf:type ?linkTargetClass{@resourceIndex}_{@linkValueIndex} ;
                knora-base:isDeleted false .

            ?linkTargetClass{@resourceIndex}_{@linkValueIndex} rdfs:subClassOf* knora-base:Resource .
            <@linkUpdate.linkPropertyIri> knora-base:objectClassConstraint ?expectedTargetClass{@resourceIndex}_{@linkValueIndex} .
            ?linkTargetClass{@resourceIndex}_{@linkValueIndex} rdfs:subClassOf* ?expectedTargetClass{@resourceIndex}_{@linkValueIndex} .
        }

        @if(linkUpdate.directLinkExists) {
            @* Make sure the relevant direct link exists between the two resources. *@
            ?resource <@linkUpdate.linkPropertyIri> <@linkUpdate.linkTargetIri> .
        } else {
            @* Make sure there no such direct link. *@
            MINUS {
                ?resource <@linkUpdate.linkPropertyIri> <@linkUpdate.linkTargetIri> .
            }
        }

        @if(linkUpdate.linkValueExists) {
            @*

            Make sure a knora-base:LinkValue exists, describing the relevant direct link
            between the source and target resources, and has the correct reference count.

            *@
            ?resource <@{linkUpdate.linkPropertyIri}Value> ?linkValue{@resourceIndex}_{@linkValueIndex} .
            ?linkValue{@resourceIndex}_{@linkValueIndex} rdf:type knora-base:LinkValue ;
                rdf:subject ?resource ;
                rdf:predicate <@linkUpdate.linkPropertyIri> ;
                rdf:object <@linkUpdate.linkTargetIri> ;
                knora-base:valueHasRefCount @linkUpdate.currentReferenceCount ;
                knora-base:isDeleted false .

        } else {
            @* Make sure there is no such knora-base:LinkValue. *@
            MINUS {
                ?resource <@{linkUpdate.linkPropertyIri}Value> ?linkValue{@resourceIndex}_{@linkValueIndex} .
                ?linkValue{@resourceIndex}_{@linkValueIndex} rdf:type knora-base:LinkValue ;
                    rdf:subject ?resource ;
                    rdf:predicate <@linkUpdate.linkPropertyIri> ;
                    rdf:object <@linkUpdate.linkTargetIri> ;
                    knora-base:isDeleted false .
            }
        }
    }

    @*

    Bind a variable for knora-base:valueHasOrder for the new value.

    If this template is being used to create a single value, maybeValueHasOrder will be None, and we have to do a subquery
    to determine the next available knora-base:valueHasOrder. This works as follows: if the property already has one or more
    (non-deleted) values in the resource, find the one with the highest order, add 1 to its order, and give the resulting
    order to the new value. Otherwise, give the new value an order of 0.

    If this template is being used to create a new resource with its initial values, there are no existing values to query in
    the resource, and maybeValueHasOrder will contain the knora-base:valueHasOrder to be used.

    *@

    @maybeValueHasOrder match {
        case Some(valueHasOrder) => {

            BIND(@valueHasOrder AS ?nextOrder{@resourceIndex}_{@valueIndex})

        }

        case None => {

            {
                SELECT ((MAX(?order{@resourceIndex}_{@valueIndex})) AS ?maxOrder{@resourceIndex}_{@valueIndex}) (IF(BOUND(?maxOrder{@resourceIndex}_{@valueIndex}), ?maxOrder{@resourceIndex}_{@valueIndex} + 1, 0) AS ?nextOrder{@resourceIndex}_{@valueIndex})
                WHERE {
                    <@resourceIri> <@propertyIri> ?otherValue{@resourceIndex}_{@valueIndex} .
                    ?otherValue{@resourceIndex}_{@valueIndex} knora-base:valueHasOrder ?order{@resourceIndex}_{@valueIndex} ;
                        knora-base:isDeleted false .
                }
            }

        }
    }
